[
{
  "model": "auth.user",
  "fields": {
    "password": "pbkdf2_sha256$24000$t3rb4O4vMlbY$DabdNnj/jJ7Mr3xhcPU9bL+RpFjpzR9hc6BajG4FZkg=",
    "last_login": "2019-01-24T16:34:07",
    "is_superuser": true,
    "username": "rcm",
    "first_name": "Rob2",
    "last_name": "Miller",
    "email": "rcm@mit.edu",
    "is_staff": true,
    "is_active": true,
    "date_joined": "2011-08-22T21:53:16",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-05-20T09:00:27",
    "is_superuser": true,
    "username": "caronoff",
    "first_name": "Caroline B",
    "last_name": "Aronoff",
    "email": "caronoff@mit.edu",
    "is_staff": true,
    "is_active": true,
    "date_joined": "2012-09-07T23:47:11",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-05-17T17:00:45",
    "is_superuser": true,
    "username": "lu16j",
    "first_name": "Richard",
    "last_name": "Lu",
    "email": "lu16j@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2013-09-05T13:29:47",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-04-30T21:47:08",
    "is_superuser": false,
    "username": "nibr",
    "first_name": "Olivia",
    "last_name": "Brode-Roger",
    "email": "nibr@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2014-09-08T09:26:58",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-05-18T02:13:28",
    "is_superuser": true,
    "username": "zlily",
    "first_name": "Lily",
    "last_name": "Zhang",
    "email": "zlily@mit.edu",
    "is_staff": true,
    "is_active": true,
    "date_joined": "2014-09-08T09:27:01",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "pbkdf2_sha256$10000$C5RPzaUDP7pb$Y6au/vAL5+aVADnvIknUqwkZMMY3PsFEwz9r/DcwcuU=",
    "last_login": "2018-04-27T13:16:09",
    "is_superuser": false,
    "username": "a2z",
    "first_name": "Aaron",
    "last_name": "Zeng",
    "email": "a2z@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2015-02-06T13:48:46",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-08-25T14:42:12",
    "is_superuser": false,
    "username": "psy01212",
    "first_name": "Joseph",
    "last_name": "Park",
    "email": "psy01212@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2015-02-06T13:48:58",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-05-19T22:09:41",
    "is_superuser": false,
    "username": "varot",
    "first_name": "Varot",
    "last_name": "Premtoon",
    "email": "varot@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2015-02-06T13:49:00",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-04-26T21:31:28",
    "is_superuser": false,
    "username": "jeaniep",
    "first_name": "Jeanine",
    "last_name": "Pearson",
    "email": "jeaniep@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2015-09-14T13:10:12",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-05-19T03:29:14",
    "is_superuser": true,
    "username": "lagrassa",
    "first_name": "Alex",
    "last_name": "LaGrassa",
    "email": "lagrassa@mit.edu",
    "is_staff": true,
    "is_active": true,
    "date_joined": "2015-09-15T13:43:31",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-05-22T14:54:48",
    "is_superuser": true,
    "username": "mcslao",
    "first_name": "Ma. Czarina A",
    "last_name": "Lao",
    "email": "mcslao@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2015-09-15T13:43:33",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-04-05T21:00:55",
    "is_superuser": false,
    "username": "zhengt",
    "first_name": "Tianlin",
    "last_name": "Zheng",
    "email": "zhengt@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2015-09-15T13:43:37",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!",
    "last_login": "2018-05-20T16:06:45",
    "is_superuser": false,
    "username": "ksmori",
    "first_name": "Keiko",
    "last_name": "Mori",
    "email": "ksmori@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2016-02-06T20:05:35",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "pbkdf2_sha256$120000$OzPLXL7tEYy1$1+dFV3AORzb8zOtAJV2YLbeJyuxDT3S3ZLsUlHIVg54=",
    "last_login": "2018-11-30T14:06:42",
    "is_superuser": false,
    "username": "avl",
    "first_name": "Amy",
    "last_name": "Liu",
    "email": "avl@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2017-02-08T14:19:14",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!BXgIq4sHZwin4rhuCC0NRYapPH61Rc778SxSFMSh",
    "last_login": "2018-05-22T21:10:33",
    "is_superuser": false,
    "username": "cww",
    "first_name": "Camaron",
    "last_name": "Wagner",
    "email": "cww@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2017-09-06T11:55:32",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!d6a3L3OlOwrG2WiiOMPWMvooVM4zG6LHbwSoZqR1",
    "last_login": "2018-04-29T19:19:37",
    "is_superuser": false,
    "username": "yaatehr",
    "first_name": "Yaateh",
    "last_name": "Richardson",
    "email": "yaatehr@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2018-02-02T14:49:05",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!HjRjLNz3j0KqVizLb2TCi7LrvJdo5vmTuHjmsIWw",
    "last_login": "2018-04-20T10:12:42",
    "is_superuser": false,
    "username": "sebatoro",
    "first_name": "Sebastian",
    "last_name": "Toro Arana",
    "email": "sebatoro@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2018-02-02T14:49:09",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!lM6NKwBOSaQbAbs2IQTq8s49CnPON2bgP8jxoIi7",
    "last_login": "2018-04-23T20:02:18",
    "is_superuser": false,
    "username": "amirf",
    "first_name": "Amir",
    "last_name": "Farhat",
    "email": "amirf@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2018-02-02T14:49:09",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!k9gJefFWa4hqDAzYJjgrL8maXfJXLlvHJqNceVUH",
    "last_login": "2018-05-22T19:27:37",
    "is_superuser": false,
    "username": "umustafi",
    "first_name": "Urmi",
    "last_name": "Mustafi",
    "email": "umustafi@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2018-02-02T14:49:11",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!6xIvWLrM06IY39eUg8ySCHb9U448YAYomAgfsefQ",
    "last_login": "2018-04-22T17:25:54",
    "is_superuser": false,
    "username": "mayalk",
    "first_name": "Maya",
    "last_name": "Kaul",
    "email": "mayalk@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2018-02-02T14:49:12",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "fields": {
    "password": "!Q3RjEfGVcQ1ZBSH0TvEGkMYk2Q3XEJDooVnty5eP",
    "last_login": "2018-05-07T23:58:36",
    "is_superuser": false,
    "username": "bcsam",
    "first_name": "Brent",
    "last_name": "Samuels",
    "email": "bcsam@mit.edu",
    "is_staff": false,
    "is_active": true,
    "date_joined": "2018-02-07T12:53:40",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "sessions.session",
  "pk": "0mxi60rdnev3qcurl30kpplv018lj1s0",
  "fields": {
    "session_data": "NTc5NWFiYWM3OWJjMzBlMjRhZGM5NjAzYmM4NGIxNWQ4YThhZWI2ZTp7Il9hdXRoX3VzZXJfaWQiOiIzNTU0IiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoibWl0LmF1dGguU1NMUmVtb3RlVXNlckJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiI3NTYwY2FmNzZlZGQ1MjQxYmEwYTNmOTAwNzAzYjc4MmM2YTMxNDFiIn0=",
    "expire_date": "2019-01-03T10:54:19"
  }
},
{
  "model": "sessions.session",
  "pk": "6toe9hgqseg8jwtbfwdrp1dhronkazin",
  "fields": {
    "session_data": "MjExNzVlNDEyYjhkNzFjN2RhOGRhMjVlYmQyOTlmMWI3OGRmMjY0OTp7Il9hdXRoX3VzZXJfaGFzaCI6IjU3OTI4NzViYzBlZDk4ZmZiNzk1NWMxNTkxZTBhMDM2ZTk4MjU4YmEiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzMjgxIn0=",
    "expire_date": "2018-08-28T18:13:43"
  }
},
{
  "model": "sessions.session",
  "pk": "8i7iu6kv3niqy1hqnkz73k7yby3f1fa3",
  "fields": {
    "session_data": "NTBjMGNkMGMwMTJkMjNiZDc5NGIwZTdmMDlhZTQ0YjQ0YWRkNDE3OTp7Il9hdXRoX3VzZXJfaGFzaCI6IjhjODNiNGYyNDQyNGEzZWNmNmM1OGNmMDExMDA4YTQ5NDQ4OTM5YjciLCJfYXV0aF91c2VyX2lkIjoiMyIsIl9hdXRoX3VzZXJfYmFja2VuZCI6Im1pdC5hdXRoLlNTTFJlbW90ZVVzZXJCYWNrZW5kIn0=",
    "expire_date": "2018-12-14T13:24:32"
  }
},
{
  "model": "sessions.session",
  "pk": "ac51wzmvroahttre6uavk244ht0wigeo",
  "fields": {
    "session_data": "Y2M2YzNkNGQ0Y2JiN2YyNjNjMTBjODBmMDU5NjczNTQxMjIwY2JjYTp7Il9hdXRoX3VzZXJfaGFzaCI6IjljMjBjZmM5ZTkxOWM5OTBmNjg2YTI2Y2U0NjhmZTk4NTQxZDFjNGQiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzNDUyIn0=",
    "expire_date": "2018-09-07T02:34:11"
  }
},
{
  "model": "sessions.session",
  "pk": "aepcv9hvw37j3e08kxvka0oioaogms9a",
  "fields": {
    "session_data": "M2JkYTg4ZDM2NjA3MmMwYjcxZGM1NmM4MjZiNjAyZTVlZGQ1YjRhZDp7Il9hdXRoX3VzZXJfaGFzaCI6IjZkYTYzMGNkN2FiMjc3ODRjNzlmNTY4ODhiZGE4YmM5OWNiYmM1YjIiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIyMTQyIn0=",
    "expire_date": "2018-09-08T14:42:12"
  }
},
{
  "model": "sessions.session",
  "pk": "avmeb1p75el1tds97r37gwkholooa13d",
  "fields": {
    "session_data": "OTk1ODM1OWJjMDM3NDA2YTRlMTkxOGM0NjYxYTQ2MzBhNzkzMmZhYTp7Il9hdXRoX3VzZXJfaWQiOiIzIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoibWl0LmF1dGguU1NMUmVtb3RlVXNlckJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiI4YzgzYjRmMjQ0MjRhM2VjZjZjNThjZjAxMTAwOGE0OTQ0ODkzOWI3In0=",
    "expire_date": "2019-02-07T16:34:09"
  }
},
{
  "model": "sessions.session",
  "pk": "d2xfu1txsvphw41dl42ho9k8d6c20keq",
  "fields": {
    "session_data": "ZDEwYmZhNjlmMWQ2NjA1OGE0MWY3MWM5OTNmNzQ3MjNiMWVjMTBkZjp7Il9hdXRoX3VzZXJfaGFzaCI6IjhjODNiNGYyNDQyNGEzZWNmNmM1OGNmMDExMDA4YTQ5NDQ4OTM5YjciLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzIn0=",
    "expire_date": "2018-08-31T11:02:45"
  }
},
{
  "model": "sessions.session",
  "pk": "dgnyvwgyy7l09niosa9z9yjysxuhvlqz",
  "fields": {
    "session_data": "ZGMxNGE5OWU3ZTJhYmUzYzBiNjA0NGVjY2E4YjU0YTBjNmFkYzBiMDp7Il9hdXRoX3VzZXJfaWQiOiIyOTg3IiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIzYTVlNGVhYjVlMDg0OWM4MWIwZjNiMDAwODBhMzliYmRjOWFhZGRkIn0=",
    "expire_date": "2018-12-14T12:49:59"
  }
},
{
  "model": "sessions.session",
  "pk": "g29a6k4ax4qwz14jeph8rgddwwyvx0al",
  "fields": {
    "session_data": "Y2UyZGU4YTRiNGZiZmJhNTU0Y2I2MDAyMTkwMDNlOWFiYjdmYjJjZTp7Il9hdXRoX3VzZXJfaWQiOiIyOTg3IiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJhY2QxYmNjNDg2YTg4NDI2YTIwMjFhNDliNGJhZjI4YjY5ZTczZWY3In0=",
    "expire_date": "2018-12-14T14:06:42"
  }
},
{
  "model": "sessions.session",
  "pk": "gn6bu4xfi9g2avk6ap1bqywno2jcwmcn",
  "fields": {
    "session_data": "Y2M2YzNkNGQ0Y2JiN2YyNjNjMTBjODBmMDU5NjczNTQxMjIwY2JjYTp7Il9hdXRoX3VzZXJfaGFzaCI6IjljMjBjZmM5ZTkxOWM5OTBmNjg2YTI2Y2U0NjhmZTk4NTQxZDFjNGQiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzNDUyIn0=",
    "expire_date": "2018-09-07T02:34:09"
  }
},
{
  "model": "sessions.session",
  "pk": "gx6opow76x89j13c2iasaonz7qitry13",
  "fields": {
    "session_data": "OTk1ODM1OWJjMDM3NDA2YTRlMTkxOGM0NjYxYTQ2MzBhNzkzMmZhYTp7Il9hdXRoX3VzZXJfaWQiOiIzIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoibWl0LmF1dGguU1NMUmVtb3RlVXNlckJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiI4YzgzYjRmMjQ0MjRhM2VjZjZjNThjZjAxMTAwOGE0OTQ0ODkzOWI3In0=",
    "expire_date": "2019-01-03T11:08:25"
  }
},
{
  "model": "sessions.session",
  "pk": "he22s5v3b9xlb4jax9gbh32ytw4enrxz",
  "fields": {
    "session_data": "MjExNzVlNDEyYjhkNzFjN2RhOGRhMjVlYmQyOTlmMWI3OGRmMjY0OTp7Il9hdXRoX3VzZXJfaGFzaCI6IjU3OTI4NzViYzBlZDk4ZmZiNzk1NWMxNTkxZTBhMDM2ZTk4MjU4YmEiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzMjgxIn0=",
    "expire_date": "2018-08-28T18:13:46"
  }
},
{
  "model": "sessions.session",
  "pk": "kfmkd1z8hqedjitj9lfev1xa7r9kapyk",
  "fields": {
    "session_data": "MjExNzVlNDEyYjhkNzFjN2RhOGRhMjVlYmQyOTlmMWI3OGRmMjY0OTp7Il9hdXRoX3VzZXJfaGFzaCI6IjU3OTI4NzViYzBlZDk4ZmZiNzk1NWMxNTkxZTBhMDM2ZTk4MjU4YmEiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzMjgxIn0=",
    "expire_date": "2018-08-28T18:13:45"
  }
},
{
  "model": "sessions.session",
  "pk": "qld3vzvlt0ssqzg99afr1an0idud8iow",
  "fields": {
    "session_data": "NTBjMGNkMGMwMTJkMjNiZDc5NGIwZTdmMDlhZTQ0YjQ0YWRkNDE3OTp7Il9hdXRoX3VzZXJfaGFzaCI6IjhjODNiNGYyNDQyNGEzZWNmNmM1OGNmMDExMDA4YTQ5NDQ4OTM5YjciLCJfYXV0aF91c2VyX2lkIjoiMyIsIl9hdXRoX3VzZXJfYmFja2VuZCI6Im1pdC5hdXRoLlNTTFJlbW90ZVVzZXJCYWNrZW5kIn0=",
    "expire_date": "2018-12-14T12:09:24"
  }
},
{
  "model": "sessions.session",
  "pk": "s2nq2ymg2800ht5xefjyo85zwxzlmrff",
  "fields": {
    "session_data": "OTk1ODM1OWJjMDM3NDA2YTRlMTkxOGM0NjYxYTQ2MzBhNzkzMmZhYTp7Il9hdXRoX3VzZXJfaWQiOiIzIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoibWl0LmF1dGguU1NMUmVtb3RlVXNlckJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiI4YzgzYjRmMjQ0MjRhM2VjZjZjNThjZjAxMTAwOGE0OTQ0ODkzOWI3In0=",
    "expire_date": "2018-12-27T09:01:54"
  }
},
{
  "model": "sessions.session",
  "pk": "tbaxddfgm383qopvyjuip80ccpwfat3o",
  "fields": {
    "session_data": "ZDEwYmZhNjlmMWQ2NjA1OGE0MWY3MWM5OTNmNzQ3MjNiMWVjMTBkZjp7Il9hdXRoX3VzZXJfaGFzaCI6IjhjODNiNGYyNDQyNGEzZWNmNmM1OGNmMDExMDA4YTQ5NDQ4OTM5YjciLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzIn0=",
    "expire_date": "2018-09-10T14:45:39"
  }
},
{
  "model": "sessions.session",
  "pk": "wb1mzvjc2t6xl9lb7umd5ps148qiwkn2",
  "fields": {
    "session_data": "NDg2OWViZTkxOWRkMWFmYmMxMjk5MzE2YmE1OTgzMTRjOGQzMDUwMTp7Il9hdXRoX3VzZXJfaGFzaCI6ImY0OWI5ZGExMjI4YTlkZWUyZTkwZGYwMTFhMjBmZjY5NDE0MzQ2N2QiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzMDA5In0=",
    "expire_date": "2018-09-01T19:19:47"
  }
},
{
  "model": "sessions.session",
  "pk": "yc7w1i1rhkxaol090jr3w9zqdd3fnm09",
  "fields": {
    "session_data": "YzVmNWYzYjY0ZGMyM2U3M2VhNDhkMDlmMGRlMGYwNTIwZDJmNWJiYjp7Il9hdXRoX3VzZXJfaGFzaCI6IjM1ODlkNThkMDY2MjkwYzRjNWIyMmZlMmNhMjJiOTAwMjJhMmFiMTEiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIyODYzIn0=",
    "expire_date": "2018-08-30T17:10:30"
  }
},
{
  "model": "sessions.session",
  "pk": "zlbf47wy9i2tpmuw5yn76g83hdtgt9br",
  "fields": {
    "session_data": "ZDYyYjZhY2IxNzMzYWU4MGI0N2IxODhkMjc1NWVmYmZmM2ViMDIwMTp7Il9hdXRoX3VzZXJfaGFzaCI6ImRmM2RlNTU3ZDBiNTZmZWRmMmY1MDRjYWY1OGZiNjY5NDYxMjkyZTkiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJtaXQuYXV0aC5TU0xSZW1vdGVVc2VyQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIzNTQ4In0=",
    "expire_date": "2018-09-05T10:23:37"
  }
},
{
  "model": "review.subject",
  "pk": 2,
  "fields": {
    "name": "6.005"
  }
},
{
  "model": "review.subject",
  "pk": 5,
  "fields": {
    "name": "6.031"
  }
},
{
  "model": "review.semester",
  "pk": 18,
  "fields": {
    "subject": 2,
    "description": "Software Construction",
    "semester": "Spring 2018",
    "is_current_semester": false
  }
},
{
  "model": "review.semester",
  "pk": 19,
  "fields": {
    "subject": 5,
    "description": "Software Construction",
    "semester": "Fall 2018",
    "is_current_semester": true
  }
},
{
  "model": "review.assignment",
  "pk": 99,
  "fields": {
    "semester": 18,
    "name": "karaoke"
  }
},
{
  "model": "review.assignment",
  "pk": 100,
  "fields": {
    "semester": 19,
    "name": "ps0"
  }
},
{
  "model": "review.milestone",
  "pk": 252,
  "fields": {
    "assignment": 99,
    "assigned_date": "2018-04-30T11:00:00",
    "duedate": "2018-11-30T20:00:00",
    "name": "final",
    "max_extension": 0,
    "allow_unextending_to_past": false,
    "type": "S"
  }
},
{
  "model": "review.milestone",
  "pk": 253,
  "fields": {
    "assignment": 99,
    "assigned_date": "2018-05-16T11:00:00",
    "duedate": "2018-05-16T11:00:00",
    "name": "grading",
    "max_extension": 0,
    "allow_unextending_to_past": false,
    "type": "R"
  }
},
{
  "model": "review.milestone",
  "pk": 256,
  "fields": {
    "assignment": 100,
    "assigned_date": "2018-02-20T10:22:18",
    "duedate": "2018-02-20T10:22:20",
    "name": "test",
    "max_extension": 2,
    "allow_unextending_to_past": false,
    "type": "S"
  }
},
{
  "model": "review.submitmilestone",
  "pk": 252,
  "fields": {
    "assignment": 99,
    "milestone_ptr": 252,
    "starting_code_path": "6.031/private/sp18/code/karaoke/starting",
    "submitted_code_path": "6.031/private/sp18/code/karaoke/final",
    "included_file_patterns": "*.java *.c *.h *.cpp *.CC *.py *.g",
    "excluded_file_patterns": "*/.* *.class *.jar *.pdf *.abc",
    "restrict_access": false,
    "run_checkstyle": true,
    "suppress_checkstyle_regex": ""
  }
},
{
  "model": "review.submitmilestone",
  "pk": 256,
  "fields": {
    "assignment": 100,
    "milestone_ptr": 256,
    "starting_code_path": "6.031/private/fa18/code/ps0/starting",
    "submitted_code_path": "6.031/private/fa18/code/ps0/test",
    "included_file_patterns": "*.java *.c *.h *.cpp *.CC *.py",
    "excluded_file_patterns": "*/Action.java */DrawableTurtle.java */LineSegment.java */PenColor.java */Point.java */TurtleGUI.java */Turtle.java */*Test.java */.* *.class *.jar *.o *.obj *.lib *.pyc",
    "restrict_access": false,
    "run_checkstyle": true,
    "suppress_checkstyle_regex": ""
  }
},
{
  "model": "review.reviewmilestone",
  "pk": 253,
  "fields": {
    "assignment": 99,
    "milestone_ptr": 253,
    "reviewers_per_chunk": 0,
    "min_student_lines": 0,
    "submit_milestone": 252,
    "student_count": 0,
    "alum_count": 0,
    "staff_count": 0,
    "reveal_date": "2018-05-22T13:00:00"
  }
},
{
  "model": "review.batch",
  "pk": 548,
  "fields": {
    "name": "karaoke - final"
  }
},
{
  "model": "review.batch",
  "pk": 549,
  "fields": {
    "name": "karaoke - final"
  }
},
{
  "model": "review.batch",
  "pk": 551,
  "fields": {
    "name": "karaoke - final"
  }
},
{
  "model": "review.batch",
  "pk": 576,
  "fields": {
    "name": "ps0 - preview"
  }
},
{
  "model": "review.batch",
  "pk": 583,
  "fields": {
    "name": "ps0 - test"
  }
},
{
  "model": "review.submission",
  "pk": 36367,
  "fields": {
    "name": "bcsam-umustafi-yaatehr",
    "created": "2018-05-18T07:43:54",
    "revision": null,
    "revision_date": null,
    "milestone": 252,
    "batch": 551,
    "sha256": "6a330a1213489afd1ad118aa73a302ddfee1bacadb0bd703aabf284ffffc0753",
    "authors": [
      [
        "yaatehr"
      ],
      [
        "umustafi"
      ],
      [
        "bcsam"
      ]
    ]
  }
},
{
  "model": "review.submission",
  "pk": 36368,
  "fields": {
    "name": "cww-mayalk-sebatoro",
    "created": "2018-05-18T07:43:55",
    "revision": null,
    "revision_date": null,
    "milestone": 252,
    "batch": 551,
    "sha256": "730e4f7654c1c16150fee706bf58d1bfcaeba45a8679e12b6824bd4a18d19a7c",
    "authors": [
      [
        "cww"
      ],
      [
        "sebatoro"
      ],
      [
        "mayalk"
      ]
    ]
  }
},
{
  "model": "review.submission",
  "pk": 36481,
  "fields": {
    "name": "avl",
    "created": "2018-08-27T14:57:30",
    "revision": null,
    "revision_date": null,
    "milestone": 256,
    "batch": 576,
    "sha256": "9637402b84d54521a79fa30434b04635d325399976364abd9af93ad78e6959e3",
    "authors": [
      [
        "avl"
      ]
    ]
  }
},
{
  "model": "review.submission",
  "pk": 36482,
  "fields": {
    "name": "amirf",
    "created": "2018-08-27T14:57:30",
    "revision": null,
    "revision_date": null,
    "milestone": 256,
    "batch": 576,
    "sha256": "205daf069de886532675ac6e74795c30e974aa51297def1717c1d93d0e7cdb8a",
    "authors": [
      [
        "amirf"
      ]
    ]
  }
},
{
  "model": "review.file",
  "pk": 282896,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/examples/HostnameExample.java",
    "data": "package examples;\n\nimport java.io.IOException;\nimport java.net.Inet4Address;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.util.Collections;\n\npublic class HostnameExample {\n\n    /**\n     * Print the IPv4 hostnames that can be used to reach this machine.\n     * Falls back to an IP address if it can't find a hostname.\n     * Some of these addresses may not be usable from remote machines:\n     * examples include localhost, 10.x.x.x, 172.x.x.x, 192.x.x.x.\n     * \n     * @param args unused\n     * @throws IOException if network problem\n     */\n    public static void main(String[] args) throws IOException {\n        for (NetworkInterface iface : Collections.list(NetworkInterface.getNetworkInterfaces())) {\n            for (InetAddress address: Collections.list(iface.getInetAddresses())) {\n                if (address instanceof Inet4Address) {\n                    System.out.println(address.getHostName());\n                }\n            }\n        }\n    }\n\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282897,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/examples/ScaleExample.java",
    "data": "package examples;\n\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\n\nimport karaoke.sound.Instrument;\nimport karaoke.sound.MidiSequencePlayer;\nimport karaoke.sound.Pitch;\nimport karaoke.sound.SequencePlayer;\n\npublic class ScaleExample {\n    \n    /**\n     * Play an octave up and back down starting from middle C.\n     * \n     * @param args not used\n     * @throws MidiUnavailableException if MIDI device unavailable\n     * @throws InvalidMidiDataException if MIDI play fails\n    */\n    public static void main(String[] args) throws MidiUnavailableException, InvalidMidiDataException {\n\n        Instrument piano = Instrument.PIANO;\n\n        // create a new player\n        final int beatsPerMinute = 120; // a beat is a quarter note, so this is 120 quarter notes per minute\n        final int ticksPerBeat = 64; // allows up to 1/64-beat notes to be played with fidelity\n        SequencePlayer player = new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n        \n        // addNote(instr, pitch, startBeat, numBeats) schedules a note with pitch value 'pitch'\n        // played by 'instr' starting at 'startBeat' to be played for 'numBeats' beats.\n        \n        int startBeat = 0;\n        int numBeats = 1;\n        player.addNote(piano, new Pitch('C'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('D'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('E'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('F'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('G'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('A'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('B'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('C').transpose(Pitch.OCTAVE), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('B'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('A'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('G'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('F'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('E'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('D'), startBeat++, numBeats);\n        player.addNote(piano, new Pitch('C'), startBeat++, numBeats);\n        \n        // add a listener at the end of the piece to tell main thread when it's done\n        Object lock = new Object();\n        player.addEvent(startBeat, (Double beat) -> {\n            synchronized (lock) {\n                lock.notify();\n            }\n        });\n        \n        // print the configured player\n        System.out.println(player);\n\n        // play!\n        player.play();\n        \n        \n        // wait until player is done\n        // (not strictly needed here, but useful for JUnit tests)\n        synchronized (lock) {\n            try {\n                lock.wait();\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n        System.out.println(\"done playing\");\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282898,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/examples/StreamingExample.java",
    "data": "package examples;\n\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.Executors;\n\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpServer;\n\npublic class StreamingExample {\n\n    /**\n     * Web server that demonstrates several ways to stream text to a web browser.\n     *     \n     * @param args not used\n     * @throws IOException if network failure\n     */\n    public static void main(String[] args) throws IOException {\n        \n        // make a web server\n        final int serverPort = 4567;\n        final HttpServer server = HttpServer.create(new InetSocketAddress(serverPort), 0);\n        \n        // handle concurrent requests with multiple threads\n        server.setExecutor(Executors.newCachedThreadPool());\n\n        // register handlers\n        server.createContext(\"/textStream\", StreamingExample::textStream);\n        server.createContext(\"/htmlStream\", StreamingExample::htmlStream);\n        server.createContext(\"/htmlWaitReload\", StreamingExample::htmlWaitReload);\n\n        // start the server\n        server.start();\n        System.out.println(\"server running, browse to one of these URLs:\");\n        System.out.println(\"http://localhost:4567/textStream\");\n        System.out.println(\"http://localhost:4567/htmlStream\");\n        System.out.println(\"http://localhost:4567/htmlStream/autoscroll\");\n        System.out.println(\"http://localhost:4567/htmlWaitReload\");\n    }\n    \n    /**\n     * This handler sends a plain text stream to the web browser,\n     * one line at a time, pausing briefly between each line.\n     * Returns after the entire stream has been sent.\n     * \n     * @param exchange request/reply object\n     * @throws IOException if network problem\n     */\n    private static void textStream(HttpExchange exchange) throws IOException {\n        final String path = exchange.getRequestURI().getPath();\n        System.err.println(\"received request \" + path);\n\n        // plain text response\n        exchange.getResponseHeaders().add(\"Content-Type\", \"text/plain; charset=utf-8\");\n\n        // must call sendResponseHeaders() before calling getResponseBody()\n        final int successCode = 200;\n        final int lengthNotKnownYet = 0;\n        exchange.sendResponseHeaders(successCode, lengthNotKnownYet);\n\n        // get output stream to write to web browser\n        final boolean autoflushOnPrintln = true;\n        PrintWriter out = new PrintWriter(\n                              new OutputStreamWriter(\n                                  exchange.getResponseBody(), \n                                  StandardCharsets.UTF_8), \n                              autoflushOnPrintln);\n        \n        try {\n            // IMPORTANT: some web browsers don't start displaying a page until at least 2K bytes\n            // have been received.  So we'll send a line containing 2K spaces first.\n            final int enoughBytesToStartStreaming = 2048;\n            for (int i = 0; i < enoughBytesToStartStreaming; ++i) {\n                out.print(' ');\n            }\n            out.println(); // also flushes\n            \n            final int numberOfLinesToSend = 100;\n            final int millisecondsBetweenLines = 200;\n            for (int i = 0; i < numberOfLinesToSend; ++i) {\n                \n                // print a line of text\n                out.println(System.currentTimeMillis()); // also flushes\n\n                // wait a bit\n                try {\n                    Thread.sleep(millisecondsBetweenLines);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n            \n        } finally {\n            exchange.close();\n        }\n        System.err.println(\"done streaming request\");\n    }\n\n    /**\n     * This handler sends a stream of HTML to the web browser,\n     * pausing briefly between each line of output.\n     * Returns after the entire stream has been sent.\n     * \n     * @param exchange request/reply object\n     * @throws IOException if network problem\n     */\n    private static void htmlStream(HttpExchange exchange) throws IOException {\n        final String path = exchange.getRequestURI().getPath();\n        System.err.println(\"received request \" + path);\n    \n        final boolean autoscroll = path.endsWith(\"/autoscroll\");\n        \n        // html response\n        exchange.getResponseHeaders().add(\"Content-Type\", \"text/html; charset=utf-8\");\n        \n        // must call sendResponseHeaders() before calling getResponseBody()\n        final int successCode = 200;\n        final int lengthNotKnownYet = 0;\n        exchange.sendResponseHeaders(successCode, lengthNotKnownYet);\n\n        // get output stream to write to web browser\n        final boolean autoflushOnPrintln = true;\n        PrintWriter out = new PrintWriter(\n                              new OutputStreamWriter(\n                                  exchange.getResponseBody(), \n                                  StandardCharsets.UTF_8), \n                              autoflushOnPrintln);\n        \n        try {\n\n            // IMPORTANT: some web browsers don't start displaying a page until at least 2K bytes\n            // have been received.  So we'll send a line containing 2K spaces first.\n            final int enoughBytesToStartStreaming = 2048;\n            for (int i = 0; i < enoughBytesToStartStreaming; ++i) {\n                out.print(' ');\n            }\n            out.println(); // also flushes\n            \n            final int numberOfLinesToSend = 100;\n            final int millisecondsBetweenLines = 200;\n            for (int i = 0; i < numberOfLinesToSend; ++i) {\n                \n                // print a line of text\n                out.println(\"duck me\" + \"<br>\"); // also flushes\n                \n                if (true) {\n                    // send some Javascript to browser that makes it scroll down to the bottom of the page,\n                    // so that the last line sent is always in view\n                    out.println(\"<script>document.body.innerHTML = \\\"\\\"</script>\");\n                }\n                \n                // wait a bit\n                try {\n                    Thread.sleep(millisecondsBetweenLines);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n            \n        } finally {\n            exchange.close();\n        }\n        System.err.println(\"done streaming request\");\n    }\n\n\n    /**\n     * This handler waits for an event to occur in the server\n     * before sending a complete HTML page to the web browser.\n     * The page ends with a Javascript command that immediately starts\n     * reloading the page at the same URL, which causes this handler to be\n     * run, wait for the next event, and send an updated HTML page.\n     * In this simple example, the \"server event\" is just a brief timeout, but it\n     * could synchronize with another thread instead.\n     * \n     * @param exchange request/reply object\n     * @throws IOException if network problem\n     */\n    private static void htmlWaitReload(HttpExchange exchange) throws IOException {\n        final String path = exchange.getRequestURI().getPath();\n        System.err.println(\"received request \" + path);\n\n        // html response\n        exchange.getResponseHeaders().add(\"Content-Type\", \"text/html; charset=utf-8\");\n        \n        // must call sendResponseHeaders() before calling getResponseBody()\n        final int successCode = 200;\n        final int lengthNotKnownYet = 0;\n        exchange.sendResponseHeaders(successCode, lengthNotKnownYet);\n\n        // get output stream to write to web browser\n        final boolean autoflushOnPrintln = true;\n        PrintWriter out = new PrintWriter(\n                              new OutputStreamWriter(\n                                  exchange.getResponseBody(), \n                                  StandardCharsets.UTF_8), \n                              autoflushOnPrintln);\n        \n        try {\n\n            // Wait until an event occurs in the server.\n            // In this example, the event is just a brief fixed-length delay, but it\n            // could synchronize with another thread instead.\n            final int millisecondsToWait = 200;\n            try {\n                Thread.sleep(millisecondsToWait);\n            } catch (InterruptedException e) {\n                return;\n            }\n            \n            // Send a full HTML page to the web browser\n            out.println(System.currentTimeMillis() + \"<br>\");\n            \n            // End the page with Javascript that causes the browser to immediately start \n            // reloading this URL, so that this handler runs again and waits for the next event\n            out.println(\"<script>location.reload()</script>\");\n            \n        } finally {\n            exchange.close();\n        }\n        System.err.println(\"done streaming request\");\n    }\n\n\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282899,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/Main.java",
    "data": "package karaoke;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.Inet4Address;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.Scanner;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.parser.PieceParser;\nimport karaoke.sound.Piece;\n\n/**\n * Main entry point of your application.\n * Navigate to the project folder in your terminal and run:\n *      \"java -cp bin:lib/parserlib.jar karaoke.Main path-to-dir/filename.abc\" to run this file\n */\npublic class Main {\n\n    /**\n     * Receives input from client for piece to play, starts server, \n     * and gives client instructions to play piece and watch the lyrics. \n     * @param args a String array of size 1 that contains the music file path at index 0\n     * @throws UnableToParseException If the input data cannot be parsed\n     * @throws FileNotFoundException If the file cannot be found from the provided file path\n     * @throws IOException If there is an input error\n     */\n    public static void main(String[] args) throws UnableToParseException, FileNotFoundException, IOException { \n        final Queue<String> arguments = new LinkedList<>(Arrays.asList(args));\n        \n        final String filePath; \n        final int port = 8080; \n        \n        try {\n            filePath = arguments.remove();\n        } catch (NoSuchElementException nse) {\n            throw new IllegalArgumentException(\"missing File Path\", nse);\n        }\n        Scanner in = new Scanner(new File(\"./\" + filePath));\n        String fileContent = in.useDelimiter(\"\\\\Z\").next();\n        Piece piece = PieceParser.parse(fileContent);\n        in.close();\n\n        String hostname = \"\"; \n        for (NetworkInterface iface : Collections.list(NetworkInterface.getNetworkInterfaces())) {\n            for (InetAddress address: Collections.list(iface.getInetAddresses())) {\n                if (address instanceof Inet4Address) {\n                    hostname = address.getHostName(); \n                    break; \n                }\n            }\n            if (!hostname.equals(\"\")) {\n                break; \n            }\n        }\n\n        Server server = new Server(piece, hostname, port);\n        server.start();\n        \n        // print title and composer of piece \n        System.out.println(\"Title: \" + piece.getTitle() + \"\\nComposer: \" + piece.getComposer());\n        // instructions on how to view lyrics on a web browser \n        System.out.println(\"Follow along with the lyrics by visiting \" + \"http://\" + hostname + \":\" + port + \"/lyrics in your web browser\");\n        // instructions on how to start music play back\n        System.out.println(\"Play by visiting \" + \"http://\" + hostname + \":\" + port + \"/play\");\n        System.out.println(\"The system will wait 3.5 seconds after you click play before it starts playing the music. Get ready!\");\n        \n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282900,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/Server.java",
    "data": "package karaoke;\n\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.concurrent.Executors;\n\nimport com.sun.net.httpserver.HttpContext;\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\n\nimport karaoke.sound.Piece;\nimport karaoke.web.HeadersFilter;\nimport karaoke.web.LogFilter;\n\npublic class Server {\n    private final HttpServer server;\n    private final Piece piece;\n    private final String hostName;\n\n    // AF (piece, server, ) = a web server that plays music on the native server machine,\n    //      and streams song lyrics to clients so they can follow along. \n    //      Piece is the musical piece, or song ADT, being played and streamed\n    //      Server is the HttpServer that handles HTTP requests from client \n\n    // Rep Invariant: \n    /* numConnections represents the number of clients connected to the server \n     * \n     */\n    \n    // Safety from rep exposure: \n    //      server, piece, and hostName are private final \n    //      they are not passed as parameters or returned from any methods\n    //      hostname is an immutable type\n\n    // Thread safety argument:\n    //      This in NOT a thread safe type, but in the context in which it is being used it is thread safe...\n    //          as each handler is run in its own thread\n    //      piece is a thread safe type, so it can be accessed by the multiple handler threads\n    //      This server instance should only be run on one thread\n\n    /**\n     * Make a new karaoke server at the address of hostName using piece that listens\n     * for connections on port.\n     * \n     * @param piece    - piece to be streamed\n     * @param hostName - identifier of the IP address for server to run on\n     * @param port     - optional port number for the server\n     * @throws IOException if an error occurs while starting the server\n     */\n    public Server(Piece piece, String hostName, int port) throws IOException {\n        this.server = HttpServer.create(new InetSocketAddress(port), 0);\n        this.piece = piece;\n        this.hostName = hostName;\n        // handle concurrent requests with multiple threads\n        server.setExecutor(Executors.newCachedThreadPool());\n\n        LogFilter log = new LogFilter();\n        HeadersFilter headers = new HeadersFilter();\n        // allow requests from web pages hosted anywhere\n        headers.add(\"Access-Control-Allow-Origin\", \"*\");\n        // all responses will be plain-text UTF-8\n        headers.add(\"Content-Type\", \"text/plain; charset=utf-8\");\n\n        // handle requests for paths that start with /lyrics\n        HttpContext lyrics = server.createContext(\"/lyrics\", new HttpHandler() {\n            public void handle(HttpExchange exchange) throws IOException {\n                handleLyrics(exchange);\n            }\n        });\n        HttpContext play = server.createContext(\"/play\", new HttpHandler() {\n            public void handle(HttpExchange exchange) throws IOException {\n                handlePlay(exchange);\n            }\n        });\n\n        // add logging to the /hello/ handler and set required HTTP headers\n        // (do this on all your handlers)\n        lyrics.getFilters().addAll(Arrays.asList(log, headers));\n        play.getFilters().addAll(Arrays.asList(log, headers));\n\n    }\n\n    /**\n     * Start this server in a new background thread.\n     */\n    public void start() {\n        System.err.println(\"Server will listen at \" + this.hostName + \":\" + this.port());\n        server.start();\n    }\n\n    /**\n     * Stop this server. Once stopped, this server cannot be restarted.\n     */\n    public void stop() {\n        System.err.println(\"Server will stop\");\n        server.stop(0);\n    }\n\n    /**\n     * @return the port on which this server is listening for connections\n     */\n    public int port() {\n        return server.getAddress().getPort();\n    }\n\n    /**\n     * @return the hostname and port on which the server is running\n     */\n    public String getHostName() {\n        return this.hostName + \":\" + this.port();\n    }\n\n    /**\n     * from example code This handler sends a stream of HTML to the web browser,\n     * containing the lyrics of the piece, sent at the proper melodic intervals.\n     * \n     * The voice of the piece is selected on a rotating basis, defined by how many\n     * clients have connected to this server\n     * \n     * @param exchange request/reply object\n     * @throws IOException if network problem\n     */\n    private void handleLyrics(HttpExchange exchange) throws IOException {\n        final String path = exchange.getRequestURI().getPath();\n\n        final String greeting = piece.generateGreeting() + \"Press <b><a href=\\\"http://\" +\n        this.getHostName() + \"/play\\\">PLAY</a></b> to begin<br><br>\" ;\n        // System.out.println(\"greet: \" + greeting);\n        System.err.println(\"received request \" + path);\n\n        // html response\n        exchange.getResponseHeaders().add(\"Content-Type\", \"text/html; charset=utf-8\");\n\n        // must call sendResponseHeaders() before calling getResponseBody()\n        final int successCode = 200;\n        final int lengthNotKnownYet = 0;\n        exchange.sendResponseHeaders(successCode, lengthNotKnownYet);\n\n        // get output stream to write to web browser\n        final boolean autoflushOnPrintln = true;\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(exchange.getResponseBody(), StandardCharsets.UTF_8),\n                autoflushOnPrintln);\n        try {\n\n            // IMPORTANT: some web browsers don't start displaying a page until at least 2K\n            // bytes\n            // have been received. So we'll send a line containing 2K spaces first.\n            final int enoughBytesToStartStreaming = 2048;\n            for (int i = 0; i < enoughBytesToStartStreaming; ++i) {\n                out.print(' ');\n            }\n            out.println(greeting); // also flushes\n            this.piece.addListener(out);\n            synchronized (out) {\n                out.wait();\n            }\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            exchange.close();\n        }\n\n    }\n\n    /**\n     * This handler triggers the Thread safe play function of piece the url then\n     * redirects to the lyrics page. NOTE: MUTATES piece\n     * \n     * @param exchange request/reply object\n     * @throws IOException if network problem\n     */\n    private void handlePlay(HttpExchange exchange) throws IOException {\n\n        piece.play();// this is a synchronized function that doesn't do anything if the piece has\n                     // already played\n\n        // html response\n        exchange.getResponseHeaders().add(\"Content-Type\", \"text/html; charset=utf-8\");\n\n        // must call sendResponseHeaders() before calling getResponseBody()\n        final int successCode = 200;\n        final int lengthNotKnownYet = 0;\n        exchange.sendResponseHeaders(successCode, lengthNotKnownYet);\n\n        // get output stream to write to web browser\n        final boolean autoflushOnPrintln = true;\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(exchange.getResponseBody(), StandardCharsets.UTF_8),\n                autoflushOnPrintln);\n\n        // send some Javascript to browser that redirects the user to the play page\n        out.println(\"<script>window.location.replace(\\\"http://\"+ this.getHostName() +\n        \"/lyrics\\\");</script>\");\n\n        exchange.close();\n\n        System.err.println(\"done streaming request\");\n    }\n\n}",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282901,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/Abc.g",
    "data": "abc-tune ::= abc-header abc-body\n\n\nabc-header ::= field-number comment* field-title other-fields* field-key\n\nfield-number ::= \"X:\" digit+ end-of-line\nfield-title ::= \"T:\" text end-of-line\nother-fields ::= field-composer | field-default-length | field-meter | field-tempo | field-voice | comment\nfield-composer ::= \"C:\" text end-of-line\nfield-default-length ::= \"L:\" note-length-stri.031ct end-of-line\nfield-meter ::= \"M:\" meter end-of-line\nfield-tempo ::= \"Q:\" tempo end-of-line\nfield-voice ::= \"V:\" text end-of-line\nfield-key ::= \"K:\" key end-of-line\n\nkey ::= keynote mode-minor?\nkeynote ::= basenote key-accidental?\nkey-accidental ::= \"#\" | \"b\"\nmode-minor ::= \"m\"\n\nmeter ::= \"C\" | \"C|\" | meter-fraction\nmeter-fraction ::= digit+ \"/\" digit+\n\ntempo ::= meter-fraction \"=\" digit+\n\n\nabc-body ::= abc-line+\nabc-line ::= element+ end-of-line (lyric end-of-line)?  | middle-of-body-field | comment\nelement ::= note-element | rest-element | tuplet-element | barline | nth-repeat | space-or-tab \n\n;; notes\nnote-element ::= note | chord\n\nnote ::= pitch note-length?\npitch ::= accidental? basenote octave?\noctave ::= \"'\"+ | \",\"+\nnote-length ::= (digit+)? (\"/\" (digit+)?)?\nnote-length-strict ::= digit+ \"/\" digit+\n\n;; \"^\" is sharp, \"_\" is flat, and \"=\" is neutral\naccidental ::= \"^\" | \"^^\" | \"_\" | \"__\" | \"=\"\n\nbasenote ::= \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"A\" | \"B\"\n        | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"a\" | \"b\"\n\nrest-element ::= \"z\" note-length?\n\n;; tuplets\ntuplet-element ::= tuplet-spec note-element+\ntuplet-spec ::= \"(\" digit \n\n;; chords\nchord ::= \"[\" note+ \"]\"\n\nbarline ::= \"|\" | \"||\" | \"[|\" | \"|]\" | \":|\" | \"|:\"\nnth-repeat ::= \"[1\" | \"[2\"\n\n; A voice field might reappear in the middle of a piece\n; to indicate the change of a voice\nmiddle-of-body-field ::= field-voice\n\nlyric ::= \"w:\" lyrical-element*\nlyrical-element ::= \" \"+ | \"-\" | \"_\" | \"*\" | \"~\" | \"\\-\" | \"|\" | lyric-text\nlyric-text::= [\\w]*; \n\n\ncomment ::= space-or-tab* \"%\" comment-text newline\ncomment-text ::=s [A-Za-z0-9./][A-Za-z0-9./_-]*;\n\nend-of-line ::= comment | newline\n\ndigit ::= [0-9]\nnewline ::= \"\\n\" | \"\\r\" \"\\n\"?\nspace-or-tab ::= \" \" | \"\\t\"\n\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282902,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/AbcParser.java",
    "data": "/* Copyright (c) 2017-2018 MIT 6.031 course staff, all rights reserved.\n * Redistribution of original or derived work requires permission of course staff.\n */\npackage karaoke.parser;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport edu.mit.eecs.parserlib.ParseTree;\nimport edu.mit.eecs.parserlib.Parser;\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.Chord;\nimport karaoke.sound.Music;\nimport karaoke.sound.Note;\nimport karaoke.sound.Pitch;\nimport karaoke.sound.Rest;\nimport karaoke.sound.Tuplet;\n\npublic class AbcParser {\n    /**\n     * Main method. Parses and then reprints an example expression.\n     * \n     * @param args command line arguments, not used\n     * @throws UnableToParseException if example expression can't be parsed\n     */\n    public static void main(final String[] args) throws UnableToParseException {\n        // final String bassIn = \"A\";\n        // final String sharpIn = \"^C\";\n        // final String doubleflatIn = \"__C\";\n        // final String octaveWithDurationIn = \"C\\'\";\n        // final String octaveWithDurationIn3 = \"C/2\";\n        // final String octaveWithDurationIn2 = \"C\\'/2\";\n        // final String chordIn = \"[C]\";\n        // final String complexChordIn = \"[C/2e\\'_g,,/2]\";\n        // final String tupletIn = \"(3CCC\";\n        // final String complexTupletIn = \"(2C[eg]\";\n\n        // final Music bass = AbcParser.parse(bassIn);\n        // final Music sharp = AbcParser.parse(sharpIn);\n        // final Music doubleFlat = AbcParser.parse(doubleflatIn);\n        // final Music octave = AbcParser.parse(octaveWithDurationIn);\n        // final Music octave3 = AbcParser.parse(octaveWithDurationIn3);\n        // final Music octave2 = AbcParser.parse(octaveWithDurationIn2);\n        // final Music chord = AbcParser.parse(chordIn);\n        // final Music complexChord = AbcParser.parse(complexChordIn);\n        // final Music tuplet = AbcParser.parse(tupletIn);\n        // // final Music complexTuplet = AbcParser.parse(complexTupletIn);\n        // final List<String> testLine = AbcParser.parseLine(\"^^d/2f''f cee|def gfe|faf gfe|[1 dfe dBA:|[2 dfe dcB|]\\n\");\n        // String builder = \"\";\n        // for(String ele : testLine) {\n        //     builder += ele.toString() +\",\";\n        // }\n        // System.out.println(builder);\n    }\n\n    // the nonterminals of the grammar\n    private static enum AbcGrammar {\n        BASENOTE, NOTE, ACCIDENTAL, OCTAVE, PITCH, DIGIT, REST, LENGTH_MODIFIER, ELEMENT, CHORD, NOTE_ELEMENT,\n        NUMERATOR, DENOMINATOR, TUPLET, TUPLET_PREFIX, ABC_LINE, END_OF_LINE, NTH_REPEAT, LINE_ELEMENT, BARLINE,\n        SPACE_OR_TAB\n    }\n\n    private static Parser<AbcGrammar> parser = makeParser();\n    private static Parser<AbcGrammar> lineParser = makeLineParser();\n\n    /**\n     * Compile the grammar into a parser.\n     * \n     * @return parser for the grammar\n     * @throws RuntimeException if grammar file can't be read or has syntax errors\n     */\n    private static Parser<AbcGrammar> makeParser() {\n        try {\n            // read the grammar as a file, relative to the project root.\n            final File grammarFile = new File(\"src/karaoke/parser/music.g\");\n            return Parser.compile(grammarFile, AbcGrammar.ELEMENT);\n\n            // A better way would read the grammar as a \"classpath resource\", which would\n            // allow this code\n            // to be packed up in a jar and still be able to find its grammar file:\n            //\n            // final InputStream grammarStream = Abc.class.openResourceAsStream(\"Abc.g\");\n            // return Parser.compile(grammarStream, AbcGrammar.ELEMENT);\n            //\n            // See\n            // http://www.javaworld.com/article/2077352/java-se/smartly-load-your-properties.html\n            // for a discussion of classpath resources.\n\n            // Parser.compile() throws two checked exceptions.\n            // Translate these checked exceptions into unchecked RuntimeExceptions,\n            // because these failures indicate internal bugs rather than client errors\n        } catch (IOException e) {\n            throw new RuntimeException(\"can't read the grammar file\", e);\n        } catch (UnableToParseException e) {\n            throw new RuntimeException(\"the grammar has a syntax error\", e);\n        }\n    }\n    /**\n     * Compile the grammar into a line parser.\n     * \n     * @return parser for the grammar\n     * @throws RuntimeException if grammar file can't be read or has syntax errors\n     */\n    private static Parser<AbcGrammar> makeLineParser() {\n        try {\n            // read the grammar as a file, relative to the project root.\n            final File grammarFile = new File(\"src/karaoke/parser/music.g\");\n            return Parser.compile(grammarFile, AbcGrammar.ABC_LINE);\n\n        } catch (IOException e) {\n            throw new RuntimeException(\"can't read the grammar file\", e);\n        } catch (UnableToParseException e) {\n            throw new RuntimeException(\"the grammar has a syntax error\", e);\n        }\n    }\n\n    /**\n     * Parse a string into a Music Element.\n     * \n     * @param string string to parse\n     * @return Abc parsed from the string\n     * @throws UnableToParseException if the string doesn't match the Abc grammar\n     */\n    public static Music parse(final String string) throws UnableToParseException {\n        final ParseTree<AbcGrammar> parseTree = parser.parse(string);\n\n        // display the parse tree in various ways, for debugging only\n        // System.out.println(\"parse tree \" + parseTree);\n        // Visualizer.showInBrowser(parseTree);\n\n        final Music element = makeMusicElement(parseTree);\n        return element;\n    }\n    /**\n     * Parse a string into a list of elements.\n     * @param string string to parse\n     * @return Abc parsed from the string\n     * @throws UnableToParseException if the string doesn't match the Abc grammar\n     */\n    public static List<String> parseLine(final String string) throws UnableToParseException {\n        final ParseTree<AbcGrammar> parseTree = lineParser.parse(string.trim());\n\n        // display the parse tree in various ways, for debugging only\n        // System.out.println(\"parse tree \" + parseTree);\n        // Visualizer.showInBrowser(parseTree);\n\n        final List<String> elements = makeMusicElements(parseTree);\n\n        return elements;\n    }\n\n    private static List<String> makeMusicElements(ParseTree<AbcGrammar> parseTree) {\n        List<String> outputMusics = new ArrayList<>();\n\n        assert parseTree.name() == AbcGrammar.ABC_LINE;\n\n        for (ParseTree<AbcGrammar> node : parseTree.children()) {\n//            System.out.println(node.text());\n            switch (node.name()) {\n    \n                case LINE_ELEMENT: // element ::= note_element | tuplet;\n                {\n                    ParseTree<AbcGrammar> child = node.children().get(0);\n                    if(child.name() == AbcGrammar.ELEMENT) {\n                        outputMusics.add(child.text());\n                        continue;\n                    }\n                    else if( child.name() == AbcGrammar.BARLINE) {\n                        outputMusics.add(child.text());\n                        continue;\n                    }\n                    else if(child.name() == AbcGrammar.NTH_REPEAT) {\n                        outputMusics.add(child.text());\n                        continue;\n\n                    }\n                    else if (child.name() == AbcGrammar.SPACE_OR_TAB){ // space or tab\n                        continue;\n\n                    } else {\n                        throw new AssertionError(\"should never get here\");\n                    }\n\n                }\n\n                case END_OF_LINE: \n                {\n                    return outputMusics;\n                }\n                default:\n                {\n//                    System.out.println(node.name());\n                    throw new AssertionError(\"should never get here\");\n                }\n            \n            }\n            \n        }\n        return outputMusics; // Should never get here?\n     }\n    \n     /**\n     * Convert a parse tree into an abstract syntax tree.\n     * \n     * @param parseTree constructed according to the grammar in Exression.g\n     * @return abstract syntax tree corresponding to parseTree\n     */\n    private static Music makeMusicElement(final ParseTree<AbcGrammar> parseTree) {\n\n        switch (parseTree.name()) {\n\n        case ELEMENT: // element ::= note_element | tuplet;\n \n        {\n            final ParseTree<AbcGrammar> child = parseTree.children().get(0);\n            return makeMusicElement(child);\n        }\n        case TUPLET: // tuplet ::= tuplet-prefix note_element+\n        {\n            final ParseTree<AbcGrammar> prefix = parseTree.children().get(0);\n            int numNotes = Integer.parseInt(prefix.text().substring(1));\n\n            List<Music> elementsInTuplet = parseTree.allChildren().stream()\n                    .filter(t -> t.name() == AbcGrammar.NOTE_ELEMENT).map(node -> makeMusicElement(node))\n                    .collect(Collectors.toList());\n\n            assert elementsInTuplet.size() == numNotes : \"spec declaration does not match Tuplet input\";\n\n            return new Tuplet(elementsInTuplet.toArray(new Music[elementsInTuplet.size()]));\n\n        }\n\n        case NOTE_ELEMENT: // note_element ::= chord | pitch;\n        {\n            final ParseTree<AbcGrammar> child = parseTree.children().get(0);\n            return makeMusicElement(child);\n        }\n\n        case CHORD: // chord ::= \"[\" pitch+ \"]\";\n        {\n            List<Music> notesInChord = parseTree.allChildren().stream().filter(t -> t.name() == AbcGrammar.PITCH)\n                    .map(node -> makeMusicElement(node)).collect(Collectors.toList());\n\n            return new Chord(notesInChord.toArray(new Music[notesInChord.size()])); // ask TA\n\n        }\n\n        case PITCH: // pitch ::= (note | (accidental note) | rest) length_modifier?;\n        {\n            Music currentNote = null;\n            int transpose = 0;\n            double duration = 1;\n            boolean setNatural = false;\n            for (int i = 0; i < parseTree.children().size(); i++) {\n                final ParseTree<AbcGrammar> child = parseTree.children().get(i);\n                if (child.name() == AbcGrammar.NOTE || child.name() == AbcGrammar.REST)\n                    currentNote = makeMusicElement(child);\n                else if (child.name() == AbcGrammar.ACCIDENTAL) {\n                    String acc = child.text();\n                    if (acc.contains(\"^\"))\n                        transpose = 1;\n                    else if (acc.contains(\"_\"))\n                        transpose = -1;\n                    else if (acc.contains(\"=\"))\n                        setNatural = true;\n                    transpose *= acc.length();\n                } else if (child.name() == AbcGrammar.LENGTH_MODIFIER) {\n                    for (ParseTree<AbcGrammar> c : child.children()) {\n                        if (c.name() == AbcGrammar.NUMERATOR) {\n                            duration = Double.parseDouble(c.text());\n                        } else if (c.name() == AbcGrammar.DENOMINATOR) {\n                            String denomString = c.text().substring(1);\n                            double denom = denomString.isEmpty() ? 2.0 : Double.parseDouble(denomString);\n                            duration /= denom;\n                        }\n                    }\n                }\n\n            }\n\n            assert duration > 0: \"note durations must be non zero\";\n            assert Double.isFinite(duration): \"note durations must be non zero\";\n\n            if(setNatural)\n                currentNote = ((Note) currentNote).setNatural();\n            currentNote = currentNote.transpose(transpose);\n            currentNote = currentNote.changeDuration(duration);\n            return currentNote;\n\n        }\n\n        case NOTE: // note ::= basenote | (basenote octave);\n        {\n            boolean hasOctave = false;\n            Music currentNote = null;\n            currentNote = makeMusicElement(parseTree.children().get(0));\n\n            try {\n                hasOctave = parseTree.children().get(1).name() == AbcGrammar.OCTAVE;\n\n            } catch (IndexOutOfBoundsException e) {// if there are no octaves following, return note\n                return currentNote;\n            }\n            if(!hasOctave) {\n                throw new RuntimeException(\"Grammer should only allow OCTAVE nodes after NOTE\");\n            }\n\n        \n            String modifier = parseTree.children().get(1).text();\n            int octaves = 1;\n            if (modifier.contains(\",\"))\n                octaves = -1;\n            return currentNote.transpose(Pitch.OCTAVE * octaves);\n\n        }\n\n        case REST: // rest ::= \"z\" | \"Z\";\n        {\n            return new Rest(1);\n        }\n\n        case BASENOTE: // basenote ::= \"C\" | \"D\" | \"E\" | \"c\" | \"d\" ETC\n        {\n            return new Note( parseTree.text().charAt(0), 1.0);\n        }\n\n        default:\n//            System.out.println(parseTree.toString());\n            throw new AssertionError(\"should never get here\");\n        }\n\n    }\n\n}",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282903,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/AbcReference.g",
    "data": "; A subset of abc 2.1 in BNF format\n\nabc-tune ::= abc-header abc-body\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Header\n\n; ignore space-or-tab between terminals in the header\n\nabc-header ::= field-number comment* field-title other-fields* field-key\n\nfield-number ::= \"X:\" digit+ end-of-line\nfield-title ::= \"T:\" text end-of-line\nother-fields ::= field-composer | field-default-length | field-meter | field-tempo | field-voice | comment\nfield-composer ::= \"C:\" text end-of-line\nfield-default-length ::= \"L:\" note-length-strict end-of-line\nfield-meter ::= \"M:\" meter end-of-line\nfield-tempo ::= \"Q:\" tempo end-of-line\nfield-voice ::= \"V:\" text end-of-line\nfield-key ::= \"K:\" key end-of-line\n\nkey ::= keynote mode-minor?\nkeynote ::= basenote key-accidental?\nkey-accidental ::= \"#\" | \"b\"\nmode-minor ::= \"m\"\n\nmeter ::= \"C\" | \"C|\" | meter-fraction\nmeter-fraction ::= digit+ \"/\" digit+\n\ntempo ::= meter-fraction \"=\" digit+\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Body\n\n; spaces and tabs have explicit meaning in the body, don't automatically ignore them\n\nabc-body ::= abc-line+\nabc-line ::= element+ end-of-line (lyric end-of-line)?  | middle-of-body-field | comment\nelement ::= note-element | rest-element | tuplet-element | barline | nth-repeat | space-or-tab \n\n;; notes\nnote-element ::= note | chord\n\nnote ::= pitch note-length?\npitch ::= accidental? basenote octave?\noctave ::= \"'\"+ | \",\"+\nnote-length ::= (digit+)? (\"/\" (digit+)?)?\nnote-length-strict ::= digit+ \"/\" digit+\n\n;; \"^\" is sharp, \"_\" is flat, and \"=\" is neutral\naccidental ::= \"^\" | \"^^\" | \"_\" | \"__\" | \"=\"\n\nbasenote ::= \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"A\" | \"B\"\n        | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"a\" | \"b\"\n\n;; rests\nrest-element ::= \"z\" note-length?\n\n;; tuplets\ntuplet-element ::= tuplet-spec note-element+\ntuplet-spec ::= \"(\" digit \n\n;; chords\nchord ::= \"[\" note+ \"]\"\n\nbarline ::= \"|\" | \"||\" | \"[|\" | \"|]\" | \":|\" | \"|:\"\nnth-repeat ::= \"[1\" | \"[2\"\n\n; A voice field might reappear in the middle of a piece\n; to indicate the change of a voice\nmiddle-of-body-field ::= field-voice\n\nlyric ::= \"w:\" lyrical-element*\nlyrical-element ::= \" \"+ | \"-\" | \"_\" | \"*\" | \"~\" | \"\\-\" | \"|\" | lyric-text\n; lyric-text should be defined appropriately\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; General\n\ncomment ::= space-or-tab* \"%\" comment-text newline\n; comment-text should be defined appropriately\n\nend-of-line ::= comment | newline\n\ndigit ::= [0-9]\nnewline ::= \"\\n\" | \"\\r\" \"\\n\"?\nspace-or-tab ::= \" \" | \"\\t\"",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282904,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/Header.g",
    "data": "abc_tune ::= abc_header abc_body;\n@skip space_or_tab{\n\tabc_header ::= field_number comment* field_title other_fields* field_key;\n\t\n\tfield_number ::= \"X:\" digit+ end_of_line; \n\tfield_title ::= \"T:\" text end_of_line;\n\tother_fields ::= field_composer | field_default_length | field_meter | field_tempo | field_voice | comment;\n\tfield_composer ::= \"C:\" text end_of_line;\n\tfield_default_length ::= \"L:\" note_length_strict end_of_line;\n\tfield_meter ::= \"M:\" meter end_of_line;\n\tfield_tempo ::= \"Q:\" tempo end_of_line;\n\tfield_voice ::= \"V:\" text end_of_line;\n\tfield_key ::= \"K:\" key end_of_line;\n\t\n\tkey ::= keynote mode_minor?;\n\tkeynote ::= basenote key_accidental?;\n\tkey_accidental ::= \"#\" | \"b\";\n\tmode_minor ::= \"m\";\n\t\n\tmeter ::= \"C\" | \"C|\" | meter_fraction;\n\tmeter_fraction ::= digit+ \"/\" digit+;\n\t\n\ttempo ::= meter_fraction \"=\" digit+;\n\t\n\tcomment ::= space_or_tab* \"%\" comment_text newline;\n\tcomment_text ::= [^\\n]*;\n\t\n\tend_of_line ::= newline | comment;\n}\nabc_body ::= abc_line+;\nabc_line ::=  lyric_chunk | middle_of_body_field | comment;\nlyric_chunk ::= line (lyric_line)?;\nline ::= element+ end_of_line?;\nlyric_line ::=  lyric end_of_line?;\n\nelement ::= note_element | rest_element | tuplet_element | barline | nth_repeat | space_or_tab;\n\nnote_element ::= note | chord;\n\nnote ::= pitch note_length?;\npitch ::= accidental? basenote octave?;\noctave ::= \"'\"+ | \",\"+;\nnote_length ::= (digit+)? (\"/\" (digit+)?)?;\nnote_length_strict ::= digit+ \"/\" digit+;\n\naccidental ::= \"^\" | \"^^\" | \"_\" | \"__\" | \"=\";\n\nrest_element ::= \"z\" note_length?;\n\ntuplet_element ::= tuplet_spec note_element+;\ntuplet_spec ::= \"(\" digit;\n\n\nchord ::= \"[\" note+ \"]\";\n\nbarline ::= \"|\" | \"||\" | \"[|\" | \"|]\" | \":|\" | \"|:\";\nnth_repeat ::= \"[1\" | \"[2\";\n\nmiddle_of_body_field ::= field_voice; \n\nlyric ::= \"w:\" lyrical_element*; \nlyrical_element ::= \" \"+ | \"-\" | \"_\" | \"*\" | \"~\" | \"\\_\" | \"|\" | lyric_text;\nlyric_text ::= [^-_*~\\\\_\\\\|\\n]*; \n\t\n\tnote_length_strict ::= digit+ \"/\" digit+; \n\tdigit ::= [0-9];\n\tnewline ::= \"\\n\" | \"\\r\" \"\\n\"?;\n\tspace_or_tab ::= \" \" | \"\\t\";\n\t\n\ttext ::= [A-Za-z0-9./]subtext*;\n\tsubtext ::= space_or_tab* [A-Za-z0-9,./_'-]*; \n\t\n    basenote ::= \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"A\" | \"B\"\n        | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"a\" | \"b\"; \n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282905,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/LyricParser.java",
    "data": "/* Copyright (c) 2017-2018 MIT 6.031 course staff, all rights reserved.\n * Redistribution of original or derived work requires permission of course staff.\n */\npackage karaoke.parser;\n\nimport java.io.File;\nimport java.io.IOException;\nimport edu.mit.eecs.parserlib.ParseTree;\nimport edu.mit.eecs.parserlib.Parser;\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.LyricLine;\n\n/**\n * Handles parsing that involves reading in lyrics.\n */\npublic class LyricParser {\n//    /**\n//    *This method is strictly for manual testing\n//    * \n//     * @param args command line arguments, not used\n//     * @throws UnableToParseException if example expression can't be parsed\n//     */\n//    public static void main(final String[] args) throws UnableToParseException {\n//        final String syllableIn = \"thia\";\n//        final String hyphenIn = \"thi-d\";\n//        final String underScore = \"hi___\";\n//        final String tilde = \"this~another~one\";\n//        final String concatString = \"this\\\\-th\";\n//        final String spacesAndStarsIn = \"this is a line***\";\n//        final String waxiesDargleIn = \"Sa-ys my au-l' wan to your aul' wan, Will~ye come to the Wa-x-ies dar-gle?\";\n//\n//        LyricParser.parse(syllableIn, 1);\n//        LyricParser.parse(hyphenIn,2);\n//        LyricParser.parse(underScore,4);\n//        LyricParser.parse(tilde,1);\n//        LyricParser.parse(concatString,1);\n//        LyricParser.parse(spacesAndStarsIn,10);\n//        LyricParser.parse(waxiesDargleIn,19);\n//\n//    }\n\n    // the nonterminals of the grammar\n    private static enum LyricGrammar {\n        LINE, SYLLABLE_MOD, HYPHEN, UNDERSCORE, STAR, TILDE, CONCAT, BAR, \n        END_LINE, SYLLABLE, WORD, WHITESPACE, ELEMENT\n    }\n\n    private static Parser<LyricGrammar> parser = makeParser();\n\n    /**\n     * Compile the grammar into a parser.\n     * \n     * @return parser for the grammar\n     * @throws RuntimeException if grammar file can't be read or has syntax errors\n     */\n    private static Parser<LyricGrammar> makeParser() {\n        try {\n            // read the grammar as a file, relative to the project root.\n            final File grammarFile = new File(\"src/karaoke/parser/lyrics.g\");\n            return Parser.compile(grammarFile, LyricGrammar.LINE);\n\n            // A better way would read the grammar as a \"classpath resource\", which would\n            // allow this code\n            // to be packed up in a jar and still be able to find its grammar file:\n            //\n            // final InputStream grammarStream = Abc.class.openResourceAsStream(\"Abc.g\");\n            // return Parser.compile(grammarStream, LyricGrammar.ELEMENT);\n            //\n            // See\n            // http://www.javaworld.com/article/2077352/java-se/smartly-load-your-properties.html\n            // for a discussion of classpath resources.\n\n            // Parser.compile() throws two checked exceptions.\n            // Translate these checked exceptions into unchecked RuntimeExceptions,\n            // because these failures indicate internal bugs rather than client errors\n        } catch (IOException e) {\n            throw new RuntimeException(\"can't read the grammar file\", e);\n        } catch (UnableToParseException e) {\n            throw new RuntimeException(\"the grammar has a syntax error\", e);\n        }\n    }\n\n    /**\n     * Parse a string into a LyricLine object of length numNotes\n     * @param numNotes The number of musical notes that are in the line of music corresponding\n     * with this line of lyrics\n     * @param string string to parse\n     * @return LyricLine parsed from the string with a length of passed in integer\n     * @throws UnableToParseException if the string doesn't match the Abc grammar\n     */\n    public static LyricLine parse(final String string, int numNotes) throws UnableToParseException {\n        // if emepty string, don't try to parse it\n        if(string.isEmpty()) {\n            final LyricLine element = new LyricLine(numNotes, 4);\n            element.adjustLength();\n            return element;\n        }\n\n        \n        final ParseTree<LyricGrammar> parseTree = parser.parse(string);\n\n        // display the parse tree in various ways, for debugging only\n        // System.out.println(\"parse tree \" + parseTree);\n        // Visualizer.showInBrowser(parseTree);\n\n        // make an AST from the parse tree\n        final LyricLine element = makeLyricLine(parseTree, new LyricLine(numNotes, 4));\n        // System.out.println(\"AST \" + expression);\n        element.adjustLength();\n        element.setIndex(0);\n        return element;\n    }\n\n    /**\n     * Convert a parse tree into an abstract syntax tree.\n     * \n     * @param parseTree constructed according to the grammar in Exression.g\n     * @return abstract syntax tree corresponding to parseTree\n     */\n    private static LyricLine makeLyricLine(final ParseTree<LyricGrammar> parseTree, LyricLine line) {\n\n        switch (parseTree.name()) {\n\n        case LINE: //     line::=  element+;\n\n        {\n            for (ParseTree<LyricGrammar> child : parseTree.children()) {\n                line = makeLyricLine(child, line);\n            }\n            return line;\n        }\n\n        case ELEMENT: // element::= (word tilde?) | bar | star;\n        {\n            ParseTree<LyricGrammar> child = parseTree.children().get(0);\n            line = makeLyricLine(child, line);\n            if(parseTree.children().size() > 1)\n                 line = makeLyricLine(parseTree.children().get(1), line);\n            return line;\n\n        }\n\n        case WORD: // word::= syllable | (syllable syllable_mod*)+;\n\n        {\n            for (ParseTree<LyricGrammar> child : parseTree.children()) {\n                line = makeLyricLine(child, line);\n            }\n\n            line.endWord();\n            return line;\n        }\n\n        case SYLLABLE: // syllable::= [^|\\-~*_\\\\s]+;\n\n        {\n            line.addSyllable(parseTree.text());\n            return line;\n        }\n\n        case SYLLABLE_MOD: // syllable_mod::= hyphen | underscore | star | concat\n\n        {\n            ParseTree<LyricGrammar> child = parseTree.children().get(0);\n            return makeLyricLine(child, line);\n        }\n\n        case HYPHEN: {\n            line.addHyphen();\n            return line;\n        }\n\n        case UNDERSCORE: // underscore::= \"_\";\n        {\n            line.addUnderscore();\n            return line;\n        }\n\n        case STAR: // star::= \"*\";\n        {\n            line.addStar();\n            return line;\n        }\n\n        case TILDE: // tilde::= \"~\";\n        {\n            line.addTilde();\n            return line;\n        }\n\n        case CONCAT: // concat::= \"\\-\";\n        {\n            line.addConcat();\n            return line;\n        }\n\n        case BAR: // bar::= \"|\";\n        {\n//            line.toBarLine();\n//            line.endWord();\n            return line;\n        }\n        case END_LINE: {\n            return line;\n        }\n\n        default:\n            System.out.println(parseTree.toString());\n            throw new AssertionError(\"should never get here\");\n        }\n    }\n}",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282906,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/Lyrics.g",
    "data": "@skip whitespace {\n    line::=  element+;\n}\n\nelement::= (word tilde?) | bar | star;\n\nword::= (syllable syllable_mod*)+;\n\nsyllable_mod::= hyphen | underscore | concat;\n\nhyphen::= \"-\";\n\nunderscore::= \"_\";\n\nstar::= \"*\";\n\ntilde::= \"~\";\n\nconcat::= \"\\\\-\";\n\nbar::= \"|\";\n\nsyllable::= [^~*_|\\s\\\\-]+;\nwhitespace::= \" \" | end_line;\nend_line::= \"\\r\"| \"\\n\"| \"\\t\";",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282907,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/PieceParser.java",
    "data": "package karaoke.parser;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\n\nimport edu.mit.eecs.parserlib.ParseTree;\nimport edu.mit.eecs.parserlib.Parser;\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.Piece;\nimport karaoke.sound.Staff;\n\npublic class PieceParser {\n    public static final String DEFAULT_METER = \"4/4\"; \n    public static final double DEFAULT_NOTE_LENGTH = 1.0/8.0;\n    public static final int DEFAULT_TEMPO = 100; \n//    /**\n//     * Main method. Parses and then reprints an example Piece object.\n//     * \n//     * @param args command line arguments, not used\n//     * @throws UnableToParseException if example expression can't be parsed\n//     */\n//    public static void main(final String[] args) throws UnableToParseException {\n//        String input1 = \"X: 1\\n\" + \n//                \"T:Bagatelle No.25 in A, WoO.59\\n\" + \n//                \"C:Ludwig van Beethoven\\n\" + \n//                \"V:1\\n\" + \n//                \"V:2\\n\" + \n//                \"M:3/8\\n\" + \n//                \"L:1/16\\n\" + \n//                \"Q:1/8=140\\n\" + \n//                \"K:A#m\\n\" + \n//                \"V:1\\n\" + \n//                \"e^d|e^deB=dc|A2 z CEA|B2 z E^GB|c2 z Ee^d|\\n\" + \n//                \"V:2\\n\" + \n//                \"z2|z6|A,,E,A, z z2|E,,E,^G, z z2|A,,E,A, z z2|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \"e^deB=dc|A2 z CEA|B2 z EcB|[1A2 z2:|[2A2z Bcd|\\n\" + \n//                \"V:2\\n\" + \n//                \"z6|A,,E,A, z z2|E,,E,^G, z z2|[1A,,E,A, z :|[2A,,E,A, z z2|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \"|:e3 Gfe|d3 Fed|c3 Edc|B2 z Ee z|z ee' z z ^d|\\n\" + \n//                \"V:2\\n\" + \n//                \"|:C,E,C z z2|G,,G,B, z z2|A,,E,A, z z2|E,,E,E z z E|e z z ^de z|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \"e z z ^ded|e^deB=dc|A2 z CEA|B2 zE^GB|c2 z Ee^d|\\n\" + \n//                \"V:2\\n\" + \n//                \"z ^de z z2|z6|A,,E,A, z z2|E,,E,^G, z z2|A,,E,A, z z2|\\n\";\n//        String input = \"X:1\\n\" + \n//                \"T:Alphabet Song\\n\" + \n//                \"C:Traditional Kid's Song\\n\" + \n//                \"M:4/4\\n\" + \n//                \"L:1/4\\n\" + \n//                \"Q:1/4=100\\n\" + \n//                \"K:D\\n\" + \n//                \"| D D A A | B B A2 | G G F F | E/2 E/2 E/2 E/2 D2 |\\n\" + \n//                \"w:A B C D E F G  H I J K L  M  N  O   P\\n\" + \n//                \"  A A G F | F F E2 | A       A  G  G | F F E2 | \\n\" + \n//                \"w:Q R S *   T U V  W~(dou-ble u) | X Y Z\\n\" + \n//                \"   D   D    A    A | B B A2 | G    G  F    F | E     E  D2 |\\n\" + \n//                \"w: Now I've said my A B C's. Tell me what you think of me.\\n\"; \n//        String input2 = \"X: 1\\n\" + \n//                \"T:Piece No.1\\n\" + \n//                \"M:2/4\\n\" +  \n//                \"Q:1/4=140\\n\" + \n//                \"K:C\\n\" + \n//                \"C C C3/4 D/4 E | E3/4 D/4 E3/4 F/4 G2 |\\n\" + \n//                \"(3ccc (3GGG (3EEE (3CCC | G3/4 F/4 E3/4 F/4 C2 |]\\n\" +\n//                \"w: Now I've said my A B C's. Tell me what you think of me.\";\n//        String input3 = \"X:8628\\n\" + \n//                \"T:Prelude BWV 846 no. 1\\n\" + \n//                \"C:Johann Sebastian Bach\\n\" + \n//                \"M:4/4\\n\" + \n//                \"L:1/16\\n\" + \n//                \"Q:1/4=70\\n\" + \n//                \"V:1\\n\" + \n//                \"V:2\\n\" + \n//                \"V:3\\n\" + \n//                \"K:C\\n\" + \n//                \"V:1\\n\" + \n//                \"z2 Gc eGce z2 Gc eGce| z2 Ad fAdf z2 Ad fAdf| z2 Gd fGdf z2 Gd fGdf|\\n\" + \n//                \"V:2\\n\" + \n//                \"z E7 z E7|z D7 z D7|z D7 z D7|\\n\" + \n//                \"V:3\\n\" + \n//                \"C8 C8|C8 C8|B,8 B,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 Gc eGce z2 Gc eGce| z2 Ae aAea z2 Ae aAea| z2 ^FA dFAd z2 FA dFAd|\\n\" + \n//                \"V:2\\n\" + \n//                \"z E7 z E7|z E7 z E7|z D7 z D7|\\n\" + \n//                \"V:3\\n\" + \n//                \"C8 C8|C8 C8|C8 C8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 Gd gGdg z2 Gd gGdg| z2 EG cEGc z2 EG cEGc| z2 EG cEGc z2 EG cEGc|\\n\" + \n//                \"V:2\\n\" + \n//                \"z D7 z D7|z C7 z C7|z C7 z C7|\\n\" + \n//                \"V:3\\n\" + \n//                \"B,8 B,8|B,8 B,8|A,8 A,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 D^F cDFc z2 DF cDFc| z2 DG BDGB z2 DG BDGB| z2 EG ^cEGc z2 EG cEGc|\\n\" + \n//                \"V:2\\n\" + \n//                \"z A,7 z A,7|z B,7 z B,7|z _B,7 z B,7|\\n\" + \n//                \"V:3\\n\" + \n//                \"D,8 D,8|G,8 G,8|G,8 G,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 DA dDAd z2 DA dDAd| z2 DF BDFB z2 DF BDFB| z2 CG cCGc z2 CG cCGc|\\n\" + \n//                \"V:2\\n\" + \n//                \"z A,7 z A,7|z _A,7 z A,7|z G,7 z G,7|\\n\" + \n//                \"V:3\\n\" + \n//                \"F,8 F,8|F,8 F,8|E,8 E,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 A,C FA,CF z2 A,C FA,CF| z2 A,C FA,CF z2 A,C FA,CF| z2 G,B, FG,B,F z2 G,B, FG,B,F|\\n\" + \n//                \"V:2\\n\" + \n//                \"z F,7 z F,7|z F,7 z F,7|z D,7 z D,7|\\n\" + \n//                \"V:3\\n\" + \n//                \"E,8 E,8|D,8 D,8|G,,8 G,,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 G,C EG,CE z2 G,C EG,CE| z2 _B,C EB,CE z2 B,C EB,CE| z2 A,C EA,CE z2 A,C EA,CE|\\n\" + \n//                \"V:2\\n\" + \n//                \"z E,7 z E,7|z G,7 z G,7|z F,7 z F,7|\\n\" + \n//                \"V:3\\n\" + \n//                \"C,8 C,8|C,8 C,8|F,,8 F,,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 A,C _EA,CE z2 A,C EA,CE| z2 B,C DB,CD z2 B,C DB,CD| z2 G,B, DG,B,D z2 G,B, DG,B,D|\\n\" + \n//                \"V:2\\n\" + \n//                \"z C,7 z C,7|z F,7 z F,7|z F,7 z F,7|\\n\" + \n//                \"V:3\\n\" + \n//                \"^F,,8 F,,8|_A,,8 A,,8|G,,8 G,,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 G,C EG,CE z2 G,C EG,CE| z2 G,C FG,CF z2 G,C FG,CF| z2 G,B, FG,B,F z2 G,B, FG,B,F|\\n\" + \n//                \"V:2\\n\" + \n//                \"z E,7 z E,7|z D,7 z D,7|z D,7 z D,7|\\n\" + \n//                \"V:3\\n\" + \n//                \"G,,8 G,,8|G,,8 G,,8|G,,8 G,,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 A,C ^FA,CF z2 A,C FA,CF| z2 G,C GG,CG z2 G,C GG,CG| z2 G,C FG,CF z2 G,C FG,CF|\\n\" + \n//                \"V:2\\n\" + \n//                \"z _E,7 z E,7|z E,7 z E,7|z D,7 z D,7|\\n\" + \n//                \"V:3\\n\" + \n//                \"G,,8 G,,8|G,,8 G,,8|G,,8 G,,8|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \" z2 G,B, FG,B,F z2 G,B, FG,B,F| z2 G,_B, EG,B,E z2 G,B, EG,B,E|z2 F,A, CFCA, CA,F,A, F,D,F,D,|\\n\" + \n//                \"V:2\\n\" + \n//                \"z D,7 z D,7|z C,7 z C,7|z C,15|\\n\" + \n//                \"V:3\\n\" + \n//                \"G,,8 G,,8|C,,8 C,,8|C,,16|\\n\" + \n//                \"%\\n\" + \n//                \"V:1\\n\" + \n//                \"z2 GB dfdB dBGB DFED|[E16G16c16]|]\\n\" + \n//                \"V:2\\n\" + \n//                \"z B,,15|C,16|]\\n\" + \n//                \"V:3\\n\" + \n//                \"C,,16|C,,16|]\\n\"; \n//        final Piece piece = PieceParser.parse(input3);\n//        // System.out.println(\"parsed\\n\" + piece);\n//    }\n    \n    // the nonterminals of the grammar\n    private static enum AbcGrammar {\n        abc_tune, abc_header, field_number, field_title, field_composer, other_fields, field_default_length, field_meter,\n        field_tempo, field_voice, field_key, key, keynote, meter, meter_fraction, tempo, comment, end_of_line,\n        note_length_strict, digit, text, mode_minor, basenote, key_accidental, space_or_tab, comment_text, newline,\n        subtext, abc_body, lyric_chunk, middle_of_body_field, lyric, lyrical_element, lyric_text,\n        element, note_element, rest_element, tuplet_element, barline, nth_repeat, note, pitch, note_length, accidental, octave,\n        tuplet_spec, chord, line, lyric_line, abc_line\n    }\n\n    private static Parser<AbcGrammar> parser = makeParser();\n    \n    /**\n     * Compile the grammar into a parser.\n     * \n     * @return parser for the grammar\n     * @throws RuntimeException if grammar file can't be read or has syntax errors\n     */\n    private static Parser<AbcGrammar> makeParser() {\n        try {\n            // read the grammar as a file, relative to the project root.\n            final File grammarFile = new File(\"src/karaoke/parser/Header.g\");\n            return Parser.compile(grammarFile, AbcGrammar.abc_tune);\n        // Parser.compile() throws two checked exceptions.\n        // Translate these checked exceptions into unchecked RuntimeExceptions,\n        // because these failures indicate internal bugs rather than client errors\n        } catch (IOException e) {\n            throw new RuntimeException(\"can't read the grammar file\", e);\n        } catch (UnableToParseException e) {\n            throw new RuntimeException(\"the grammar has a syntax error\", e);\n        }\n    }\n\n    /**\n     * Parse a string into an expression.\n     * @param string string to parse\n     * @return Piece parsed from the string\n     * @throws UnableToParseException if the string doesn't match the Header grammar\n     */\n    public static Piece parse(final String string) throws UnableToParseException {\n        // parse the example into a parse tree\n        final ParseTree<AbcGrammar> parseTree = parser.parse(string);\n//        System.out.println(parseTree); \n//        Visualizer.showInBrowser(parseTree);\n        // make an AST from the parse tree\n        Piece piece = makePieceObject(parseTree); \n        return piece;\n    }\n    \n    /**\n     * Convert a parse tree into an initialized Piece object\n     * \n     * @param parseTree constructed according to the grammar in Header.g\n     * @return Piece object corresponding to parseTree\n     * @throws UnableToParseException if internal parsers detect invalid syntax\n     */\n    private static Piece makePieceObject(final ParseTree<AbcGrammar> parseTree) throws  UnableToParseException {\n        Piece piece = new Piece(1, \"default\", \"default\", \"default\", DEFAULT_METER,DEFAULT_NOTE_LENGTH, DEFAULT_TEMPO);\n        Map<String,List<String>> voiceNotes = new HashMap<>(); \n        Map<String,List<String>> voiceLyrics = new HashMap<>();\n        for (ParseTree<AbcGrammar> half : parseTree.children()) {\n            switch(half.name()) {\n            case abc_header: {\n//                System.out.println(\"reached header\");\n                for (ParseTree<AbcGrammar> child: half.children()) {\n//                    System.out.println(\"header child \" + child.name());\n                    switch(child.name()) {\n                        case field_number: {\n//                            System.out.println(\"reached field number X\");\n                            int indexOfColon = child.text().indexOf(':');\n                            piece.setIndex(Integer.valueOf(child.text().substring(indexOfColon+1).trim()));\n//                            for (ParseTree<AbcGrammar> c: child.childrenByName(AbcGrammar.digit)) {\n//                                piece.setIndex(Integer.valueOf(c.text()));\n//                            }\n                            break; \n                        } case field_title: {\n//                            System.out.println(\"reached title\");\n                            for (ParseTree<AbcGrammar> c: child.childrenByName(AbcGrammar.text)) {\n                                piece.setTitle(c.text());\n                            }\n                            break; \n                        } case other_fields: {\n//                            System.out.println(\"reached other fields\");\n                            for (ParseTree<AbcGrammar> gc : child.children()) {\n                                switch(gc.name()) {\n                                    case field_composer: {\n//                                        System.out.println(\"reached composer\");\n                                        for (ParseTree<AbcGrammar> gcc: gc.childrenByName(AbcGrammar.text)) {\n                                            piece.setComposer(gcc.text());\n                                        }\n                                        break; \n                                    } case field_default_length: {\n//                                        System.out.println(\"reached note length\");\n                                        for (ParseTree<AbcGrammar> gcc: gc.childrenByName(AbcGrammar.note_length_strict)) {\n                                            piece.setDefaultNoteLength(Piece.decimalValueOfString(gcc.text()));\n                                        }\n                                        break;\n                                    } case field_meter: {\n//                                        System.out.println(\"reached field meter\");\n                                        for (ParseTree<AbcGrammar> gcc: gc.childrenByName(AbcGrammar.meter)) {\n                                            piece.setMeter(gcc.text());\n                                        }\n                                        break;\n                                    } case field_tempo: {\n//                                        System.out.println(\"reached field tempo\");\n                                        for (ParseTree<AbcGrammar> gcc: gc.childrenByName(AbcGrammar.tempo)) {\n                                            String gccText = gcc.text();\n                                            gccText = gccText.replaceAll(\"\\\\s+\",\"\"); // removes whitespace from: https://stackoverflow.com/questions/5455794/removing-whitespace-from-strings-in-java\n                                            int equalsIndex = gccText.indexOf(\"=\"); //index of where = appears\n                                            String meterNoteLength = gccText.substring(0, equalsIndex);\n                                            String meterNumOfNotesPerMin = gccText.substring(equalsIndex+1);\n                                            piece.setTempoNoteLength(Piece.decimalValueOfString(meterNoteLength));\n                                            piece.setTempo(Integer.parseInt(meterNumOfNotesPerMin));\n                                        }\n                                        break;\n                                    } case field_voice: {\n//                                        System.out.println(\"reached field voice\");\n                                        break;\n                                    } default:\n                                        throw new AssertionError(\"should never get here\");\n                                    }\n                            }\n                            break;\n                        } case field_key: {\n                            for (ParseTree<AbcGrammar> c: child.childrenByName(AbcGrammar.key)) {\n                                piece.setKey(c.text());\n                            }\n                            break; \n                        } default:\n                            throw new AssertionError(\"should never get here\");\n                        }\n                }\n                break; \n            }\n            case abc_body: {\n//                System.out.println(\"reached body\");\n                String voice = \"main\"; \n                for (ParseTree<AbcGrammar> child: half.children()) {\n//                    System.out.println(\"header child \" + child.name());\n                    for (ParseTree<AbcGrammar> gc: child.children()) {\n                        switch(gc.name()) {\n                        case middle_of_body_field: {\n                          voice = gc.text().trim();\n                          int indexOfColon = voice.indexOf(\":\");\n                          voice = voice.substring(indexOfColon+1);\n//                          System.out.println(\"changed voice to \" + voice);\n                          break;\n                        } case lyric_chunk: {\n//                            System.out.println(\"voice is \" + voice);\n                            if (!voiceNotes.containsKey(voice)) {\n//                                System.out.println(\"new voice found\");\n                                voiceNotes.put(voice, new ArrayList<>()); \n                                voiceLyrics.put(voice, new ArrayList<>()); \n                            }\n                            for (ParseTree<AbcGrammar> ggc : gc.children()) {\n                                switch(ggc.name()) {\n                                case line: {\n//                                    System.out.println(\"reached line case \" + \"voice \" + voice);\n                                    voiceNotes.get(voice).add(ggc.text()); \n                                    break;\n                                } case lyric_line: {\n//                                    System.out.println(\"reached lyric line\");\n                                    while (voiceNotes.get(voice).size() > voiceLyrics.get(voice).size()+1) {\n                                        voiceLyrics.get(voice).add(\"\"); \n                                    }\n                  \n                                    int startIndexOfLyrics = ggc.text().indexOf(':');\n//                                    System.out.println(ggc.text());\n                                    voiceLyrics.get(voice).add(ggc.text().substring(startIndexOfLyrics+1)); \n                                    break;\n                                }\n                                default:\n                                    break;\n                                }\n                            }\n                            break; \n                        } case comment: { // do nothing on comments\n                            break;\n                        } default:\n                            break; \n                        }\n                    }\n                } \n              break;\n            } default:\n            throw new AssertionError(\"should never get here\");\n        }\n        }\n        for (String v : voiceLyrics.keySet()) {\n            while (voiceNotes.get(v).size() > voiceLyrics.get(v).size()) {\n                voiceLyrics.get(v).add(\"\"); \n            }\n        }\n        // create staff for each voice\n        for (String v : voiceNotes.keySet()) {\n            Staff s = new Staff(piece.getKey(),piece.getMeter(),piece.getNoteLength(),piece.getTempo(), piece.getTempoNoteLength()); \n            s = StaffParser.parse(voiceNotes.get(v), voiceLyrics.get(v), s);\n            piece.addStaff(s);  \n        }\n        piece.initializePiece(); \n        return piece; \n    }\n    \n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282908,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/StaffParser.java",
    "data": "package karaoke.parser;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.LyricLine;\nimport karaoke.sound.Music;\nimport karaoke.sound.Music.MusicKeys;\nimport karaoke.sound.Staff;\n \n/**\n * Parses the notes and lyrics of the music to create a staff object \n * that holds that information. Handles any repeats in the music\n */\npublic class StaffParser {\n    public static final int DEFAULT_NOTES_PER_BEAT = 4; \n    /**\n     * Takes a staff and returns a copy of it with the given music\n     * @param linesOfNotes The string representations of lines of notes where linesOfNotes.get(i) corresponds\n     * with the ith line of music \n     * @param staff The staff to copy and modify\n     * @return A staff that contains the music and lyrics of the staff\n     * @throws UnableToParseException Thrown if unable to parse one of the lines of notes or lyrics\n     */\n    public static Staff parse(List<String> linesOfNotes,  Staff staff) throws UnableToParseException{\n        List<String> emptyLyricList = new ArrayList<>();\n        for(String note : linesOfNotes) {\n            emptyLyricList.add(\"\");\n        }\n        return parse(linesOfNotes, emptyLyricList, staff);\n    }\n    \n    /**\n     * Takes a staff and returns a copy of it with the given music notes and lyrics\n     * @param linesOfNotes The string representations of lines of notes where linesOfNotes.get(i) corresponds\n     * with the ith line of music \n     * @param lyricLines The string representations of lines of lyrics where lyricLines.get(i) corresponds \n     * with the ith line of lyrics (may contain empty strings)\n     * @param staff The staff to copy and modify\n     * @return A staff that contains the music and lyrics of the staff\n     * @throws UnableToParseException Thrown if unable to parse one of the lines of notes or lyrics\n     */\n    public static Staff parse(List<String> linesOfNotes, List<String> lyricLines,  Staff staff) throws UnableToParseException {\n        List<String> lyricFinal = new ArrayList<>();\n        List<Music> noteFinal = new ArrayList<>();\n        \n        List<String> lyricTemp = new ArrayList<>();\n        List<Music> noteTemp = new ArrayList<>();\n        \n        Set<String> clearTempSet = new HashSet<>();\n        clearTempSet.add(\"[|\");\n        clearTempSet.add(\"|]\");\n        clearTempSet.add(\"||\");\n        clearTempSet.add(\"|:\");\n        clearTempSet.add(\"[|\");\n        \n        Set<String> nonAlphabets = new HashSet<>(clearTempSet);\n        nonAlphabets.add(\":|\");\n        nonAlphabets.add(\"[1\");\n        nonAlphabets.add(\"[2\");\n        nonAlphabets.add(\"|\");\n\n        \n        List<List<String>> notesAndBarsList = new ArrayList<>();\n        \n        //creates a 2d list of each array with bar lines, repeats, and ends included as elements\n        for(String line : linesOfNotes) {\n//            System.out.println(\"passed to abc parser \" +line);\n            notesAndBarsList.add(AbcParser.parseLine(line));\n        }\n        \n        //the number of notes in line ith line of music\n        List<Integer> lineLength = new ArrayList<>();\n        for(int i=0; i<notesAndBarsList.size(); i++) {\n            int numLineNotes = 0;\n            for(String note : notesAndBarsList.get(i)) {\n                //if an alphabet\n                if(!nonAlphabets.contains(note)) {\n                    numLineNotes++;\n                }\n            }\n            lineLength.add(numLineNotes);\n        }\n        \n        List<LyricLine> lyricList = new ArrayList<>();\n        for(int i=0; i<linesOfNotes.size(); i++) {\n            String currentLine = lyricLines.get(i);\n\n            if(currentLine.isEmpty()) {\n                LyricLine temp = new LyricLine(lineLength.get(i), DEFAULT_NOTES_PER_BEAT);\n                temp.adjustLength();\n                lyricList.add(temp);\n            }\n            else\n                lyricList.add(LyricParser.parse(lyricLines.get(i), lineLength.get(i)));\n        }\n        \n        \n        boolean firstEnding = false; //\n        for(int i=0; i<notesAndBarsList.size(); i++) {\n            for(int j=0; j<notesAndBarsList.get(i).size(); j++) {\n                String currentNote = notesAndBarsList.get(i).get(j);\n                \n                //if the note is an alphabet\n                if(!nonAlphabets.contains(currentNote) && !firstEnding) {\n                    noteTemp.add(AbcParser.parse(currentNote));\n                    noteFinal.add(AbcParser.parse(currentNote));\n                    \n                    String lyricString = lyricList.get(i).printLyricLine();\n                    lyricTemp.add(lyricString);\n                    lyricFinal.add(lyricString);\n                    \n                }else if(!nonAlphabets.contains(currentNote) && firstEnding) {\n                    noteFinal.add(AbcParser.parse(currentNote));\n                    String lyricString = lyricList.get(i).printLyricLine();\n                    lyricFinal.add(lyricString);\n                    \n                }else if(clearTempSet.contains(currentNote)) {\n                    noteTemp.clear();\n                    lyricTemp.clear();\n                    \n                }else if(currentNote.equals(\"[1\")) {\n                    firstEnding = true;\n                    \n                }else if(currentNote.equals(\"[2\")) {\n                    firstEnding = false;\n                    noteFinal.addAll(noteTemp);\n                    noteTemp.clear();\n                    \n                    lyricFinal.addAll(lyricTemp);\n                    lyricTemp.clear();\n                    \n                }else if(currentNote.equals(\":|\")) {\n                    noteFinal.addAll(noteTemp);\n                    noteTemp.clear();\n                    \n                    lyricFinal.addAll(lyricTemp);\n                    lyricTemp.clear();\n                }else if(!currentNote.equals(\"|\")) {\n                    throw new AssertionError(\"didn't know how to handle: \" + currentNote);\n                }\n            }\n        }\n        \n        List<Music> newMusic = new ArrayList<>();\n        MusicKeys keyEnum = Music.keyToEnum(staff.getKey());\n        for(Music m : noteFinal) {\n            newMusic.add(m.modifyKey(keyEnum));\n        }\n    \n        \n        Staff outputStaff = staff.copy();\n        outputStaff.addLineOfMusic(newMusic);\n        for(String lyric : lyricFinal) {\n            outputStaff.addLyric(lyric);\n        }\n\n        // System.out.println(outputStaff);\n        return outputStaff;\n    }\n        \n\n//    /**\n//     * This method is used for manual testing of the staff parser. \n//     * @param args String of args \n//     * @throws UnableToParseException incorrect abc file \n//     */\n//    public static void main(final String[] args) throws  UnableToParseException {\n////        List<String> inputNotesList = Arrays.asList(\"[| |: ^C2D,/E2F,, :|GA2_B/^^C|]\", \"B A B B :| G G A B\");\n//        \n//        List<String> inputNotesList = Arrays.asList(\"|: C D E F\", \"|[1 G A B c\", \"| G A B B\", \":|[2 F E D C |\");\n//        \n//        List<String> lyricInputList = Arrays.asList(\"scoop-ity poop-y\",\n//                                                   \"syll-a-ble bite\",\n//                                                   \"take me home now\",\n//                                                   \"but these bars though\");\n//\n//        Staff staff = new Staff(\"K:C\", \"4/4\", 1.0/DEFAULT_NOTES_PER_BEAT, 100);\n//        Staff actual = StaffParser.parse(inputNotesList, lyricInputList, staff);\n//\n//    }\n}\n\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282909,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/parser/music.g",
    "data": "abc_line ::= line_element+ end_of_line?;\n\nline_element ::= element | barline | nth_repeat | space_or_tab;\n\n\nelement ::= note_element | tuplet;\n\ntuplet ::= tuplet_prefix note_element+;\n\nnote_element ::= chord | pitch;\n\nchord ::= \"[\" pitch+ \"]\";\n\nlength_modifier ::= numerator | denominator | numerator denominator;\nnumerator::= digit+; \ndenominator::= \"/\" digit*;\n\nrest ::= \"z\" | \"Z\";\n\npitch ::= (note | (accidental note) | rest) length_modifier?;\n\naccidental ::= (\"^\" | \"^^\" | \"_\" | \"__\" | \"=\");\n\nnote ::= basenote | (basenote octave);\n\noctave ::= (\"'\" | \",\")+;\n\nbasenote ::= \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"A\" | \"B\"\n        | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"a\" | \"b\";\n\ndigit ::= [0-9];\n\ntuplet_prefix::= \"(2\" | \"(3\" | \"(4\";\n\nbarline ::= \"|\" | \"||\" | \"[|\" | \"|]\" | \":|\" | \"|:\";\nnth_repeat ::= \"[1\" | \"[2\";\nend_of_line ::= \"\\n\" | \"\\r\" \"\\n\"?;\nspace_or_tab ::= \" \" | \"\\t\";",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282910,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Chord.java",
    "data": "package karaoke.sound;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * An immutable, thread safe data type representing a Chord, or one or more notes played simultaneously. \n *\n */\npublic class Chord implements Music{\n\n    private final double duration;\n    private final Music[] notes;\n    \n    /*\n     * AF(notes, duration) = a musical Chord consisting of one or more notes played simultaneously.  \n     * notes consists of the list of musical notes that should all be played simultaneously\n     * duration represents the duration of the Chord, determined by the first note in notes\n     * \n     * Rep Invariant:\n     *      notes cannot contain any rests or tuplets\n     *      notes consists of at least one notes \n     *      \n     * Rep Exposure:\n     *      notes and duration are private, final\n     *      defensive copying of input param notes when construction a Chord and when returning notes to client\n     *      duration is a primitive\n     *      \n     * Thread Safety:\n     *      immutability: Chord is an immutable class and relies on thread safety of Note class. \n     */\n    \n    /**\n     * Constructs a Chord object from a list of sequence of Notes\n     * @param notes The sequence of Note ADTs, must be of length >0 and non Null\n     */\n    public Chord(Music[] notes){\n        assert notes.length > 0;\n        assert notes[0] != null;\n        duration = notes[0].duration();\n        this.notes = Arrays.copyOf(notes, notes.length);\n        checkRep();\n    }\n    \n\n    // assert the rep invariant of this class\n    private void checkRep() {\n        assert this.duration >0;\n        for(int i = 0; i < this.notes.length; i++ ) {\n            assert this.notes[i].numNotes() == 1;// must be notes\n        }\n        for (int i = 0; i < notes.length; i++) {\n            assert notes[i] != null;\n        }\n    }\n\n    @Override\n    public double duration() {\n        return duration;\n    }\n\n    @Override\n    public Music transpose(int semitonesUp) {\n        Music[] constructorArgument = new Music[notes.length];\n        for(int i=0; i<notes.length; i++) {\n            constructorArgument[i] = notes[i].transpose(semitonesUp);\n        }\n        return new Chord(constructorArgument);\n    }\n    \n    /**\n     * @return the notes that make up this chord in order\n     */\n    public Music[] getNotes() {\n        return Arrays.copyOf(notes, notes.length);\n        \n    }\n    \n    @Override\n    public Music changeDuration(double duration) {\n        assert duration >0;\n        Music[] newNotes = this.notes.clone();\n        newNotes[0] = newNotes[0].changeDuration(duration);\n        return new Chord(newNotes);\n    }\n    \n    @Override\n    public int numNotes() {\n        return this.notes.length;\n    }\n\n    @Override\n    public List<Double> addToMidiPlayer(double startBeat) {\n        List<Double> midiData = new ArrayList<>();\n        for(Music note : notes) {\n            midiData.addAll(note.addToMidiPlayer(startBeat));\n        }\n        return midiData;\n    }\n\n\n\n    @Override\n    public List<Double> addToMidiPlayer(double startBeat, int tupletSpec) {\n        List<Double> midiData = new ArrayList<>();\n        for(Music note : notes) {\n            midiData.addAll(note.addToMidiPlayer(startBeat, tupletSpec));\n        }\n        return midiData;\n    }\n\n    \n    @Override\n    public boolean isRest() {\n        return false;\n    }\n\n    @Override\n    public Music modifyKey(MusicKeys key) {\n        Music[] newNotes = new Music[this.notes.length];\n        for (int i = 0; i < this.notes.length; i++) {\n            newNotes[i] = this.notes[i].modifyKey(key);\n        }\n        return new Chord(newNotes);\n    }\n\n\n    @Override\n    public String toString() {\n        String builder = \"[\";\n        for(Music note: this.notes) {\n            builder += note.toString() +\" \";\n        }\n        return  builder.trim() + \"](\" + Music.convertDecimalToFraction(this.duration) + \")\";\n     }\n}\n\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282911,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Instrument.java",
    "data": "package karaoke.sound;\n\n/**\n * Instrument represents a musical instrument.\n * \n * These instruments are the 128 standard General MIDI Level 1 instruments.\n * See: http://www.midi.org/about-midi/gm/gm1sound.shtml\n */\npublic enum Instrument {\n    // Order is important in this enumeration because an instrument's\n    // position must correspond to its MIDI program number.\n\n    PIANO,\n    BRIGHT_PIANO,\n    ELECTRIC_GRAND,\n    HONKY_TONK_PIANO,\n    ELECTRIC_PIANO_1,\n    ELECTRIC_PIANO_2,\n    HARPSICHORD,\n    CLAVINET,\n\n    CELESTA,\n    GLOCKENSPIEL,\n    MUSIC_BOX,\n    VIBRAPHONE,\n    MARIMBA,\n    XYLOPHONE,\n    TUBULAR_BELL,\n    DULCIMER,\n\n    HAMMOND_ORGAN,\n    PERC_ORGAN,\n    ROCK_ORGAN,\n    CHURCH_ORGAN,\n    REED_ORGAN,\n    ACCORDION,\n    HARMONICA,\n    TANGO_ACCORDION,\n\n    NYLON_STR_GUITAR,\n    STEEL_STRING_GUITAR,\n    JAZZ_ELECTRIC_GTR,\n    CLEAN_GUITAR,\n    MUTED_GUITAR,\n    OVERDRIVE_GUITAR,\n    DISTORTION_GUITAR,\n    GUITAR_HARMONICS,\n\n    ACOUSTIC_BASS,\n    FINGERED_BASS,\n    PICKED_BASS,\n    FRETLESS_BASS,\n    SLAP_BASS_1,\n    SLAP_BASS_2,\n    SYN_BASS_1,\n    SYN_BASS_2,\n\n    VIOLIN,\n    VIOLA,\n    CELLO,\n    CONTRABASS,\n    TREMOLO_STRINGS,\n    PIZZICATO_STRINGS,\n    ORCHESTRAL_HARP,\n    TIMPANI,\n\n    ENSEMBLE_STRINGS,\n    SLOW_STRINGS,\n    SYNTH_STRINGS_1,\n    SYNTH_STRINGS_2,\n    CHOIR_AAHS,\n    VOICE_OOHS,\n    SYN_CHOIR,\n    ORCHESTRA_HIT,\n\n    TRUMPET,\n    TROMBONE,\n    TUBA,\n    MUTED_TRUMPET,\n    FRENCH_HORN,\n    BRASS_ENSEMBLE,\n    SYN_BRASS_1,\n    SYN_BRASS_2,\n\n    SOPRANO_SAX,\n    ALTO_SAX,\n    TENOR_SAX,\n    BARITONE_SAX,\n    OBOE,\n    ENGLISH_HORN,\n    BASSOON,\n    CLARINET,\n\n    PICCOLO,\n    FLUTE,\n    RECORDER,\n    PAN_FLUTE,\n    BOTTLE_BLOW,\n    SHAKUHACHI,\n    WHISTLE,\n    OCARINA,\n\n    SYN_SQUARE_WAVE,\n    SYN_SAW_WAVE,\n    SYN_CALLIOPE,\n    SYN_CHIFF,\n    SYN_CHARANG,\n    SYN_VOICE,\n    SYN_FIFTHS_SAW,\n    SYN_BRASS_AND_LEAD,\n\n    FANTASIA,\n    WARM_PAD,\n    POLYSYNTH,\n    SPACE_VOX,\n    BOWED_GLASS,\n    METAL_PAD,\n    HALO_PAD,\n    SWEEP_PAD,\n\n    ICE_RAIN,\n    SOUNDTRACK,\n    CRYSTAL,\n    ATMOSPHERE,\n    BRIGHTNESS,\n    GOBLINS,\n    ECHO_DROPS,\n    SCI_FI,\n\n    SITAR,\n    BANJO,\n    SHAMISEN,\n    KOTO,\n    KALIMBA,\n    BAG_PIPE,\n    FIDDLE,\n    SHANAI,\n\n    TINKLE_BELL,\n    AGOGO,\n    STEEL_DRUMS,\n    WOODBLOCK,\n    TAIKO_DRUM,\n    MELODIC_TOM,\n    SYN_DRUM,\n    REVERSE_CYMBAL,\n\n    GUITAR_FRET_NOISE,\n    BREATH_NOISE,\n    SEASHORE,\n    BIRD,\n    TELEPHONE,\n    HELICOPTER,\n    APPLAUSE,\n    GUNSHOT,\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282912,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/LyricLine.java",
    "data": "package karaoke.sound;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A mutable datatype to represent a syllable of lyrics with given duration\n * \n */\npublic class LyricLine {\n    private final List<String> syllables;\n    private final List<Integer> noteLengths;\n    private int index;\n    private final int totalNotes;\n    private final int notesPerBar;\n    private WordMod lastWordMod;\n    private SyllableMod lastSyllableMod;\n    private final List<Integer> wordIndex; //indices at which syllables become words, make spaces with \n    private final int currentLength;\n\n    public enum WordMod {\n        TILDE, NONE\n    }\n\n    public enum SyllableMod {\n        HYPHEN, UNDERSCORE, CONCAT, NONE\n    }\n\n    /*\n     * AF(syllables, noteLengths, index, totalNotes, notesPerBar, lastWordMod, lastSyllableMod, wordIndex, currentLength) \n     * = The lyrics to a line of music such that the lyrics contain the syllables held by syllables with each syllable, syllable[i]\n     * held for noteLengths[i] notes. The line of lyrics has a length of currentLength and covers totalNotes number of notes where\n     * there are notesPerBar number of those notes in each of the bars of music. For further operations wordIndex[i] is the index of\n     * the last syllable that completes a word and lastWordMod and lastSyllableMod record the last operation used on parsing to a LyricLine\n     * object.\n     * \n     * Syllables[i] determines the lyrics of the line of music, noteLengths[i]\n     * determines how many notes each syllable is held for\n     * \n     * Rep Invariant: \n     * this.syllables.size() == this.noteLengths.size(); \n     * this.index >= 0;\n     * \n     * Rep Exposure:\n     *      All fields are private. Most fields are final except for immutable fields that are only\n     *      altered by setter methods. No mutable parameters or return types are used without a\n     *      defensive copy\n     * \n     * Thread Safety:\n     *      This class is never used in multiple threads.\n     */\n\n    /**\n     * Constructs a LyricLine object\n     * @param syllables The syllables in the line of lyrics\n     * @param noteLengths The number of notes that each corresponding lyric lasts for\n     * @param index The index of the syllable that should be bold\n     * @param totalNotes The total number of musical notes in the corresponding line\n     * @param notesPerBar The number of notes per par in the corresponding line of music \n     * @param lastWordMod The last modification (tilde or none) to this LyricLine object\n     * @param lastSyllableMod The last modification (hyphen, underscore, concatenation, or none) to this LyricLine object \n     * @param wordIndex The indices of the syllables that complete words\n     * @param currentLength The current length of this line of lyrics\n     */\n    public LyricLine(List<String> syllables, List<Integer> noteLengths, int index, int totalNotes, int notesPerBar,\n            WordMod lastWordMod, SyllableMod lastSyllableMod, List<Integer> wordIndex, int currentLength) {\n        this.syllables = new ArrayList<>(syllables);\n        this.noteLengths = new ArrayList<>(noteLengths);\n        this.index = index;\n        this.totalNotes = totalNotes;\n        this.notesPerBar = notesPerBar;\n        this.lastWordMod = lastWordMod;\n        this.lastSyllableMod = lastSyllableMod;\n        this.wordIndex = wordIndex;\n        this.currentLength = currentLength;\n    }\n\n    /**\n     * Constructs a LyricLine object from a duration and string syllable value\n     * @param totalNotes The total number of notes in the line of lyrics\n     * @param npb The number of notes per bar in the corresponding line of music\n     */\n    public LyricLine(int totalNotes, int npb) {\n        this.currentLength = 0;\n        this.totalNotes = totalNotes;\n        this.notesPerBar = npb;\n        this.noteLengths = new ArrayList<>();\n        this.syllables = new ArrayList<>();\n        this.wordIndex = new ArrayList<>();\n        this.lastSyllableMod = SyllableMod.NONE;\n        this.lastWordMod = WordMod.NONE;\n        this.index = 0;\n        this.checkRep();\n    }\n\n    private void checkRep() {\n        assert this.syllables.size() == this.noteLengths.size();\n        if(this.syllables.size() != 0)\n            assert this.index < this.getCurrentNumNotes();\n        else\n            assert this.index == 0: \"empty lyric lines must have an index of 0\";\n            \n\n    }\n\n    /**\n     * @return the number of effective syllables in this LyricLine (ie the numebr of\n     *         concatenated syllabls)\n     */\n    public int getNumSyllables() {\n        return this.syllables.size();\n    }\n\n    /**\n     * @return the number of notes that this lyricLine currently lasts\n     */\n    public int getCurrentNumNotes() {\n        return this.noteLengths.stream().reduce(0, Integer::sum);\n    }\n\n    /**\n     * @return the number of effective words in the LyricLine (concatenated words\n     *         count as one)\n     */\n    public int getNumWords() {\n        return this.wordIndex.size();\n    }\n\n    /**\n     * Modifier method. Adjust the syllables in LyricLine based on the last actions\n     * tkaen by the parser.\n     */\n    public void endWord() {\n        if (lastWordMod == WordMod.TILDE) { // is this necessary,\n            String lastWord = \"\";\n            int k = this.wordIndex.size() - 1;\n            for (int i = this.wordIndex.get(k) + 1; i < this.syllables.size(); i++) {\n                int lastWordIndex = this.wordIndex.get(k) + 1;\n                lastWord += this.syllables.remove(lastWordIndex) + \" \"; // get last word\n                this.noteLengths.remove(i); // remove corresponding notelength\n                i--;\n            }\n            this.wordIndex.remove(k);\n            this.addToLastSyllable(lastWord.trim(), \" \");\n        }\n        this.wordIndex.add(this.syllables.size() - 1);\n        this.lastWordMod = WordMod.NONE;\n        this.checkRep();\n    }\n\n    /**\n     * parser helper method. Indicates hyphen symbol if the last symbol added was a\n     * hyphen, add another note\n     */\n    public void addHyphen() { // add space if necessary\n        if (this.lastSyllableMod == SyllableMod.HYPHEN) {\n            this.syllables.add(\".\");\n            this.noteLengths.add(1);\n        }\n        this.lastSyllableMod = SyllableMod.HYPHEN;\n        this.checkRep();\n    }\n\n    /**\n     * parser helper method. Exptends the duration of the lasta syllable one note\n     */\n    public void addUnderscore() { // increment last notelength\n        int i = this.syllables.size() - 1;\n        int numNotes = this.noteLengths.get(i);\n        numNotes += 1;\n        this.noteLengths.remove(i);\n        this.noteLengths.add(numNotes);\n        this.lastSyllableMod = SyllableMod.UNDERSCORE;\n        this.checkRep();\n    }\n\n    /**\n     * parser helper method. Adds a \".\" to the olyrics to indicate a break Lasts one\n     * note.\n     */\n    public void addStar() { // add space\n        this.syllables.add(\".\");\n        this.noteLengths.add(1);\n        this.endWord();\n        this.checkRep();\n    }\n\n    /**\n     * helper method. Appends syllable to the last syllable in the list with the\n     * String seperator in between.\n     * \n     */\n    private void addToLastSyllable(String input, String seperator) { // append to last \"syllable\" divided by seperator\n        int i = this.syllables.size() - 1;\n        String tempString = this.syllables.get(i);\n        tempString += seperator + input;\n        this.syllables.remove(i);\n        this.syllables.add(tempString);\n        this.checkRep();\n    }\n\n    /**\n     * parser helper method. Adds a syllable to this lyric line.\n     * @param input The syllable to be added to the line of lyrics\n     */\n    public void addSyllable(String input) {\n        if (this.lastSyllableMod == SyllableMod.CONCAT) {\n            this.addToLastSyllable(input, \"-\");\n        } else {\n            this.syllables.add(input);\n            this.noteLengths.add(1);\n        }\n        this.lastSyllableMod = SyllableMod.NONE;\n        this.checkRep();\n    }\n\n    /**\n     * parser helper method. concatenates next word to the most recent syllable the\n     * concatenated word (A B) lasts one note\n     */\n    public void addTilde() {\n        this.lastWordMod = WordMod.TILDE;\n    }\n\n    /**\n     * parser helper method. Cocnatenates teh next syllabel to the most recent\n     * syllable seperated with a \"-\". the comound syllabel (A-B) lasts one note\n     */\n    public void addConcat() {\n        this.lastSyllableMod = SyllableMod.CONCAT;\n    }\n\n    /**\n     * @return Whether the lyric line should be delayed to the next bar line in the line of music\n     */\n    public boolean toBarLine() { // requires interfacing with staff\n        throw new AssertionError(\"not implemented\");\n    }\n\n    /**\n     * returns the client representation of this string with emphasis on the a\n     * syllable, as defined by an internal counter calling this method increments\n     * the counter ie for lyric string a-b: <b>a</b>b -> a<b>b</b>\n     * \n     * @return the string representation of the lyric line\n     */\n    public synchronized String printLyricLine() {\n\n        // this.noteLengths.stream().reduce((int d, int y) -> )\n        int durationCounter = 0;\n        String builder = \"\";\n        int boldSyllable = 0;\n\n        for (int i = 0; i < this.noteLengths.size(); i++) { // find current syllable to bold\n            durationCounter += this.noteLengths.get(i);\n            if(durationCounter > index){\n                boldSyllable = i; break;\n            }\n        }\n\n        for (int i = 0; i < this.syllables.size(); i++) {\n            if (i == boldSyllable)\n                builder += \"<b>\";\n            builder += this.syllables.get(i);\n            if (i == boldSyllable)\n                builder += \"</b>\";\n            if (this.wordIndex.contains(i))\n                builder += \" \";\n        }\n        if (this.syllables.size() != 0)\n            this.index = (this.index + 1) % this.getCurrentNumNotes();\n        return builder.trim();\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"\";\n        for (int i = 0; i < this.syllables.size(); i++) {\n            builder += this.syllables.get(i) + this.noteLengths.get(i) + \" \";\n\n        }\n\n        return builder.trim();\n    }\n\n    /**\n     * @return A copy of this\n     */\n    public LyricLine copy() {\n        return new LyricLine(this.syllables, this.noteLengths, this.index, this.totalNotes, this.notesPerBar,\n                this.lastWordMod, this.lastSyllableMod, this.wordIndex, this.currentLength);\n    }\n\n    /**\n     * @param that any object\n     * @return true if for LyricLine that, for some subset of features f in that,\n     *         there exists a corresponding features in this f' such that\n     *         f'.equals(f)\n     */\n    @Override\n    public boolean equals(Object that) {\n        return (that instanceof LyricLine && this.isSimilar((LyricLine) that));\n    }\n\n    // helper method that tests for field equality\n    private boolean isSimilar(LyricLine that) {\n        return this.wordIndex.equals(that.wordIndex) && this.syllables.equals(that.syllables)\n                && this.noteLengths.equals(that.noteLengths);\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime1 = 61;\n        final int prime2 = 73;\n        final int prime3 = 51;\n        final int prime4 = 47; \n        \n        int h = prime1;\n        h += this.syllables.hashCode() * prime2;\n        h += this.wordIndex.hashCode() * prime3;\n        h += this.noteLengths.hashCode() * prime4;\n        return h;\n    }\n\n    /**\n     * @return A list of for how many notes the ith syllable in the line of lyrics lasts for\n     */\n    public List<Integer> getNoteLengths() {\n        return new ArrayList<>(this.noteLengths);\n    }\n\n    /**\n     * Sets the index of which syllable in the line of lyrics should be bold\n     * @param index The index of the syllable to be bold\n     */\n    public void setIndex(int index) {\n        this.index = index;\n        this.checkRep();\n    }\n\n    /**\n     * Returns a copy of this with a different index of the syllable to be bold\n     * @param index The index of the syllable to be bold in the copy\n     * @return A LyricLine object which is identical to this except with a different index of the syllable to be bold\n     */\n    public LyricLine getCopyWithIndex(int index) {\n        LyricLine output = this.copy();\n        output.setIndex(index);\n        return output;\n    }\n\n    /**\n     * Adjusts the length of this lyric line to the number of notes in its corresponding line of music\n     */\n    public void adjustLength() {\n        this.adjustLength(this.totalNotes);\n    }\n\n    /**\n     * Adjusts the number of syllables in the line of lyrics to match the number of notes in\n     * the line of music by removing syllables if the lyric line is too long and adding rests if\n     * the line is too short\n     * @param numNotes The number of notes to which this lyric line should be adjusted\n     */\n    public void adjustLength(int numNotes) {\n        if(numNotes == 0) // this logic is to facilitate testing,\n            //if the staff object passes a 0 length to adjust line, it will cause errors when it tries to \n            //set the index to something greater\n            return;\n        // reduce on sum of currentNumNotes\n        int currentNumNotes = this.getCurrentNumNotes();\n        // fill extra notes with stars\n        if (currentNumNotes < numNotes) {\n            for (int i = 0; i < (numNotes - currentNumNotes); i++) {\n                this.addStar();\n            }\n\n        } else if (currentNumNotes > numNotes) {\n            for (int i = 0; i < (currentNumNotes - numNotes); i++) {\n                int lastSyllableIndex = this.syllables.size() - 1, lastNoteIndex = this.noteLengths.size() - 1;\n                int lastNoteLength = this.noteLengths.get(lastNoteIndex);\n\n                if (lastNoteLength == 1) { // if only one beat, adjust class fields as necessary\n                    this.noteLengths.remove(lastNoteIndex);\n                    this.syllables.remove(lastSyllableIndex);\n                    this.index--;//decrement index\n                    if (!this.wordIndex.isEmpty()\n                            && this.wordIndex.get(this.wordIndex.size() - 1) == lastSyllableIndex)\n                        this.wordIndex.remove(this.wordIndex.size() -1); // remove a word\n                } else { // decrement the last notelength\n                    this.noteLengths.set(lastNoteIndex, --lastNoteLength);\n                }\n            }\n        }\n        // if(this.syllables.size()  - 1 > index) {\n        //     this.index = this.syllables.size() == 0? 0 : this.syllables.size()-1; //correct for empty initialized LyricLines\n        // }\n        this.checkRep();\n    }\n    //\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282913,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/MidiSequencePlayer.java",
    "data": "package karaoke.sound;\n\nimport java.math.BigInteger;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.function.Consumer;\n\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MetaMessage;\nimport javax.sound.midi.MidiChannel;\nimport javax.sound.midi.MidiEvent;\nimport javax.sound.midi.MidiMessage;\nimport javax.sound.midi.MidiSystem;\nimport javax.sound.midi.MidiUnavailableException;\nimport javax.sound.midi.Sequence;\nimport javax.sound.midi.Sequencer;\nimport javax.sound.midi.ShortMessage;\nimport javax.sound.midi.Synthesizer;\nimport javax.sound.midi.Track;\n\n/**\n * Schedules and plays a sequence of notes using the MIDI synthesizer.\n */\npublic class MidiSequencePlayer implements SequencePlayer {\n\n    /**\n     * Default tempo.\n     */\n    public static final int DEFAULT_BEATS_PER_MINUTE = 120;\n    /**\n     * Default MIDI ticks per beat.\n     */\n    public static final int DEFAULT_TICKS_PER_BEAT = 64;\n\n    // the volume\n    private static final int DEFAULT_VELOCITY = 100;\n\n    // the generic marker meta message type\n    private static final int META_MARKER = 6;\n    // the \"end_of_track\" meta message type\n    private static final int META_END_OF_TRACK = 47;\n\n    // MIDI note number representing middle C\n    private static final int MIDI_NOTE_MIDDLE_C = 60;\n    \n    private final Synthesizer synthesizer;\n\n    // active MIDI channels, assigned to instruments\n    private final Map<Instrument, Integer> channelForInstrument = new HashMap<>();\n\n    // next available channel number (not assigned to an instrument yet)\n    private int nextChannel = 0;\n\n    private final Sequencer sequencer;\n    private final Track track;\n    private int beatsPerMinute; // only modified when the midiplayer isn't playing,\n    private final int ticksPerBeat;\n\n    // event callback functions\n    private final SortedMap<Integer, Consumer<Double>> callbacks = new TreeMap<>();\n    private final MetaMessage keepalive = new MetaMessage(META_MARKER, new byte[] { 0 }, 1);\n\n    /*\n     * Rep invariant:\n     *   sequencer and track are non-null,\n     *   beatsPerMinute and ticksPerBeat are positive,\n     *   channels and callbacks are non-null,\n     *   channels does not contain value nextChannel\n     */\n\n    private void checkRep() {\n        assert sequencer != null : \"sequencer should be non-null\";\n        assert track != null : \"track should be non-null\";\n        assert beatsPerMinute >= 0 : \"should be positive number of beats per minute\";\n        assert ticksPerBeat >= 0 : \"should be positive number of ticks per beat\";\n        assert callbacks != null : \"callbacks should be non-null\";\n        assert callbacks.keySet().stream().allMatch(n -> n >= 1) : \"callback numbers should be positive\";\n        assert ! channelForInstrument.values().contains(nextChannel) : \"nextChannel should not be assigned\";\n    }\n\n    /**\n     * Make a new MIDI sequence player with the default parameters.\n     * @throws MidiUnavailableException if MIDI device unavailable\n     * @throws InvalidMidiDataException if MIDI play fails\n     */\n    public MidiSequencePlayer() throws MidiUnavailableException, InvalidMidiDataException {\n        this(DEFAULT_BEATS_PER_MINUTE, DEFAULT_TICKS_PER_BEAT);\n    }\n\n    /**\n     * Make a new MIDI sequence player.\n     * @param beatsPerMinute the number of beats per minute\n     * @param ticksPerBeat the number of ticks per beat; every note plays for an integer number of ticks\n     * @throws MidiUnavailableException if MIDI device unavailable\n     * @throws InvalidMidiDataException if MIDI play fails\n     */\n    public MidiSequencePlayer(int beatsPerMinute, int ticksPerBeat)\n            throws MidiUnavailableException, InvalidMidiDataException {\n        synthesizer = MidiSystem.getSynthesizer();\n        synthesizer.open();\n        synthesizer.loadAllInstruments(synthesizer.getDefaultSoundbank());\n\n        this.sequencer = MidiSystem.getSequencer();\n\n        // create a sequence object with with tempo-based timing, where\n        // the resolution of the time step is based on ticks per quarter note\n        Sequence sequence = new Sequence(Sequence.PPQ, ticksPerBeat);\n        this.beatsPerMinute = beatsPerMinute;\n        this.ticksPerBeat = ticksPerBeat;\n\n        // create an empty track; notes will be added to this track\n        this.track = sequence.createTrack();\n\n        sequencer.setSequence(sequence);\n\n        checkRep();\n    }\n\n    @Override\n    public void addNote(Instrument instr, Pitch pitch, double startBeat, double numBeats) {\n        int channel = getChannel(instr);\n        int note = getMidiNote(pitch);\n        try {\n            // schedule two events in the track, one for starting a note and\n            // the other for ending the note.\n            addMidiNoteEvent(ShortMessage.NOTE_ON, channel, note, (int) (startBeat * ticksPerBeat));\n            addMidiNoteEvent(ShortMessage.NOTE_OFF, channel, note, (int) ((startBeat + numBeats) * ticksPerBeat));\n        } catch (InvalidMidiDataException imde) {\n            String msg = MessageFormat.format(\"Cannot add note with the pitch {0} at beat {1} \" +\n                                              \"for duration {2}\", note, startBeat, numBeats);\n            throw new RuntimeException(msg, imde);\n        }\n    }\n\n    /**\n     * Schedule a MIDI note event.\n     * @param eventType valid MidiMessage type in ShortMessage\n     * @param channel valid channel\n     * @param note valid pitch value\n     * @param tick tick >= 0\n     * @throws InvalidMidiDataException\n     */\n    private void addMidiNoteEvent(int eventType, int channel, int note, int tick) throws InvalidMidiDataException {\n        ShortMessage msg = new ShortMessage(eventType, channel, note, DEFAULT_VELOCITY);\n        this.track.add(new MidiEvent(msg, tick));\n    }\n\n    @Override\n    public void addEvent(double atBeat, Consumer<Double> callback) {\n        int callbackNumber = saveCallback(callback);\n        try {\n            addMidiMetaEvent(callbackNumber, (int) (atBeat * ticksPerBeat));\n        } catch (InvalidMidiDataException imde) {\n            throw new RuntimeException(\"Cannot add event at beat \" + atBeat, imde);\n        }\n    }\n\n    private int saveCallback(Consumer<Double> callback) {\n        int key = callbacks.isEmpty() ? 1 : callbacks.lastKey() + 1;\n        callbacks.put(key, callback);\n        checkRep();\n        return key;\n    }\n\n    /**\n     * Schedule a MIDI meta event.\n     * @param callback active callback number\n     * @param tick tick >= 0\n     * @throws InvalidMidiDataException\n     */\n    private void addMidiMetaEvent(int callback, int tick) throws InvalidMidiDataException {\n        byte[] bytes = BigInteger.valueOf(callback).toByteArray();\n        MetaMessage msg = new MetaMessage(META_MARKER, bytes, bytes.length);\n        this.track.add(new MidiEvent(msg, tick));\n        this.track.add(new MidiEvent(keepalive, tick+1));\n    }\n\n    @Override\n    public void play() {\n        try {\n            sequencer.open();\n        } catch (MidiUnavailableException mue) {\n            throw new RuntimeException(\"Unable to open MIDI sequencer\", mue);\n        }\n        sequencer.setTempoInBPM(this.beatsPerMinute);\n\n        sequencer.addMetaEventListener(meta -> {\n            if (meta.getType() == META_MARKER) {\n                // trigger event callback\n                int callbackNumber = new BigInteger(meta.getData()).intValue();\n                if (callbackNumber > 0) {\n                    callbacks.remove(callbackNumber).accept(sequencer.getTickPosition() / (double)ticksPerBeat);\n                }\n            } else if (meta.getType() == META_END_OF_TRACK) {\n                // allow the sequencer to finish\n                try { Thread.sleep(Duration.ofSeconds(1).toMillis()); } catch (InterruptedException ie) { }\n                // stop & close the sequencer\n                sequencer.stop();\n                sequencer.close();\n            }\n        });\n\n        // start playing!\n        sequencer.start();\n    }\n\n    /**\n     * Check if the MIDI is playing\n     * @return true if playing\n     */\n    public boolean isPlaying() {\n        return this.sequencer.isOpen();\n    }\n\n    /**\n     * setter method for beats per minute\n     * @param tempo  in beats per minute, must be >= 0\n     */\n    public void setBeatsPerMinute(int tempo) {\n        this.beatsPerMinute = tempo;\n        this.checkRep();\n    }\n\n    /**\n     * Get a MIDI channel for the given instrument, allocating one if necessary.\n     * @param instr instrument\n     * @return channel for the instrument\n     */\n    private int getChannel(Instrument instr) {\n        // check whether this instrument already has a channel\n        if (channelForInstrument.containsKey(instr)) {\n            return channelForInstrument.get(instr);\n        }\n        \n        int channel = allocateChannel();\n        patchInstrumentIntoChannel(channel, instr);\n        channelForInstrument.put(instr, channel);\n        checkRep();\n        return channel;\n    }\n\n    /**\n     * @return next available channel number\n     */\n    private int allocateChannel() {\n        MidiChannel[] channels = synthesizer.getChannels();\n        if (nextChannel >= channels.length) {\n            throw new RuntimeException(\"Tried to use too many instruments: limited to \" + channels.length);\n        }\n        return nextChannel++;\n    }\n\n    private void patchInstrumentIntoChannel(int channel, Instrument instr) {\n        try {\n            addMidiNoteEvent(ShortMessage.PROGRAM_CHANGE, channel, instr.ordinal(), 0);\n        } catch (InvalidMidiDataException imde) {\n            throw new RuntimeException(\"Cannot set instrument\", imde);\n        }\n    }\n\n    /**\n     * @return the MIDI note number for a pitch, defined as the number of\n     *         semitones above C 5 octaves below middle C; for example,\n     *         middle C is note 60\n     */\n    private static int getMidiNote(Pitch pitch) {\n        return MIDI_NOTE_MIDDLE_C + pitch.difference(Pitch.MIDDLE_C);\n    }\n\n    /**\n     * @return a string that displays the entire track information as a\n     *         sequence of MIDI events, where each event is either turning on\n     *         or off a note at a certain tick, a marker event, or the end of\n     *         the track\n     */\n    @Override\n    public String toString() {\n        String trackInfo = \"\";\n\n        for (int i = 0; i < track.size(); i++) {\n            final MidiEvent e = track.get(i);\n            final MidiMessage msg = e.getMessage();\n            final String msgString;\n\n            if (msg instanceof ShortMessage) {\n                final ShortMessage smg = (ShortMessage) msg;\n                final int command = smg.getCommand();\n                final String commandName;\n\n                if (command == ShortMessage.NOTE_OFF) {\n                    commandName = \"NOTE_OFF\";\n                } else if (command == ShortMessage.NOTE_ON) {\n                    commandName = \"NOTE_ON \";\n                } else {\n                    commandName = \"Unknown command \" + command;\n                }\n\n                msgString = \"Event: \" + commandName + \" Pitch: \" + smg.getData1() + \" \";\n\n            } else if (msg instanceof MetaMessage) {\n                final MetaMessage mmg = (MetaMessage) msg;\n                final int type = mmg.getType();\n                final String typeName;\n\n                if (type == META_MARKER) {\n                    typeName = \"MARKER\";\n                } else if (type == META_END_OF_TRACK) {\n                    typeName = \"END_OF_TRACK\";\n                } else {\n                    typeName = \"Unknown type \" + type;\n                }\n\n                msgString = \"Meta event: \" + typeName;\n\n            } else {\n                msgString = \"Unknown event\";\n            }\n\n            trackInfo += msgString + \" Tick: \" + e.getTick() + \"\\n\";\n        }\n\n        return trackInfo;\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282914,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Music.java",
    "data": "package karaoke.sound;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.parser.AbcParser;\n\n/**\n * An immutable data type that represents a piece of music. A single Music object contains all\n * features specified in the Karaoke project specification.\n */\npublic interface Music {\n\n    /*\n     * Datatype definition: Music = Note(p:Pitch,duration:Double) \n     *                              + Rest(duration:Double) \n     *                              + Tuplets(values:Music[]) \n     *                              + Chord(m:Music[])\n     */\n\n    public static int NO_TUPLE = 1;\n    public static HashMap<String, String> KEY_SIGNATURES = new HashMap<>();\n\n    public static double NO_TEMPO = -1;\n    public static double NO_DEFAULT_NOTE_LENGTH = -1;\n\n    public double tempo = NO_TEMPO;\n    public double defaultNoteLength = NO_DEFAULT_NOTE_LENGTH;\n    public static final char[] BASENOTES = { 'B', 'E', 'A', 'D', 'G', 'C', 'F' };\n\n    public static enum MusicKeys {\n        C, CS, D, Eb, E, F, FS, G, Ab, A, Bb, B\n    }\n\n    /**\n     * static helper method that converts a string key to the corresponding key enum.\n     * If a key isn't recognized as valid, default to the key of C\n     * \n     * @param key in String representation (ie #s, bs, and ms for sharp flat and\n     *            minor respectively)\n     * @return proper MusicKeys enum\n     */\n    public static MusicKeys keyToEnum(String key) {\n        if (!Piece.VALIDKEYS.contains(key)) {\n            return MusicKeys.C;\n        }\n        final int[] scale = { 9, // A\n                11, // B\n                0, // C\n                2, // D\n                4, // E\n                5, // F\n                7, // G\n        };\n        int keyNumber = scale[Character.toUpperCase(key.charAt(0)) - 'A'];\n        if (key.contains(\"m\")) {\n            keyNumber -= 3;\n        }\n        if (key.contains(\"#\")) {\n            keyNumber += 1;\n        } else if (key.contains(\"b\")) {\n            keyNumber -= 1;\n        }\n        MusicKeys[] keys = MusicKeys.values();\n\n        while (keyNumber < 0) {\n            keyNumber += keys.length;\n        }\n\n        return keys[keyNumber % keys.length];\n    }\n\n    /**\n     * Static helper method that converts Music Keys into the signed\n     *      number of accidentals in that key. \n     * \n     * @param key to convert\n     * @return signed number of accidentals, >0 if sharp, otherwise flat\n     * @throws AssertionError if the key isn't recognized\n     */\n    public static int numAccidentals(MusicKeys key) {\n        switch (key) {\n        case C:\n            return 0;\n        case CS:\n            return 7;\n        case D:\n            return 2;\n        case Eb:\n            return -3;\n        case E:\n            return 4;\n        case F:\n            return -1;\n        case FS:\n            return 6;\n        case G:\n            return 1;\n        case Ab:\n            return -4;\n        case A:\n            return 3;\n        case Bb:\n            return -2;\n        case B:\n            return 5;\n        default:\n            throw new AssertionError();\n        }\n    }\n\n    /**\n     * Static helper that converts the signed number of accidentals in a key to the\n     * note values of a key signiture\n     * \n     * @param numAccidentals signed number of accidentals, absolute value must be <8\n     * @return note values in key signiture\n     */\n    public static char[] baseNotesToModify(int numAccidentals) {\n        assert Math.abs(numAccidentals) < 8;\n        boolean isSharped = numAccidentals < 0;\n        numAccidentals = Math.abs(numAccidentals);\n        char[] output = new char[numAccidentals];\n        if (!isSharped) {\n            int j = 0;\n            for (int i = Music.BASENOTES.length - 1; i > Music.BASENOTES.length - numAccidentals - 1; i--) {\n                output[j++] = Music.BASENOTES[i];\n            }\n        } else {\n            for (int i = 0; i < numAccidentals; i++) {\n                output[i] = Music.BASENOTES[i];\n            }\n        }\n\n        return output;\n    }\n\n    /**\n     * Parse a single music string expression (a string representable by one music ADT)\n     *      in the ABC subset format defined in the project specification\n     *      A tuplet must be followed directly by the number of notes procided in the spec\n     * \n     * @param input expression to be parsed\n     * @return Music object created by parsed expression\n     * @throws UnableToParseException if the expression is syntactically in valid.\n     */\n    public static Music parseMusicString(String input) throws UnableToParseException {\n        return AbcParser.parse(input);\n    }\n\n\n    /**\n     * parses an ABC_Line as specified in the grammar subset defined in the project spec,\n     * \n     * @param input ABC line expression\n     * @return corresponding list of music objects\n     */\n    public static Music[] parseLine(String input) throws UnableToParseException {\n        List<String> musicList = AbcParser.parseLine(input);\n        musicList = musicList.stream().filter(x -> !(x.equals(\"|\") || x.equals(\"|:\") || x.equals(\"[|\") || x.equals(\"|]\")\n                || x.equals(\"||\") || x.equals(\":|\") || x.equals(\"1]\") || x.equals(\"2]\"))).collect(Collectors.toList()); // check for illegal music symbols\n\n        Music[] output = new Music[musicList.size()];\n\n        for (int i = 0; i < musicList.size(); i++) {\n            output[i] = parseMusicString(musicList.get(i));\n        }\n        return output;\n    }\n\n    /**\n     * Converts a decimal to string fraction representation found from\n     * https://stackoverflow.com/questions/31585931/how-to-convert-decimal-to-fractions\n     * \n     * @param x double\n     * @return a string representaion of each double\n     */\n    public static String convertDecimalToFraction(double x) {\n        if (x < 0) {\n            return \"-\" + convertDecimalToFraction(-x);\n        }\n        double tolerance = 1.0E-6;\n        double h1 = 1;\n        double h2 = 0;\n        double k1 = 0;\n        double k2 = 1;\n        double b = x;\n        do {\n            double a = Math.floor(b);\n            double aux = h1;\n            h1 = a * h1 + h2;\n            h2 = aux;\n            aux = k1;\n            k1 = a * k1 + k2;\n            k2 = aux;\n            b = 1 / (b - a);\n        } while (Math.abs(x - h1 / k1) > x * tolerance);\n        if (k1 != 1)\n            return (int) h1 + \"/\" + (int) k1;\n        else\n            return \"\" + (int) h1;\n    }\n\n    /**\n     * convert a valid tuplet spec into the multiplier for all internal Music\n     * durations\n     * \n     * @param tupletSpec must be 2, 3, or 4\n     * @return multiplier\n     * @throws AssertionError for invalid tupletSpecs\n     */\n    public static double tupletSpecToFactor(int tupletSpec) {\n        double factor = 0;\n        if (tupletSpec == 2) {\n            factor = 3.0 / 2;\n        } else if (tupletSpec == 3) {\n            factor = 2.0 / 3;\n        } else if (tupletSpec == 4) {\n            factor = 3.0 / 4;\n        } else {\n            throw new AssertionError(\"invalid tuplet spec, must be 2 3 or 4\");\n        }\n        return factor;\n    }\n\n    /**\n     * @return total duration of this music in beats\n     */\n    public double duration();\n\n    /**\n     * Transpose all notes upward or downward in pitch.\n     * \n     * @param semitonesUp semitones by which to transpose\n     * @return for Music m, return m' such that for all notes n in m, the\n     *         corresponding note n' in m' has n'.pitch() ==\n     *         n.pitch().transpose(semitonesUp), and m' is otherwise identical to m.\n     */\n    public Music transpose(int semitonesUp);\n\n    /**\n     * set the duration of this piece of music\n     * \n     * @param duration return a new piece of Music, identical to the current one in\n     *                 types of notes but with duration scaled to result in the\n     *                 input duration\n     * @return Music object m' such that for all notes n in original piece, the\n     *         corresponding notes in m' have the same pitch but altered duration to\n     *         make the duration of m' equal the input duration.\n     */\n    public Music changeDuration(double duration);\n\n    /**\n     * @return the number of individual notes in this music\n     */\n    public int numNotes();\n\n    /**\n     * determine if a music represents a rest\n     * \n     * @return true if this music is a rest\n     */\n    public boolean isRest();\n\n    /**\n     * Create a new music that satisfies the given key signiture\n     * \n     * @param key signiture to satisfy\n     * @return Music Object adjusted for key signiture\n     */\n    public Music modifyKey(MusicKeys key);\n\n\n    /**\n     * Passes in the neccesary parameters and midiplayer object to add the sound of\n     * this music object to the midiplayer object. tuplet spec modifies interior\n     * note lengths appropriately\n     * \n     * @param midiPlayer        the midiplayer object that will play this notes\n     *                          sound. Is modified\n     * @param tempo             defined by containing piece\n     * @param defaultNoteLength defined by containing piece\n     * @param tupletSpec        modifies inner note lengths to the proper fraction\n     *                          of their original duration\n     * @return the next starting beat of the\n     */\n    public List<Double> addToMidiPlayer(double startBeat, int tupletSpec);\n\n    /**\n     * Passes in the neccesary parameters and midiplayer object to add the sound of\n     * this music object to the midiplayer object. interior note lengths aren't\n     * modified.\n     * \n     * @param midiPlayer        the midiplayer object that will play this notes\n     *                          sound. Is modified\n     * @param tempo             defined by containing piece\n     * @param defaultNoteLength defined by containing piece\n     * @return the next starting beat of the\n     */\n    public List<Double> addToMidiPlayer(double startBeat);\n\n\n    /**\n     * Returns the string representation of this music ADT\n     * including the duration of the msuci ADT, and the duration of\n     * all interior Music ADTs\n     */\n    public String toString();\n\n    /**\n     * @param that any object\n     * @return true if for Music that, all features f in that, there exists a\n     *         corresponding features in this f' such that f'.equals(f)\n     */\n    @Override\n    public boolean equals(Object that);\n\n    @Override\n    public int hashCode();\n\n\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282915,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Note.java",
    "data": "package karaoke.sound;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * An immutable, thread safe data type representing a musical note. \n */\npublic class Note implements Music{\n    private final double duration;\n    private final int pitchValue;\n    private final char baseNote;\n    private final boolean isNatural;\n    \n    // global variables \n    public static final int PITCH_MODIFIER_BASE = 12; \n    public static final int PITCH_MODIFIER_DOUBLE = 2;\n    public static final int HASHCODE_BASE = 19; \n    public static final int HASHCODE_DURATION_MULITIPLIER = 13; \n    public static final int HASHCODE_PITCH_MULITIPLIER = 51;\n    /*\n     * AF(duration, pitchValue, baseNote, isNatural) = a musical note with a distinct pitch and duration, \n     * where pitchValue determines the harmonic pitch of the note, \n     * baseNote represents the Note letter value in musical notation,\n     * duration represents the amount of time the note should be held, \n     * isNatural determines if the note should ignore key and hangover accidentals.\n     * \n     * Rep Invariant:\n     *      duration > 0\n     *      basenote is a valid basenote as defined in the Music interface\n     * \n     * Rep Exposure:\n     *      all fields are private, final and primitive\n     * \n     * Thread Safety:\n     *      immutability: Note class is immutable: all references to variables are immutable by the final modifier and \n     *                  all fields are primitive types and therefore immutable \n     */\n    \n    /**\n     * Constructs a Note object with pitch Basenote and given duration.\n     * @param pitch The letter value of the pitch of the note\n     * @param duration The string representation of the note's duration (e.g. 1/4 or /2)\n     */\n    public Note(char pitch, double duration) {\n        this.duration = duration;\n        this.baseNote = Character.toUpperCase(pitch);\n        this.pitchValue = calculatePitchValue(\"\", pitch, \"\");\n        this.isNatural = false;\n        checkRep();\n    }\n    \n    /**\n     * Constructs a Note object from a pitch value and duration\n     * @param pitchValue the value of the pitch of the note\n     * @param duration the duration of the note\n     * @param pitch the Character representing the letter value of the musical pitch of the note\n     * @param natural boolean that determines if the note should be held by key or hangover accidental \n     */\n    public Note(int pitchValue, double duration, char pitch, boolean natural) {\n        this.pitchValue = pitchValue;\n        this.duration = duration;\n        this.baseNote = pitch;\n        this.isNatural = natural;\n    }\n\n\n     /**\n     * Complex Note constructor (mainly used for testing)\n     * @param accidental The string representation (^ and _) of the accidentals (sharps, flats) of the note\n     * @param pitch The letter value of the pitch of the note\n     * @param octave The string representation (' and ,) of the note's octave\n     * @param duration The double representation of the note's duration (e.g. .25 or .125)\n     */\n    public Note(String accidental, char pitch, String octave, double duration) {\n        this.duration = duration;\n        this.baseNote = Character.toUpperCase(pitch);\n        this.pitchValue = calculatePitchValue(accidental, pitch, octave);\n        this.isNatural = accidental.equals(\"=\");\n        checkRep();\n    }\n    \n    /**\n     * Checks the rep invariant\n     */\n    private void checkRep() {\n        boolean validPitch = false;\n        for(char c : Music.BASENOTES) {\n            validPitch = c == this.baseNote || validPitch;\n        }\n        assert validPitch;\n        assert this.duration > 0;\n    }\n\n    /**\n     * Converts inputs to proper pitch value\n     * @param accidental\n     * @param pitch\n     * @param octave\n     */\n    private static int calculatePitchValue(String accidental, char pitch, String octave) {\n        final int[] scale = {\n                9,  // A\n                11, // B\n                0,  // C\n                2,  // D\n                4,  // E\n                5,  // F\n                7,  // G\n        };\n        int outputPitchValue = scale[Character.toUpperCase(pitch) - 'A'];\n        Map<String, Integer> pitchModifiers = new HashMap<>();\n \n        pitchModifiers.put(\"^^\", 2);\n        pitchModifiers.put(\"^\", 1);\n        pitchModifiers.put(\"\", 0);\n        pitchModifiers.put(\"=\", 0);\n        pitchModifiers.put(\"_\", -1);\n        pitchModifiers.put(\"__\", -PITCH_MODIFIER_DOUBLE);\n        \n        pitchModifiers.put(\"\\'\\'\", 2*PITCH_MODIFIER_BASE);\n        pitchModifiers.put(\"\\'\", PITCH_MODIFIER_BASE);\n        pitchModifiers.put(\",\", -PITCH_MODIFIER_BASE);\n        pitchModifiers.put(\",,\", -PITCH_MODIFIER_DOUBLE*PITCH_MODIFIER_BASE);\n        \n        outputPitchValue += pitchModifiers.get(accidental);\n        outputPitchValue += pitchModifiers.get(octave);\n        \n        if(Character.isLowerCase(pitch)) {\n            outputPitchValue += PITCH_MODIFIER_BASE;\n        }\n        \n        return outputPitchValue;\n    }\n\n    @Override\n    public int numNotes() {\n        return 1;\n    }\n\n    @Override\n    public double duration() {\n        return duration;\n    }\n\n    @Override\n    public Music transpose(int semitonesUp) {\n        return new Note(this.pitchValue+semitonesUp, duration, this.baseNote, this.isNatural);\n    }\n\n    @Override\n    public Music changeDuration(double d) {\n        assert d >=0;\n        return new Note(this.pitchValue, d, this.baseNote, this.isNatural);\n    }\n    \n    /**\n     * @return The a double representing the pitch of this note.\n     */\n    public double getPitchValue() {\n        return pitchValue;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return obj instanceof Note && \n                this.isSimmilar((Note) obj);\n    }\n\n    private boolean isSimmilar(Note obj) {\n        return this.duration == obj.duration \n                && this.pitchValue == obj.pitchValue;\n    }\n\n    @Override\n    public int hashCode() {\n        int h = HASHCODE_BASE;\n        h += this.duration*HASHCODE_DURATION_MULITIPLIER;\n        h += this.pitchValue*HASHCODE_PITCH_MULITIPLIER;\n        return h;\n    }\n\n    /**\n     * Construct a new note with a natural accidental, that will not be modified\n     * by prior accidentals or keys and played with key C. \n     * @return natural note played as if the key were in C regardless of modifiers\n     */\n    public Music setNatural() {\n        return new Note(this.pitchValue, this.duration, this.baseNote, true);\n    }\n\n    @Override\n    public boolean isRest() {\n        return false;\n    }\n\n    @Override\n    public List<Double> addToMidiPlayer(double startBeat) {\n        return new ArrayList<Double>(Arrays.asList(startBeat*1.0, this.pitchValue*1.0, this.duration*1.0));\n    }\n\n\n\n    @Override\n    public List<Double> addToMidiPlayer(double startBeat, int tupletSpec) {\n        double factor = Music.tupletSpecToFactor(tupletSpec);\n        return new ArrayList<Double>(Arrays.asList(startBeat*1.0, this.pitchValue*1.0, this.duration*factor));\n    }\n    \n    @Override\n    public String toString() {\n        return this.baseNote + Music.convertDecimalToFraction(this.duration);\n    }\n\n    @Override\n    public Music modifyKey(MusicKeys key) { // if the basenote is in the key, sharp or flat appropriately\n        int numAccidentals = Music.numAccidentals(key);\n        char[] baseNotes = Music.baseNotesToModify(numAccidentals);\n        for(char c : baseNotes) {\n            if(!this.isNatural && this.baseNote == c)\n                return numAccidentals > 0 ? this.transpose(1) : this.transpose(-1);\n        }\n        return this;\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282916,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Piece.java",
    "data": "package karaoke.sound;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n\n/**\n * An mutable data type that represents a work in the karaoke machine.\n * Every work corresponds to an abc grammar.\n */\npublic class Piece {\n    \n    private List<Staff> staffs;\n    private int karaokeIndex;\n    private String title;\n    private String composer;\n    private String key;\n    private String meter;\n    private double noteLength;\n    private int tempo; // number of beats per min \n    private boolean defaultNoteLength;\n    private boolean isValid;\n    private MidiSequencePlayer player;\n    private int numListeners;\n    private double tempoNoteLength;\n    public static final Set<String> VALIDKEYS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(\n        \"G\", \"D\",\"A\",\"E\",\"B\",\"F#\",\"Gb\", \"Db\", \"Ab\", \"Eb\", \"Bb\", \"F\",\n         \"C\", \"C#\", \"Cb\", \"Em\", \"Bm\", \"F#m\" ,\"C#m\", \"G#m\", \"D#m\",\n          \"A#m\",\"Dm\", \"Gm\", \"Cm\",\"Fm\", \"Bbm\", \"Ebm\", \"Abm\", \"Am\")));\n   public static final double BASE_FOR_NOTE_LENGTH = 8.0; \n   public static final double METER_THRESHOLD = 0.75;\n   public static final int HASHCODE_BASE = 51;\n   public static final int HASHCODE_TEMPO_MULTIPLIER = 37;\n   public static final int HASHCODE_METER_MULITPLIER = 11;\n   public static final int DEFAULT_BEATS_PER_MIN = 64; \n   public static final int THREAD_SLEEP_TIME = 3500; \n    /* Abstraction Function:\n     * AF(staffs,karaokeIndex,title,composer,key,meter,noteLength,tempo,isValid,defaultNoteLength,player,numListeners, tempoNoteLength) \n     * = a work of music in the karaoke machine such that:\n     * staffs contains a list of unique Staffs in the work of the music, where each staff corresponds to the music of a voice in the piece.  \n     * karaokeIndex represents the order in which this work of music will appear on the queue of music to be played. \n     * title is the title of the work. \n     * composer is the name of the composer. \n     * key is the key signature of the work.\n     * meter is the sum of the durations of all the notes in a bar.\n     * defaultNoteLength is the duration of a standard note in this work.\n     * tempo is the number of whole beats to play per minute. \n     * player is the means of playing the parsed music.\n     * isValid determines whether or not a piece can be listened to. Once a piece is valid, its musical content can no longer be modified\n     *      however, listeners can still be added and it can be played.\n     * defaultNoteLength is the length of any given note in the piece if its note length is not specified relative to this field\n     * numListeners indicates the number of people listening to this piece\n     * \n     * Rep invariant: \n     *      isValid == true iff a piece has been parsed and initialized by the PieceParser\n     *      karaokeIndex >= 0\n     *      title.isEmpty() == false\n     *      composer.isEmpty() == false\n     *      key is a valid major or minor key\n     *      meter > 0\n     *      defaultNoteLength >= 1/64\n     *      tempo > 0\n     *      if defaultNoteLength and meter < 0.75, then noteLength = 1/16 otherwise noteLength = 1/8. \n     *      \n     * Safety from Rep Exposure: \n     *      All getter methods return primitive values with no reference to the field. \n     *      All mutable fields are never returned, and are only passed as parameters to protected package classes without assignment\n     *      of its object reference or any of its fields in the body of the method\n     *      All fields are private, with exception of validKeys which is wrapped in an unmodifiable set and marked as final.\n     * \n     * Thread Safety Argument:\n     *      All public methods are synchronized. \n     *      Synchronized access to the underlying thread safe midisequence player class ensures\n     *          no race conditions\n     */\n\n    \n    /**\n     * Creates a new work of music with the given parameters. \n     * @param i karaoke index\n     * @param name title of the piece \n     * @param comp name of the composer\n     * @param k key which determines key signature. \n     * @param m meter, if m <=0 then use default meter 4/4\n     * @param nl note length\n     * @param tm tempo \n     */\n    public Piece(int i, String name, String comp, String k, String m, double nl, int tm) {\n        this.karaokeIndex = i;\n        this.title = name;\n        this.composer = comp;\n        if(Piece.VALIDKEYS.contains(k))\n            this.key = k;\n        else \n            this.key = \"C\";\n        this.meter = m;\n        this.noteLength = nl;\n        this.tempo = tm;\n        this.tempoNoteLength = nl;\n        this.staffs = new ArrayList<>(); \n        this.isValid = false;\n        this.defaultNoteLength = true;\n        this.numListeners = 0; \n        try {\n            this.player = new MidiSequencePlayer((int) tm, DEFAULT_BEATS_PER_MIN);}\n        catch(Exception e) {\n            System.err.println(e.toString());\n        }\n       this.checkRep();\n    }\n\n    // asserts rep invariant\n    private void checkRep() {\n        assert karaokeIndex >= 0;\n        assert !title.isEmpty();\n        assert !composer.isEmpty();\n        assert VALIDKEYS.contains(key);\n        assert !meter.isEmpty();\n        assert this.numListeners >=0;\n\n        assert noteLength >= 1/(BASE_FOR_NOTE_LENGTH*BASE_FOR_NOTE_LENGTH);\n        assert tempo > 0;\n    }\n    \n    /**\n     * Play this work of music.\n     * if the piece is already playing, return\n     */\n    public synchronized void play() {\n        if(!this.isValid || this.player.isPlaying()) {\n                 return;\n            }\n        try {\n            Thread.sleep(THREAD_SLEEP_TIME);// wait for player page to render\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        this.player.play();   \n    }\n\n\n    /**\n     * A function that loops through the staffs in this piece, and adds notes and lyric events to the\n     * piece player. staffs are stored in this.staffs.\n     * \n     * Used by piece parser in initialization \n     * @throws AssertionError A valid piece cannot be re-initialized\n     */\n    public void initializePiece() {\n\n        if(this.isValid)\n            throw new AssertionError(\"piece has already been initalized\");\n\n        if(this.staffs.isEmpty())\n            throw new AssertionError(\"A piece must have one or more voices to be initialized\");\n\n        this.player.setBeatsPerMinute((int) tempo);\n        for (Staff staff : this.staffs) {\n//            System.out.println(\"staff\\n\" + staff);\n            staff.addMusicToMidiPlayer(this.player);\n        }\n        this.isValid = true;\n    }\n    \n    /**\n     * @return number of listeners of the piece\n     */\n    public int getNumListeners() {\n        return this.numListeners;\n    }\n\n\n\n    /**\n     * Add a listener for a voice. Voices are distributed as evenly as possible amongst the listeners. \n     * @param listener the printWriter to print to\n    * @throws AssertionError An invalid piece can't have listeners\n     */\n    public synchronized void addListener(PrintWriter listener) {\n        if(!this.isValid )\n            throw new AssertionError(\"Piece is invalid and can't be listened to\");\n\n        this.staffs.get(this.numListeners % this.staffs.size()).addListener(listener);\n        \n        \n        this.numListeners++;\n    }\n    \n    /**\n     * @return karaoke index\n     */\n    public int getKaraokeIndex() {\n        return this.karaokeIndex;\n    }\n    \n    /**\n     * @return title\n     */\n    public String getTitle() {\n        return this.title;\n    }\n    \n    /**\n     * @return composer\n     */\n    public String getComposer() {\n        return this.composer;\n    }\n    \n    /**\n     * @return key\n     */\n    public String getKey() {\n        return this.key;\n    }\n    \n    /**\n     * @return meter \n     */\n    public String getMeter() {\n        return this.meter;\n    }\n    \n    /**\n     * @return note length \n     */\n    public double getNoteLength() {\n        return this.noteLength;\n    }\n    \n    /**\n     * @return tempo \n     */\n    public int getTempo() {\n        return this.tempo;\n    }\n    \n    /** \n     * @return String representation of all the staffs contained\n     */\n    public String getStaffs() {\n        String staffs = \"\"; \n        for (int i=0; i<this.staffs.size(); i++) {\n            staffs += i + \":\\n\";\n            staffs += this.staffs.get(i).toString() + \"\\n\";\n        }\n        return staffs.substring(0, staffs.length()-1); \n    }\n    //--------------------------setters\n\n\n    /**\n     * Sets the karaoke index to i. \n     * @param i new karaoke index. \n     */\n    public void setIndex(int i) {\n        if(this.isValid)\n            throw new AssertionError(\"Valid pieces can no longer be modified\");\n        this.karaokeIndex = i;\n        this.checkRep();\n    }\n\n    /**\n     * Sets the title of piece to name. \n     * @param name new title. \n     */\n    public void setTitle(String name) {\n        if(this.isValid)\n            throw new AssertionError(\"Valid pieces can no longer be modified\");\n        this.title = name;\n        this.checkRep();\n\n    }\n\n    /**\n     * Sets the composer to c. \n     * @param c new composer. \n     */\n    public void setComposer(String c) {\n        if(this.isValid)\n            throw new AssertionError(\"Valid pieces can no longer be modified\");\n        this.composer = c;\n        this.checkRep();\n\n    }\n\n    /**\n     * Sets the key to k. \n     * @param k new key. \n     */\n    public void setKey(String k) {\n        if(this.isValid)\n            throw new AssertionError(\"Valid pieces can no longer be modified\");\n        this.key = k;\n        this.checkRep();\n\n    }\n    \n    /**\n     * Sets the meter to m, changes defaultMeter status to false. \n     * If note length hasn't been initialized then change defaultNoteLength \n     *      according to the default values mentioned in the karaoke specs. \n     * @param m new meter. \n     */\n    public void setMeter(String m) {\n        if(this.isValid)\n            throw new AssertionError(\"Valid pieces can no longer be modified\");\n\n        if (defaultNoteLength && decimalValueOfString(m) < METER_THRESHOLD) {\n            this.noteLength = 1/(2*BASE_FOR_NOTE_LENGTH); \n        }\n        this.meter = m;\n        this.checkRep();\n\n    }\n\n    /**\n     * Set note length to m, change defaultNoteLength to false. \n     * @param l new note length. \n     */\n    public void setDefaultNoteLength(double l) {\n        if(this.isValid)\n            throw new AssertionError(\"Valid pieces can no longer be modified\");\n\n        this.noteLength = l;\n        this.defaultNoteLength = false; \n        this.checkRep();\n\n    }\n    /**\n     * sets the tempo note length \n     * @param tl new tempo note length \n     */\n    public void setTempoNoteLength(double tl) {\n        this.tempoNoteLength = tl;\n        this.checkRep();\n    }\n\n    /**\n     * @return the tempo's note length \n     */\n    public double getTempoNoteLength(){\n        return this.tempoNoteLength;\n    }\n    \n    /**\n     * Sets the tempo to t. \n     * @param t new tempo\n     */\n    public void setTempo(int t) {\n        if(this.isValid)\n            throw new AssertionError(\"Valid pieces can no longer be modified\");\n\n        this.tempo = t;\n        this.checkRep();\n\n    }\n    \n    /**\n     * Add new staff to list of staffs. \n     * @param s new staff\n     */\n    public void addStaff(Staff s) {\n        if(this.isValid)\n            throw new AssertionError(\"Valid pieces can no longer be modified\");\n        this.staffs.add(s);\n        this.checkRep();\n\n    }\n\n    /**\n     * Generate a greeting for karaoke listeners including the piece title and composer if it exists. \n     * @return string greeting \n     */\n    public String generateGreeting() {\n        String greeting = this.title + \" by \" + this.composer +\"<br>\";\n        greeting += \"prepare to sing!<br>\";\n        return greeting;\n\n    }\n\n\n    \n    @Override\n    public String toString() {\n        String show = \"\";\n        show += \"karaoke index: \" + this.karaokeIndex + \"\\ntitle: \" + this.title + \"\\ncomposer: \" + this.composer + \n                \"\\nkey: \" + this.key + \"\\nmeter: \" + this.meter + \"\\nnote length: \" + this.noteLength + \n                \"\\ntempo: \" + this.tempo + \"\\nstaffs: \" + this.staffs + \"\\nis valid: \" + this.isValid +\n                \"staffs: \" + this.staffs; \n        return show;         \n    }\n\n    /**\n     * Return decimal value of the String number. \n     * @param number of the form A/B where A and B are nonempty strings of digits, C (4/4) or C| (2/2)\n     * @return double A or A/B when applicable \n     */\n    public static double decimalValueOfString(String number) {\n        if (number.equals(\"C\") || number.equals(\"C|\")) {\n            return 1.0; \n        }\n        double value; \n        int indexOfSlash = number.indexOf(\"/\");\n        if (indexOfSlash != -1) {\n            // extract numerator and denominator from number using the \"/\" as delimiter\n            double num = Double.valueOf(number.substring(0, indexOfSlash)); \n            double den = Double.valueOf(number.substring(indexOfSlash+1)); \n            value = num/den; \n        } else {\n            value = Integer.valueOf(number);\n        }\n        return value; \n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return obj instanceof Piece &&\n            this.isSimilar((Piece) obj);\n    }\n\n    @Override\n    public int hashCode() {\n        int h = HASHCODE_BASE;\n        h += this.composer.hashCode();\n        h += this.key.hashCode();\n        h += this.title.hashCode();\n        h += this.title.hashCode();\n        h += this.staffs.hashCode();\n        h += this.tempo*HASHCODE_TEMPO_MULTIPLIER;\n        h += decimalValueOfString(this.meter)*HASHCODE_METER_MULITPLIER;\n        return h;\n    }\n\n    private boolean isSimilar(Piece obj) {\n        boolean isEqual = true; // short circuit ops\n        //   do we want all the fields?\n        isEqual = isEqual && this.composer.equals(obj.composer);\n        isEqual = isEqual && this.key.equals(obj.key);\n        isEqual = isEqual && this.title.equals(obj.title);\n        isEqual = isEqual && this.karaokeIndex == obj.karaokeIndex;\n        isEqual = isEqual && this.meter == obj.meter;\n        isEqual = isEqual && this.tempo == obj.tempo;\n        isEqual = isEqual && this.noteLength == obj.noteLength;\n        isEqual = isEqual && this.title.equals(obj.title);\n        isEqual = isEqual && this.staffs.equals(obj.staffs);\n        return isEqual;\n    }\n\n    /**\n     * @return an indication of whether or not the piece is being played by the midisequence player. \n     */\n    public boolean isPlaying() {\n        return this.player.isPlaying();\n    }\n\n\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:54"
  }
},
{
  "model": "review.file",
  "pk": 282917,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Pitch.java",
    "data": "package karaoke.sound;\n\n/**\n * Pitch is an immutable type representing the frequency of a musical note.\n * Standard music notation represents pitches by letters: A, B, C, ..., G.\n * Pitches can be sharp or flat, or whole octaves up or down from these\n * primitive generators.\n * \n * <p> For example:\n * <br> new Pitch('C') makes middle C\n * <br> new Pitch('C').transpose(1) makes C-sharp\n * <br> new Pitch('E').transpose(-1) makes E-flat\n * <br> new Pitch('C').transpose(OCTAVE) makes high C\n * <br> new Pitch('C').transpose(-OCTAVE) makes low C\n */\npublic class Pitch {\n\n    private final int value;\n\n    /*\n     *\n     * Abstraction function AF(value):\n     *   AF(0),...,AF(11) map to middle C, C-sharp, D, ..., A, A-sharp, B.\n     *   AF(i+12n) maps to n octaves above middle AF(i)\n     *   AF(i-12n) maps to n octaves below middle AF(i)\n     *   \n     * Rep invariant: \n     *      true\n     */\n\n    private static final int[] SCALE = {\n            9,  // A\n            11, // B\n            0,  // C\n            2,  // D\n            4,  // E\n            5,  // F\n            7,  // G\n    };\n\n    private static final String[] VALUE_TO_STRING = {\n            \"C\", \"^C\", \"D\", \"^D\", \"E\", \"F\", \"^F\", \"G\", \"^G\", \"A\", \"^A\", \"B\"\n    };\n    \n    /**\n     * Middle C.\n     */\n    public static final Pitch MIDDLE_C = new Pitch('C');\n\n    /**\n     * Number of pitches in an octave.\n     */\n    public static final int OCTAVE = 12;\n\n    /**\n     * Make a Pitch object in any octave given some\n     * numerical value\n     * @param value The value upon which to base the pitch\n     */\n    public Pitch(int value) {\n        this.value = value;\n    }\n\n    /**\n     * Make a Pitch named c in the middle octave of the piano keyboard.\n     * For example, new Pitch('C') constructs middle C.\n     * @param c letter in {'A',...,'G'}\n     */\n    public Pitch(char c) {\n        try {\n            value = SCALE[c-'A'];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(c + \" must be in the range A-G\", e);\n        }\n    }\n\n    /**\n     * @param semitonesUp \n     * @return pitch made by transposing this pitch by semitonesUp semitones;\n     *         for example, middle C transposed by 12 semitones is high C, and\n     *         E transposed by -1 semitones is E flat\n     */\n    public Pitch transpose(int semitonesUp) {\n        return new Pitch(value + semitonesUp);\n    }\n\n    /**\n     * @param that \n     * @return number of semitones between this and that; i.e., n such that\n     *         that.transpose(n).equals(this)\n     */\n    public int difference(Pitch that) {\n        return this.value - that.value;\n    }\n\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null) return false;\n        if (obj.getClass() != this.getClass()) return false;\n        \n        Pitch that = (Pitch) obj;\n        return this.value == that.value;\n    }\n\n    @Override\n    public int hashCode() {\n        return value;\n    }\n\n    /**\n     * @return this pitch in abc music notation\n     * @see \"http://www.walshaw.plus.com/abc/examples/\"\n     */\n    @Override\n    public String toString() {\n        String suffix = \"\";\n        int v = value;\n\n        while (v < 0) {\n            suffix += \",\";\n            v += OCTAVE;\n        }\n\n        while (v >= OCTAVE) {\n            suffix += \"'\";\n            v -= OCTAVE;\n        }\n\n        return VALUE_TO_STRING[v] + suffix;\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282918,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Rest.java",
    "data": "package karaoke.sound;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Rest implements Music{\n    private final double duration;\n\n    // AF(duration) = a concrete variant of music that represents a rest note\n    //          the duration of the rest in beats is determined by duration\n    // \n    //  RI:\n    //      this.duration >0\n    //  \n    //  Safety from Rep exposure\n    //      all fields are marked private final, and are primitive types\n\n    //  Thread safety argument\n    //      this class is immutable, and therefore threadsafe.\n\n    private final int hashcodeNumber = 79;\n    /**\n     * Constructs a Rest object from the given duration\n     * @param d The duration of the rest\n     */\n    public Rest(double d) {\n        this.duration = d;\n        this.checkRep();\n    }\n\n    private void checkRep(){\n        assert this.duration > 0;\n    }\n\n    @Override\n    public double duration() {\n        return this.duration;\n    }\n\n    @Override\n    public Music transpose(int semitonesUp) { // can we just return this??\n        return new Rest(this.duration);\n    }\n\n    @Override\n    public Music changeDuration(double duration) {\n        return new Rest(duration);\n    }\n\n    @Override\n    public int numNotes() {\n        return 0;\n    }\n    \n    @Override\n    public boolean equals(Object that) {\n        if(that instanceof Rest ) {\n            Rest other = (Rest) that;\n            return this.duration == other.duration;\n        }\n\n        return false;\n    }\n\n    @Override\n    public List<Double> addToMidiPlayer(double startBeat) { \n        return new ArrayList<Double>(Arrays.asList(-1.0,-1.0,0.0));\n    }\n\n\n    @Override\n    public boolean isRest() {\n        return true;\n    }\n\n    @Override\n    public List<Double> addToMidiPlayer(double startBeat, int tupletSpec) {\n        throw new AssertionError( \"rests cannot be in tuplets\");\n    }\n\n    @Override\n    public int hashCode() {\n        return (int) Math.pow(hashcodeNumber*this.duration, 2);\n    }\n\n    @Override\n    public String toString() {\n        return \"z\" + Music.convertDecimalToFraction(this.duration);\n    }\n    \n    @Override\n    public Music modifyKey(MusicKeys key) {\n        return this;\n    }\n\n\n}",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282919,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/SequencePlayer.java",
    "data": "package karaoke.sound;\n\nimport java.util.function.Consumer;\n\n/**\n * Schedules and plays a sequence of notes at given times.\n * Times and durations are specified in doubles, but implementations of this\n * interface may round to implementation-specific precision.\n * For example, 0.501 beats may be rounded to 0.5 beats.\n * (In MidiSequencePlayer, this precision is controlled by the ticksPerBeat\n * parameter.)\n */\npublic interface SequencePlayer {\n\n    /**\n     * Schedule a note to be played starting at startBeat for the duration numBeats.\n     * @param instr instrument for the note\n     * @param pitch pitch value of the note\n     * @param startBeat the starting beat\n     * @param numBeats the number of beats the note is played\n     */\n    public void addNote(Instrument instr, Pitch pitch, double startBeat, double numBeats);\n\n    /**\n     * Schedule a callback when the synthesizer reaches a time.\n     * @param atBeat beat at which to call the callback\n     * @param callback function to call, with type double->void. \n     *              The double parameter is the time when actually called, in beats.\n     *              This time may be slightly different from atBeat because of rounding.\n     */\n    public void addEvent(double atBeat, Consumer<Double> callback);\n\n    /**\n     * Play the scheduled music.\n     */\n    public void play();\n    \n\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282920,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Staff.java",
    "data": "package karaoke.sound;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.function.Consumer;\n\n\n/**\n * A mutable data type that holds music notes and lyrics in their proper position (essentially a music array)\n */\npublic class Staff {\n    private final String key;\n    private final List<Integer> meter; //1st element is numerator, 2nd is denominator\n    private final double defaultNoteLength;\n    private final double tempoNoteLength;\n    private final int tempo;\n    private final List<String> lyrics; // accessed by callbacks\n    private final List<Music> music;\n\n    private final int barNumber;\n    private final Instrument instrument = Instrument.PIANO;\n    private int noteCounter = 0;\n    private final LyricPrinter printer;\n    \n    public static final int DEFAULT_METER = 4; \n    // \n    // AF(key, meter, defaultNoteLength, tempoNoteLength, tempo, lyrics, music, barNumber, instrument, noteCounter, printer)\n    /*      = A staff in Music notation, or a collection of melodic lines of music (musical notes and corresponding lyrics).  \n    * key is the key signature of the work.\n    * meter is the sum of the durations of all the notes in a bar.\n    * defaultNoteLength is the duration of a note in this work.\n    * tempoNoteLength is the duration of a note in this work assumed by the tempo \n    * tempo is the number of whole beats per minute. \n    * music and lyrics are lists of the musical notes and corresponding lyrics in this work, respectively, \n    *     where the musical note at index i of music matches with the lyric String at index i of lyrics. \n    * barNumber an index referring to the temporal position in the staff\n    * noteCounter an index used to traverse through music and lyrics\n    * printer is used to print staff's lyrics to an output stream \n    */\n    //  \n    // Rep Invariant:\n    //      meter, defaultNoteLength, tempo, barNumber, noteCounter, lyricCounter >= 0\n    //    \n    // Rep Exposure:\n    //      all fields are private and final\n    //      defensive copies of lyrics and music are used when they are passed as parameters \n    //      or returned to the client\n    //      The only field of this class accessed by its protected LyricPrinter class is the\n    //          lyric array, which is not returned or passed as a parameter by either class\n    //\n    // Thread Safety:\n    //    This class is not thread safe, in intended use its spec is split into initialization and playback modules.\n    \n    //    In the initialization section of the spec, the Staff object is not threadsafe, but it\n    //    only needs to be accessed by the Piece Parser creating it, and the piece containing it. \n    //    \n    //    The playback segment of the spec includes the following functions and fields: lyrics, printer, lyricCounter, numListeners, and addListener.\n    //    these fields and methods are exposed to multiple threads from the server class via piece methods.\n    //    Fields:\n    //    immutability: fields key, meter (unmodifiable list), defaultNoteLength, tempoNoteLength, tempo, barNumber, instrument, printer are threadsafe by immutability\n    //    music is never accessed by multiple threads\n    //    lyrics is wrapped by a thread safe wrapper class (syncrhonized list)\n    //    noteCounter is only modified by synchronized methods \n    \n    //    Methods:\n    //    synchronization: numListeners, addListeners, addMusicToMidiPlayer use the monitor pattern with a lock on Staff obj to ensure thread safe\n    //                      modification and access to fields/methods \n    //    \n    //    the LyricPrinter internal class is a threadsafe class\n    //    Each Staff will only ever have one instance of LyricPrinter\n\n\n    \n    /**\n     * Constructs a Staff from a key, meter, noteLength, tempo\n     * @param key The musical key that the staff is in \n     * @param meter The musical meter of the staff\n     * @param defaultNoteLength The standard note length of the staff\n     * @param tempo The musical tempo of the staff\n     */ \n    public Staff(String key, String meter, double defaultNoteLength, int tempo) {\n        this.key = key;\n        this.meter = parseMeter(meter);\n        this.defaultNoteLength = defaultNoteLength;\n        this.tempo = tempo;\n        this.tempoNoteLength = defaultNoteLength;\n        this.printer = new LyricPrinter();\n        this.music = new ArrayList<>();\n        this.lyrics = Collections.synchronizedList(new ArrayList<>());\n        this.barNumber = 0;\n        this.checkRep();\n    }\n        \n    /**\n     * Constructs a Staff from a key, meter, noteLength, tempo\n     * @param key The musical key that the staff is in \n     * @param meter The musical meter of the staff\n     * @param defaultNoteLength The standard note length of the staff\n     * @param tempo The musical tempo of the staff (beats per min)\n     * @param tempoNoteLength the note length of tempo \n     */ \n    public Staff(String key, String meter, double defaultNoteLength, int tempo, double tempoNoteLength) {\n        this.key = key;\n        this.meter = parseMeter(meter);\n        this.defaultNoteLength = defaultNoteLength;\n        this.tempo = tempo;\n        this.tempoNoteLength = tempoNoteLength;\n        this.printer = new LyricPrinter();\n        this.music = new ArrayList<>();\n        this.lyrics = Collections.synchronizedList(new ArrayList<>());\n        this.barNumber = 0;\n        this.checkRep();\n        \n    }\n    \n    /**\n     * Constructs a Staff object from a key, meter, defaultNoteLength, tempo, lyrics, music, barNumber, and tempoNoteLength\n     * @param key The musical key that the staff is in \n     * @param meter The musical meter of the staff\n     * @param defaultNoteLength The standard note length of the staff\n     * @param tempo The musical tempo of the staff (beats per min)\n     * @param lyrics lists of lyrics \n     * @param music list of musical notes\n     * @param barNumber location of position in staff\n     * @param tempoNoteLength note length of the tempo \n     */\n    public Staff(String key,\n    List<Integer> meter, //1st element is numerator, 2nd is denominator\n    double defaultNoteLength,\n    int tempo,\n    List<String> lyrics, //sequencePlayer\n    List<Music> music, //sequencePlayer\n    int barNumber,\n    double tempoNoteLength\n    // private final SequencePlayer player; // pass in the Piece player and a channel number\n) {\n        this.key = key;\n        this.meter = meter;\n        this.defaultNoteLength = defaultNoteLength;\n        this.tempo = tempo;\n        this.lyrics = new ArrayList<>(lyrics);\n        this.music = new ArrayList<>(music);\n        this.barNumber = barNumber;\n        this.tempoNoteLength = tempoNoteLength;\n        this.printer = new LyricPrinter();\n    }\n    \n    /**\n     * @return a new Staff object with fields identical to the input Staff. \n     */\n    public Staff copy() {\n        return new Staff(this.key, this.meter, this.defaultNoteLength, this.tempo, this.lyrics,\n                this.music, this.barNumber, this.tempoNoteLength);\n    }\n    \n    //turns a string meter into numerator and denominator ints\n    private static List<Integer> parseMeter(String meter) {\n        String noSpacesMeter = meter.replaceAll(\"\\\\s+\",\"\"); //from: https://stackoverflow.com/questions/5455794/removing-whitespace-from-strings-in-java\n        if(noSpacesMeter.equals(\"C\")) {\n            return Arrays.asList(DEFAULT_METER,  DEFAULT_METER);\n        }else if(noSpacesMeter.equals(\"C|\")) {\n            return Arrays.asList(2, 2);\n        }else {\n            int slashIndex = meter.indexOf(\"/\");\n            String numerator = meter.substring(0, slashIndex);\n            String denominator = meter.substring(slashIndex+1);\n            return Collections.unmodifiableList(Arrays.asList(Integer.parseInt(numerator), Integer.parseInt(denominator)));\n        }\n    }\n\n    private void checkRep() {\n        assert !this.meter.isEmpty();\n        assert this.defaultNoteLength > 0;\n        assert this.tempo  > 0;\n        assert this.printer != null;\n        assert this.music != null;\n        assert this.lyrics != null;\n        assert this.barNumber >= 0;\n        // assert this.lyrics.size() > 0;\n        // assert the size of the lyric list should be the size of the musicList;\n    }\n    \n    /**\n     * @return key of staff \n     */\n    public String getKey() {\n        return this.key; \n    }\n    /**\n     * Add a list of musics to the current music object\n     * @param newNotes list of musical notes to add\n     */\n    public void addLineOfMusic(List<Music> newNotes) {\n        this.music.addAll(newNotes);\n    }\n\n\n    /**\n     * Add a lyric to the staff\n     * @param lyric The lyric to be added\n     */\n    public void addLyric(String lyric) {\n        lyrics.add(lyric);\n    }\n    \n    /**\n     * Add a list of music objects to the midiplayer by specifying start time and duration of note to be played. \n     * @param player midiSequencePlayer to add music to \n     */\n    synchronized void addMusicToMidiPlayer(SequencePlayer player) {\n\n\n        double currentBeat = 0;\n\n        for (Music note : this.music) {\n\n            double startOffset = 0;\n            List<Double> allMidiData = note.addToMidiPlayer(startOffset);\n\n            for (int i = 0; i < allMidiData.size(); i++) {\n                double startBeat = allMidiData.get(i++)*defaultNoteLength/tempoNoteLength;\n                Pitch pitch = new Pitch(allMidiData.get(i++).intValue());\n                double duration = allMidiData.get(i)*defaultNoteLength/tempoNoteLength;\n\n                if (startBeat >= 0) {// don't add rests\n                    synchronized (player) {// only modify player with lock\n                        player.addNote(this.instrument, pitch, currentBeat, duration);\n                    }\n                }\n                player.addEvent(currentBeat, printer);// add print event for every beat\n\n            }\n\n            currentBeat += note.duration()*defaultNoteLength/tempoNoteLength;\n        } // loop through all Notes in list and add\n\n        synchronized (player) {// only modify player with lock\n            player.addEvent(currentBeat + 2, (d) -> printer.notifyAllListeners(d)); // slight delay until listeners are\n                                                                                    // released\n        }\n    }\n\n\n    /**\n     * Add a listener for the staff \n     * @param listenerOut PrintWriter object for lyrics to be printed to \n     */\n    synchronized void addListener(PrintWriter listenerOut) {\n        printer.addListener(listenerOut);\n    }\n\n    /**\n     * Return number of listeners for this object. \n     * @return int number of listeners. \n     */\n    synchronized int numListeners() {\n        return this.printer.listeners.size();\n    }\n\n    @Override\n    public boolean equals(Object that) {\n        return that instanceof Staff && sameValue((Staff) that);\n    }\n\n    private boolean sameValue(Staff that) {\n        return this.key.equals(that.key) && this.meter.equals(that.meter)\n                && this.defaultNoteLength == that.defaultNoteLength && this.tempo == that.tempo\n                && this.lyrics.equals(that.lyrics) && this.music.equals(that.music) && this.barNumber == that.barNumber\n                && this.noteCounter == that.noteCounter;\n\n    }\n\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"[|\";\n        for (Music ele : this.music) {\n            builder += \" \" + ele.toString();\n        }\n        builder += \"|]\\n[\";\n        int index = 0;\n        for (int i = 0; i < this.lyrics.size(); i++) {\n            String s = this.lyrics.get(i);\n            if (index != 0) {\n                builder += \", \";\n            }\n            builder += s;\n            index++;\n        }\n\n        return builder + \"]\";\n    }\n\n    /**\n     * This method is for testing purposes\n     * \n     * @return The list of Music objects that make up this staff\n     */\n    public List<Music> getMusic() {\n        return new ArrayList<>(this.music);\n    }\n\n    /**\n     * This method is for testing purposes\n     * \n     * @return The list of LyricLine objects that make up the lyrics for this staff\n     */\n    public List<String> getLyrics() {\n        return new ArrayList<>(this.lyrics);\n    }\n\n\n    /**\n     * An internal class that prints the lyrics of this staff to multiple outputStreams\n     */\n     // \n     // AF(counter, listeners) = a class that prints the stored lines of the containing staff class to\n     //      to multiple output streams. Counter indicates the index of lyric line of the containing staff class to\n     //      to be printed and listeners is a list of streams to be printed to.\n     // \n     // Rep Invariant:\n     //      this.counter < lyrics.size()\n     //      this.listeners does not have any null inputs\n     //  \n     // Safety from rep exposure:\n     //      Counter is a primitive field\n     //      listeners is marked private final, and is not passed\n     //          as a parmaeter or returned from any method\n     //      all fields accessible from the staff class are not \n     //          passed as arguments or returned from any method.\n     // \n     // Thread Safety argument:\n     //      because the methods of thsis class are called asynchronously as callbacks,\n     //      this class follows the monitor pattern. Additionally, any referneces to the rep\n     //      that can be shared across multiple threads are locked with a synchronize clause,\n     //      as in accept and notifyAllListeners. Additionally, the lyric list of the containing\n     //      Staff class is in a threadsfe wrapper.\n      \n    class LyricPrinter implements Consumer<Double> {\n        private int counter = 0;\n        private final List<PrintWriter> listeners = Collections.synchronizedList(new ArrayList<>());\n        \n        /**\n         * a thread safe, mutable data type representing a lyric printer listening to a Staff object and printing lyrics. \n         */\n        LyricPrinter() {\n        }\n\n        @Override\n        public synchronized void accept(Double d) {\n            for(PrintWriter listener : listeners) {\n               synchronized(listener) {\n                   listener.println(lyrics.get(counter)+\"<br>\");\n                   listener.println(\"<script>document.body.scrollIntoView(false)</script>\");\n               }\n            }\n            counter++;\n        }\n\n        /**\n         * add a listener to print to.\n         * @param listener printwriter to be added\n         * \n         */\n        synchronized void addListener(PrintWriter listener) {\n            listeners.add(listener);\n        }\n\n        /**\n         * Called at the end of a song to release all listeners for other threads. \n         * @param d double param used by LyricPrinter\n         */\n        public synchronized void notifyAllListeners(Double d) {\n            for (PrintWriter listener : listeners) {\n                synchronized(listener) {\n                    listener.notifyAll();\n\n                }\n            }\n        }\n\n    }\n\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282921,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/sound/Tuplet.java",
    "data": "package karaoke.sound;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * A Tuplet represents a tuplet in music, a consecutive group of notes meant to\n * be played for a duration greater or less than the sum of the individual notes\n * in that group\n */\npublic class Tuplet implements Music{\n    private final Music[] notes;\n    private final double duration;\n    \n    /*\n     * AF(notes, duration) = a musical Tuplet consisting of notes which\n     *      are played for a duration greater or less that the sum of the \n     *      individual note durations.\n     * \n     * Rep Invariant:\n     *      duration >0\n     *      notes cannot contain any rests\n     *      \n     * Rep Exposure:\n     *      all fields are private and final\n     *      defensive copies are always used for mutable parameters and return types\n     *      \n     * Thread Safety:\n     *      immutability: Tuplet is an immutable class and relies on the thread safety\n     *      of the Note class\n     */\n    \n    /**\n     * Constructs a Tuplet object from the notes in the tuplet\n     * @param notes The Music objects that make up the tuplet, \n     *      objects in the array must be non null\n     */\n    public Tuplet(Music[] notes) {\n        this.notes = Arrays.copyOf(notes, notes.length);\n        this.duration = calculateDuration(Arrays.copyOf(notes, notes.length));\n        this.checkRep();\n    }\n\n    private void checkRep() {\n        final int dupletLength = 2;\n        final int tripletLength = 3;\n        final int quadruplet = 4;\n        \n        assert this.duration >0;\n        for(Music note : notes) {\n            assert note != null;\n            assert !note.isRest(); // cannot contain rests\n        }\n        assert this.notes.length == dupletLength \n                || this.notes.length == tripletLength || this.notes.length == quadruplet; \n    }\n    \n    /*calculates the duration of the tuplet\n      the entries of notes must not be null */\n    private double calculateDuration(Music[] notes) {\n        double originalDuration = 0;\n        for(Music note : notes) {\n            assert note != null;\n            originalDuration += note.duration();\n        }\n        return originalDuration*Music.tupletSpecToFactor(notes.length);\n    }\n    \n    @Override\n    public double duration() {\n        return duration;\n    }\n\n    @Override\n    public Music transpose(int semitonesUp) {\n        Music[] outputParameter = new Music[this.notes.length];\n        for(int i=0; i<this.notes.length; i++) {\n            outputParameter[i] = this.notes[i].transpose(semitonesUp);\n        }\n        \n        return new Tuplet(outputParameter);\n    }\n\n    @Override\n    public Music changeDuration(double duration) {\n        assert duration >0;\n        Music[] newNotes = this.notes.clone();\n        newNotes[0] = newNotes[0].changeDuration(duration);\n        return new Tuplet(newNotes);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return obj instanceof Tuplet\n            && this.isSimilar((Tuplet) obj);\n    }\n\n    private boolean isSimilar(Tuplet obj) {\n        if(this.notes.length != obj.notes.length) \n            return false;\n\n        boolean isEqual = true;\n        for (int i = 0; i < this.notes.length; i++) {\n            isEqual = isEqual && this.notes[i].equals(obj.notes[i]);\n        }\n        return isEqual;\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime1 = 7;\n        final int prime2 = 11;\n                \n        int h = prime1;\n        for (Music ele : this.notes) {\n            h += ele.hashCode()*prime2;\n        }\n        return h;\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"(\" + this.notes.length + \"{\";\n        for(Music note: this.notes) {\n            builder += note.toString() + \" \";\n        }\n        return builder + \"}(\" + Music.convertDecimalToFraction(this.duration)+\")\";\n    }\n\n    @Override\n    public List<Double> addToMidiPlayer(double startBeat) {\n        List<Double> midiData = new ArrayList<>();\n        for(Music note : notes) {\n            midiData.addAll(note.addToMidiPlayer(startBeat, this.notes.length));\n            startBeat += midiData.get(2); // update start from duration\n        }\n        return midiData;\n    }\n\n\n\n    @Override\n    public List<Double> addToMidiPlayer(double startBeat, int tupletSpec) {\n        if(tupletSpec != this.notes.length){\n            throw new AssertionError(\"tuplet spec is invalid\");\n        }\n\n        List<Double> midiData = new ArrayList<>();\n        for(Music note : notes) {\n            midiData.addAll(note.addToMidiPlayer(startBeat, tupletSpec));\n            startBeat += midiData.get(2); // update start from duration\n        }\n        return midiData;\n    }\n\n    \n    @Override\n    public boolean isRest() {\n        return false;\n    }\n\n    @Override\n    public int numNotes() {\n        int numNotes = 0;\n        for (Music note : this.notes) {\n            numNotes += note.numNotes();\n        }\n        return numNotes;\n    }\n\n    @Override\n    public Music modifyKey(MusicKeys key) {\n        Music[] newNotes = new Music[this.notes.length];\n        for (int i = 0; i < this.notes.length; i++) {\n            newNotes[i] = this.notes[i].modifyKey(key);\n        }\n        return new Tuplet(newNotes);\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282922,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/web/HeadersFilter.java",
    "data": "/* Copyright (c) 2017-2018 MIT 6.031 course staff, all rights reserved.\n * Redistribution of original or derived work requires permission of course staff.\n */\npackage karaoke.web;\n\nimport java.io.IOException;\n\nimport com.sun.net.httpserver.Filter;\nimport com.sun.net.httpserver.Headers;\nimport com.sun.net.httpserver.HttpExchange;\n\n/**\n * Filter that adds standard headers to every response.\n * \n */\npublic class HeadersFilter extends Filter {\n    \n    private final Headers headers = new Headers();\n    \n    @Override public String description() { return \"Add headers to all responses\"; }\n    \n    /**\n     * Add a new header to the set of standard headers.\n     * @param key header name, e.g. \"Content-Type\"\n     * @param value header value, e.g. \"text/plain\"\n     */\n    public void add(String key, String value) {\n        headers.add(key, value);\n    }\n    \n    @Override public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n        exchange.getResponseHeaders().putAll(headers);\n        chain.doFilter(exchange);\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282923,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/src/karaoke/web/LogFilter.java",
    "data": "/* Copyright (c) 2017-2018 MIT 6.031 course staff, all rights reserved.\n * Redistribution of original or derived work requires permission of course staff.\n */\npackage karaoke.web;\n\nimport java.io.IOException;\n\nimport com.sun.net.httpserver.Filter;\nimport com.sun.net.httpserver.HttpExchange;\n\n/**\n * Logging filter that reports request URLs, exceptions, and response codes to\n * the console.\n * \n */\npublic class LogFilter extends Filter {\n    \n    @Override public String description() { return \"Log requests\"; }\n    \n    @Override public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n        System.err.println(\" -> \" + exchange.getRequestMethod() + \" \" + exchange.getRequestURI());\n        try {\n            chain.doFilter(exchange);\n        } catch (IOException | RuntimeException e) {\n            System.err.print(\" !! \");\n            e.printStackTrace();\n            throw e; // after logging, let the exception continue\n        }\n        System.err.println(\" <- \" + exchange.getResponseCode());\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282924,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/ServerTest.java",
    "data": "package karaoke;\n\nimport java.io.IOException;\n\nimport org.junit.Test;\n\nimport karaoke.sound.Piece;\nimport karaoke.sound.Staff;\n\n/**\n * @category no_didit\n */\npublic class ServerTest {\n\n    public static final double EPSILON = .0001;\n\n    /**\n     * Testing Strategy\n     * Sevre class is rather straightforward , but has \n     * \n     * \n     * \n     */\n\n\n     @Test\n     public void testStartStopServer() throws IOException{\n        Piece piece = new Piece(0, \"test piece\", \"Junit\", \"\", \"C\", 1.0/8,70);\n        Staff staff1 = new Staff(\"\", \"C\", 1.0/8, 70,1.0/4.0);\n        Staff staff2 = new Staff(\"\", \"C\", 1.0/8, 70,1.0/4.0);\n\n\n        piece.addStaff(staff1);\n        piece.addStaff(staff2);\n        piece.initializePiece();\n\n         Server server = new Server(piece, \"host\", 0);\n\n         server.start();\n\n         System.out.println(server.port());\n\n         server.stop();\n\n     }\n\n\n     @Test\n     public void testRunServer() throws IOException{\n        Piece piece = new Piece(0, \"test piece\", \"Junit\", \"\", \"C\", 1.0/8,70);\n        Staff staff1 = new Staff(\"\", \"C\", 1.0/8, 70,1.0/4.0);\n        Staff staff2 = new Staff(\"\", \"C\", 1.0/8, 70,1.0/4.0);\n\n\n        piece.addStaff(staff1);\n        piece.addStaff(staff2);\n        piece.initializePiece();\n\n         Server server = new Server(piece, \"host\", 0);\n\n         server.start();\n\n         System.out.println(server.port());\n\n     }\n\n}",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282925,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/parser/LyricParserTest.java",
    "data": "package karaoke.parser;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.LyricLine;\n/**\n * @category no_didit\n */\npublic class LyricParserTest {\n        \n    /**\n     * Testing strategy:\n     *      This classes methods are heavily interdependent with the lyric parser, so we will\n     *      test the implementation of the class in conjunction with the lyric parser. the edge\n     *      cases and features of the class we cannot test include...\n     *          empty string inputs (grammar doesn't recognize empty strings)\n     *          methods not used in the parser logic, i.e. getters, adjustLength, printLyricLine etc\n     *      these will have to be tested separately\n     *          \n     * General Partitions : \n     *      * - parens represent: (default), other, other\n     * \n     * input:\n     *      numHyphens: (0), 1, n  \n     *      numStars: (0), 1, n\n     *      numConcats: (0), 1, n\n     *      numUnderscores: (0), 1, n\n     *      numTildes: (0), 1, n\n     *      numWords: (0), 1, n\n     *      numNotes: (0), 1, n\n     *      totalLength: (0), 1, n\n     *      \n     * \n     * LyricLine Tests\n     *      parse():\n     *          validInput: (true), false ##NOTE invalid inputs include anything that doesn't match the grammar\n     *          as well as empty strings\n     *          outputs(): LyricLine Object\n     *      getNumSyllables():\n     *          outputs: int 0, 1, n\n     *      getNumWords():\n     *          outputs : int 0, 1, n\n     * \n     *      printLyricLine():\n     *          inputs: \n     *              currentIndex: (0), 1, n\n     *          outputs:\n     *              properly formated String\n     * \n     *      getCurrentNumNotes():\n     *          outputs: 0, 1, n\n     *      toString():\n     *          outputs: String\n     *      equals():\n     *          outputs: true, false\n     *      copy():\n     *          outputs() - LyricLine\n     *      hashCode(): 0\n     *          outputs: 0, 1, n\n     */\n    \n    @Test(expected=AssertionError.class)\n    public void testAssertionsEnabled() {\n        assert false; // make sure assertions are enabled with VM argument: -ea\n    }\n\n    // Covers\n    //  inputs: numSyllables 0, numWords 0, numNotes 0, totalLength 0\n    // methods: getNumSyllables() 0, getNumWords() 0, printLyricLine(), toString(), setIndex(),\n    @Test\n    public void emptyLineTest() {\n        LyricLine empty = new LyricLine(1, 1);\n        assertEquals(\"expected empty Lyricline prop to be 0\", 0, empty.getNumSyllables());\n        assertEquals(\"expected empty Lyricline prop to be 0\", 0, empty.getCurrentNumNotes());\n        assertEquals(\"expected empty Lyricline prop to be \", \"\", empty.printLyricLine());\n        assertEquals(\"expected empty Lyricline prop to be 0\", 0, empty.getNumWords());\n        assertEquals(\"expected empty Lyricline prop to be the empty string \", \"\", empty.toString()); \n        boolean indexInvarTest1 = false, indexInvarTest2 = false;\n        try {\n            empty.setIndex(2);\n        } catch(AssertionError e) {\n            indexInvarTest1 = true;\n        }\n        try {\n            empty.setIndex(-1);\n        } catch(AssertionError e) {\n            indexInvarTest2 = true;\n        }\n\n        empty.setIndex(0);\n\n        assertTrue(indexInvarTest1 && indexInvarTest2);\n\n    }\n\n    // covers:\n    //  totalLength 0\n    // parse()\n    @Test\n    public void testParseEmptystring() throws UnableToParseException{\n        LyricLine empty = LyricParser.parse(\"\", 0);\n        assertEquals(\"expected empty Lyricline prop to be 0\", 0, empty.getNumSyllables());\n        assertEquals(\"expected empty Lyricline prop to be 0\", 0, empty.getCurrentNumNotes());\n        assertEquals(\"expected empty Lyricline prop to be \", \"\", empty.printLyricLine());\n        assertEquals(\"expected empty Lyricline prop to be 0\", 0, empty.getNumWords());\n        assertEquals(\"expected empty Lyricline prop to be the empty string \", \"\", empty.toString()); \n    }\n    \n    // covers:\n    //  totalLength 1, numStars 1\n    // parse()\n    @Test\n    public void testParseSingleSymbol() throws UnableToParseException{\n        LyricLine empty = LyricParser.parse(\"*\", 0);\n        assertEquals(\"expected blank syllable Lyricline prop to be 1\", 1, empty.getNumSyllables());\n        assertEquals(\"expected blank syllable Lyricline prop to be 1\", 1, empty.getCurrentNumNotes());\n        assertEquals(\"expected blank syllable Lyricline to highlight syllable \", \"<b>.</b>\", empty.printLyricLine());\n        assertEquals(\"expected blank syllable Lyricline to keep highlighting syllable\", \"<b>.</b>\", empty.printLyricLine());\n        assertEquals(\"expected blank syllable Lyricline to be a word\", 1, empty.getNumWords());\n    }\n\n    //covers: \n    // numSyllables: 1, numWords 1, numNotes 1, totalLength 0\n    // methods:\n    // copy() an equivalent lyricline object, hashCode() - follows object contract, getNumSyllables 1,\n    //  getCurrentNumNotes() - 1, toString(), parse(), equals()\n    // \n    @Test\n    public void testWordSingleton() throws UnableToParseException{\n        LyricLine singleton = LyricParser.parse(\"this\", 1);\n        assertEquals(\"expected one syllable\", 1, singleton.getNumSyllables());\n        LyricLine copy = singleton.copy();\n        assertEquals(singleton, copy);\n        assertEquals(singleton.hashCode(), copy.hashCode());\n        assertEquals(1, singleton.getCurrentNumNotes());\n        assertEquals(\"this1\", singleton.toString());\n    }\n\n    // covers:\n    // inputs: all fields empty or 0, totalLength n\n    //  methods: adjustLength() - Success (8 blank syllables added) -> printLyricLine()\n    @Test//TODO: failing\n    public void testAdjustLyricLength() {\n        LyricLine emptyLine = new LyricLine(8, 3);\n        emptyLine.adjustLength();\n\n        assertEquals(\"expected all syllables to be...\", \"<b>.</b> . . . . . . .\", emptyLine.printLyricLine());\n        emptyLine.adjustLength(1);\n        assertEquals(\"expected all syllables to be .\", \"<b>.</b>\", emptyLine.printLyricLine());\n    }\n\n    //covers: test parser adjustment\n    // numSyllables: 1, numWords 1, currentIndex 0 hasUnderscores: n, totalLength n\n    // methods - parse(), equals(), toString()\n    @Test\n    public void testMultipleMods() throws UnableToParseException{\n        LyricLine mods = LyricParser.parse(\"hi___\", 4);\n        assertEquals(\"expected one syllabel\", 1, mods.getNumSyllables());\n        assertEquals(4, mods.getCurrentNumNotes());\n\n        LyricLine truncatedMods = LyricParser.parse(\"hi___\", 3);\n        assertEquals(\"expected one syllabel\", 1, truncatedMods.getNumSyllables());\n        assertEquals(3, truncatedMods.getCurrentNumNotes());\n        assertFalse(truncatedMods.equals(mods));\n        assertEquals(\"hi4\", mods.toString());\n    }\n\n    // covers: printLyricLine spec (moving index), complex parsing\n    // inputs: numHyphens n, numSpaces n, numTildes 1, totalLegnth n\n    // methods: parse(), printLyricLien()\n    @Test\n    public void testAulwan() throws UnableToParseException{\n        final String waxiesDargleIn = \"Sa-ys my au-l' wan to your aul' wan, Will~ye come to the Wa-x-ies dar-gle?\";\n\n        LyricLine mods = LyricParser.parse(waxiesDargleIn, 19);\n        // System.out.println(mods.toString());\n        assertEquals(19, mods.getNumSyllables());\n        assertEquals(14, mods.getNumWords());\n\n        mods.printLyricLine(); \n        mods.printLyricLine(); \n        mods.printLyricLine(); \n\n\n        String output = mods.printLyricLine(); // print to the 4th syllable\n        String expected = \"Says my <b>au</b>l' wan to your aul' wan, Will ye come to the Waxies dargle?\";\n        assertEquals(\"expected 4th syllble to be highlighted\", expected, output);\n    }\n    \n    // covers: parsing concats\n    // inputs: numHyphens 1, numConcats 1, totalLength n\n    // methods: parse(), printLyricLine()\n    @Test\n    public void testConcats() throws UnableToParseException{\n        final String stars = \"you\\\\-re sta-ring at the stars\";\n\n        LyricLine starLyrics = LyricParser.parse(stars, 6);\n        assertEquals(\"expected 6 syllabels\", 6, starLyrics.getNumSyllables());\n        assertEquals(\"expected 5 words\", 5, starLyrics.getNumWords());\n        String expected = \"<b>you-re</b> staring at the stars\";\n        assertEquals(\"expected strings to match\", expected, starLyrics.printLyricLine());\n    }\n\n    // covers: parsing concats\n    // inputs: numUnderscores n, numStars n numTilde n, totalLength n\n    // methods: parse(), printLyricLine(), adjustLength\n    @Test\n    public void testComplexLyric() throws  UnableToParseException  {\n        final String inputString = \"this** is** a-sad song!____ what~do~we~dooooo when\";\n\n        LyricLine complexLine = LyricParser.parse(inputString, 11);\n        // System.out.println(complexLine);\n        String formatted = complexLine.printLyricLine();\n\n        // System.out.println(formatted);\n        String expected = \"<b>this</b> . . is . . asad song!\";\n\n        assertEquals(expected, formatted);\n        assertEquals(8, complexLine.getNumWords());\n        assertEquals(9, complexLine.getNumSyllables());\n        assertEquals(11, complexLine.getCurrentNumNotes());\n        for (int i = 0; i < 8; i++) {\n            complexLine.printLyricLine();\n        }\n\n        expected = \"this . . is . . asad <b>song!</b>\";\n        assertEquals(expected, complexLine.printLyricLine());\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282926,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/parser/PieceParserTest.java",
    "data": "package karaoke.parser;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport edu.mit.eecs.parserlib.internal.ParseException;\nimport karaoke.sound.Piece;\n/**\n * @category no_didit\n */\npublic class PieceParserTest {\n        \n    /**\n     * Partitions for parse(), makeAbstractSyntaxTree(), makeParser(): \n     * input: valid input that contains field_number, field_title, field_key\n     *        (un)parsable\n     * contains optional operations:\n     *      other_fields\n     *      field_composer\n     *      field_default_length\n     *      field_meter\n     *      field_tempo\n     *      field_voice\n     * return: Piece object, throws UnableToParseException \n     * field_default_length value: 1/64 < value < 1/16, 1/16, 1/16 < value < 1/8, > 1/8\n     *                           value set to default when neither meter or note length are specified\n     *                           value set to default when only meter, but not note length specified\n     * field_meter value: default value (4/4) or specified      \n     *                    specified as a rational number or special meter (C or C|)\n     *                    value < 3/4, = 3/4, > 3/4\n     * field_tempo: default value (100 beats per min with note length given by L) or specified\n     * voices: contains 1 voice, 2 voices, > 2 voices\n     * lyrics: contains no lyrics, lyrics for some lines of notes, lyrics for every line of notes\n     * comments: (does not) contains \n     * whitespace: extra white space and tabs make (un)parsable\n     */\n    \n    @Test(expected=AssertionError.class)\n    public void testAssertionsEnabled() {\n        assert false; // make sure assertions are enabled with VM argument: -ea\n    }\n       \n    @Test // This test covers input: contains only requirements field_number, field_title, field_key\n    // parsable, return: Piece object\n    public void testParseRequirements() throws UnableToParseException  {\n        String input = \"X: 3\\n\" +\n              \"T: Piece No.3\\n\" + \n              \"K: C\\n\" +\n              \"A2 B2 C2 D2|\";\n        final Piece p = PieceParser.parse(input);\n        assertEquals(\"index doesn't match\",3,p.getKaraokeIndex());\n        assertEquals(\"title doesn't match\",\"Piece No.3\",p.getTitle());\n        assertEquals(\"key doesn't match\",\"C\",p.getKey());\n    }\n    \n    @Test(expected=ParseException.class) // This test covers input: contains 2/3 requirements field_number, field_title\n    // unparsable, return: UnableToParseException\n    public void testParseRequirementsWrong() throws UnableToParseException  {\n        String input = \"X: 3\\n\" +\n              \"T: Piece No.3\\n\"; \n        final Piece p = PieceParser.parse(input);\n    }\n    \n    @Test // This test covers input: contains requirements + other_fields, field_default_length, field_meter, field_tempo\n    // parsable, return: Piece object, voices: 1 voice, lyrics: lyrics for every line of notes, comments: does contain\n    public void testParsePiece3() throws UnableToParseException  {\n        // Piece 3\n        String input = \"X: 3\\n\" + \n                \"T: Piece No.3\\n\" + \n                \"M: 3/4\\n\" + \n                \"L: 1/7\\n\" + \n                \"Q: 1/8= 100\\n\" + \n                \"K: C\\n\"\n                + \"z4 D2 | G4 B G | B4 A2 | G4 E2 | D4 D2 | G4 B G | B4 A2 | d6\\n\" + \n                \"w: ****A_-ma___-zi-ng gra__ce! How_ sweet___ the_ sound___ That_ sa__-ved a_ wretch___ like_ me._____\\n\" + \n                \"%Translation: 4 note  rest , a held for 2,ma held for 4,zi,ng,gra held for 3, ce!, \\n\" + \n                \"%how held for 2, sweet 4, the 2, sound 4, that 2, sa3 ved, a 2, wretch 4, like 2, me. 6\\n\";\n        final Piece p = PieceParser.parse(input);\n        assertEquals(\"index doesn't match\",3,p.getKaraokeIndex());\n        assertEquals(\"title doesn't match\",\"Piece No.3\",p.getTitle());\n        assertEquals(\"key doesn't match\",\"C\",p.getKey()); \n        assertTrue(\"meter doesn't match\", \"3/4\".equals(p.getMeter()));\n        assertTrue(\"note length doesn't match\",1.0/7.0==p.getNoteLength());\n        assertTrue(\"tempo doesn't match\",100.0==p.getTempo());\n        assertTrue(\"tempo note length\", 1/8.0==p.getTempoNoteLength()); \n        String staffs = p.getStaffs(); \n        // System.out.println(\"staffs \" + staffs);\n        assertEquals(\"0:\\n[| z4 D2 G4 B1 G1 B4 A2 G4 E2 D4 D2 G4 B1 G1 B4 A2 D6|]\\n\" + \n                \"[<b>.</b> . . . Amazing grace! How, . <b>.</b> . . Amazing grace! How, . . <b>.</b> . Amazing grace! How, . . . <b>.</b> \"\n                + \"Amazing grace! How, . . . . <b>A</b>mazing grace! How, . . . . <b>A</b>mazing grace! How, . . . . A<b>ma</b>zing grace! \"\n                + \"How, . . . . A<b>ma</b>zing grace! How, . . . . A<b>ma</b>zing grace! How, . . . . A<b>ma</b>zing grace! How, . . . . Ama<b>zi</b>ng grace! \"\n                + \"How, . . . . Amazi<b>ng</b> grace! How, . . . . Amazing <b>gra</b>ce! How, . . . . Amazing <b>gra</b>ce! How, . . . . Amazing <b>gra</b>ce! \"\n                + \"How, . . . . Amazing gra<b>ce!</b> How, . . . . Amazing grace! <b>How</b>]\"\n                ,staffs);  \n    }\n    \n    @Test // This test covers input: contains requirements + other_fields, field_composer, field_default_length, field_meter, field_tempo\n    // parsable, return: Piece object, voices: 1 voice, lyrics: lyrics for every line of notes, comments: does not contain, whitespace: extra white space\n    public void testParseAbcSong() throws UnableToParseException  {\n        String input = \"X:1\\n\" + \n                \"T:Alphabet Song\\n\" + \n                \"C:Traditional Kid's Song\\n\" + \n                \"M:4/4\\n\" + \n                \"L:1/4\\n\" + \n                \"Q:1/4=100\\n\" + \n                \"K:D\\n\" + \n                \"| D D A A|B B A2|G G F F|E/2E/2E/2E/2 D2|\\n\" + \n                \"w:A B C D E F G  H I J K L  M  N  O   P\\n\" + \n                \"  A A G F | F F E2|A       A  G  G | F F E2|\\n\" + \n                \"w:Q R S *   T U V  W~(dou-ble u) | X Y Z\\n\" + \n                \"   D   D    A    A |B B A2 | G    G  F    F | E     E  D2|\\n\" + \n                \"w: Now I've said my A B C's. Tell me what you think of me.\\n\" + \n                \"\";\n        final Piece p = PieceParser.parse(input);\n        assertEquals(\"index doesn't match\",1,p.getKaraokeIndex());\n        assertEquals(\"title doesn't match\",\"Alphabet Song\",p.getTitle());\n        assertEquals(\"composer doesn't match\", \"Traditional Kid's Song\",p.getComposer());\n        assertEquals(\"key doesn't match\",\"D\",p.getKey()); \n        assertTrue(\"meter doesn't match\", \"4/4\".equals(p.getMeter()));\n        assertTrue(\"note length doesn't match\",1.0/4.0==p.getNoteLength());\n        assertTrue(\"tempo doesn't match\",100==p.getTempo());\n        assertTrue(\"tempo note length\", 1/4.0==p.getTempoNoteLength()); \n        String staffs = p.getStaffs(); \n        // System.out.println(\"staffs \" + staffs);\n        String expected = \"0:\\n[| D1 D1 A1 A1 B1 B1 A2 G1 G1 F1 F1 E1/2 E1/2 E1/2 E1/2 D2 A1 A1 G1 F1 F1 F1 E2 A1 A1 G1 G1 F1 F1 E2 D1 D1 A1 A1 B1 B1 A2 G1 G1 F1 F1 E1 E1 D2|]\\n\"\n        +\"[<b>A</b> B C D E F G H I J K L M N O P, A <b>B</b> C D E F G H I J K L M N O P, A B <b>C</b> D E F G H I J K L M N O P, A B C <b>D</b> E F G H I J K L M N O P, A B C D <b>E</b> F G H I J K L M N O P, A B C D E <b>F</b> G H I J K L M N O P, A B C D E F \"\n        +\"<b>G</b> H I J K L M N O P, A B C D E F G <b>H</b> I J K L M N O P, A B C D E F G H <b>I</b> J K L M N O P, A B C D E F G H I <b>J</b> K L M N O P, A B C D E F G H I J <b>K</b> L M N O P, A B C D E F G H I J K <b>L</b> M N O P, A B C D E F G H I J K L \"\n        +\"<b>M</b> N O P, A B C D E F G H I J K L M <b>N</b> O P, A B C D E F G H I J K L M N <b>O</b> P, A B C D E F G H I J K L M N O <b>P</b>, <b>Q</b> R S . T U V W (dou ble u) X Y Z . ., Q <b>R</b> S . T U V W (dou ble u) X Y Z . ., Q R <b>S</b> . T U V W (dou ble u) X Y Z . ., Q R S \"\n        +\"<b>.</b> T U V W (dou ble u) X Y Z . ., Q R S . <b>T</b> U V W (dou ble u) X Y Z . ., Q R S . T <b>U</b> V W (dou ble u) X Y Z . ., Q R S . T U <b>V</b> W (dou ble u) X Y Z . ., Q R S . T U V <b>W (dou ble</b> u) X Y Z . ., Q R S . T U V W (dou ble \"\n        +\"<b>u)</b> X Y Z . ., Q R S . T U V W (dou ble u) <b>X</b> Y Z . ., Q R S . T U V W (dou ble u) X <b>Y</b> Z . ., Q R S . T U V W (dou ble u) X Y <b>Z</b> . ., Q R S . T U V W (dou ble u) X Y Z <b>.</b> ., Q R S . T U V W (dou ble u) X Y Z . <b>.</b>, \"\n        +\"<b>Now</b> I've said my A B C's. Tell me what you think of me., Now <b>I've</b> said my A B C's. Tell me what you think of me., Now I've <b>said</b> my A B C's. Tell me what you think of me., Now I've said <b>my</b> A B C's. Tell me what you think of me., Now I've said my \"\n        +\"<b>A</b> B C's. Tell me what you think of me., Now I've said my A <b>B</b> C's. Tell me what you think of me., Now I've said my A B <b>C's.</b> Tell me what you think of me., Now I've said my A B C's. <b>Tell</b> me what you think of me., Now I've said my A B C's. Tell \"\n        +\"<b>me</b> what you think of me., Now I've said my A B C's. Tell me <b>what</b> you think of me., Now I've said my A B C's. Tell me what <b>you</b> think of me., Now I've said my A B C's. Tell me what you <b>think</b> of me., Now I've said my A B C's. Tell me what you think \"\n        +\"<b>of</b> me., Now I've said my A B C's. Tell me what you think of <b>me.</b>]\";\n        assertEquals(expected,staffs);  \n    }\n    \n    @Test // This test covers input: contains requirements + other_fields, field_composer, field_default_length, field_meter, field_tempo\n    // parsable, return: Piece object, voices: 1 voice, lyrics: no lyrics, comments: does not contain\n    public void testParseLittleNightSong() throws UnableToParseException  {\n        String input = \"X:1\\n\" + \n                \"T:Little Night Music Mvt. 1\\n\" + \n                \"C:Wolfgang Amadeus Mozart\\n\" + \n                \"Q:1/4=140\\n\" + \n                \"M:4/4\\n\" + \n                \"L:1/8\\n\" + \n                \"K:G\\n\" + \n                \"[D2B2g2]z d g2z d | g d g b d'2 z2 | c'2z a c'2z a | c' a f a d2 z2 |\\n\" + \n                \"[DBg]z g3 b a g | g f f3 a c' f | a g g3 b a g | g f f3 a c' f |\\n\" + \n                \"g g f e1/2f/2 g g a g/a/ | b b c' b/c'/ d'2 z2 | d4 e4 | c2 c2 B2 B2 |\\n\" + \n                \"A2 A2 G F E F | G z A z B z z2  | d4 e4 | dccc cBBB | BAAA GFEF | \\n\" + \n                \"[G4G,4] [GG,] G1/3F1/3G1/3 AF | B4 B B/3A/3B/3 c A | d4 e2 f2 |\\n\" + \n                \"g2 a2 b2 ^c'2 | d'3 a ^c'3/2 a/ c'3/2 a/ | d'3 a ^c'3/2 a/ c'3/2 a/ | \\n\" + \n                \"d' [d'2f2] [d'2f2] [d'2f2] [d'f] | d' [d'2e2] [d'2e2] [d'2e2] [d'e] | \\n\" + \n                \"[^c'e] a d' a c' a d' a | ^c' A A A A2 z2 | \\n\" + \n                \"a3 g/3f/3e/3 d z b z | g z e z a z z2 | f3 e/3d/3^c/3 B z g z | f4 e2 z2 |\\n\" + \n                \"z aaa aaaa | aaaa aab^c' | ^c'd' z b b a z ^c | d2 z a d'^c'ba | \\n\" + \n                \"b a z a a a a a | b a z a d' ^c' b a |\\n\" + \n                \"b a z a a a a a | b a z2 [b3B3] a/3g/3f/3 | g2 z2 [a3A3] g/3f/3e/3 |\\n\" + \n                \"f2 z2 b ^c'/d'/ c' b | b a f a a g f e | d2 z a d' ^c' b a | b a z a a a a a |\\n\" + \n                \"b a z a d' ^c' b a | b a z a a a a a | b a z2 [b3B3] a/3g/3f/3 |\\n\" + \n                \"g2 z2 [a3A3] g/3f/3e/3 | f2 z2 b ^c'/d'/ c' b | b a f a a g f e |\\n\" + \n                \"d A B ^c d d e d/e/ | \\n\" + \n                \"f ^c d e f f g f/g/ | a a ^a ^g/a/ b2 z2 | B3 e d ^c B A | d z f z d z z2 |\\n\";\n        final Piece p = PieceParser.parse(input);\n        assertEquals(\"index doesn't match\",1,p.getKaraokeIndex());\n        assertEquals(\"title doesn't match\",\"Little Night Music Mvt. 1\",p.getTitle());\n        assertEquals(\"composer doesn't match\", \"Wolfgang Amadeus Mozart\",p.getComposer());\n        assertEquals(\"key doesn't match\",\"G\",p.getKey()); \n        assertTrue(\"meter doesn't match\", \"4/4\".equals(p.getMeter()));\n        assertTrue(\"note length doesn't match\",1.0/8.0==p.getNoteLength());\n        assertTrue(\"tempo doesn't match\",140==p.getTempo());\n        assertTrue(\"tempo note length\", 1/4.0==p.getTempoNoteLength()); \n        String staffs = p.getStaffs(); \n        // System.out.println(\"staffs \" + staffs);\n        String expected = \"0:\\n[| [D2 B2 G2](2) z1 D1 G2 z1 D1 G1 D1 G1 B1 D2 z2 C2 z1 A1 C2 z1 A1 C1 A1 F1 A1 D2 z2 [D1 B1 G1](1) z1 G3 B1 A1 G1 G1 F1 F3 A1 C1 F1 A1 G1 G3 B1 A1 G1 G1 F1 F3 A1 C1 F1 G1 G1 F1 E1/2 F1/2 G1 G1 A1 G1/2 A1/2 B1 B1 C1 B1/2 C1/2 D2 z2 D4 E4 C2 C2 \"\n        +\"B2 B2 A2 A2 G1 F1 E1 F1 G1 z1 A1 z1 B1 z1 z2 D4 E4 D1 C1 C1 C1 C1 B1 B1 B1 B1 A1 A1 A1 G1 F1 E1 F1 [G4 G4](4) [G1 G1](1) G1/3 F1/3 G1/3 A1 F1 B4 B1 B1/3 A1/3 B1/3 C1 A1 D4 E2 F2 G2 A2 B2 C2 D3 A1 C3/2 A1/2 C3/2 A1/2 D3 A1 C3/2 A1/2 C3/2 A1/2 D1 [D2 F2](2) [D2 F2](2) [D2 F2](2) [D1 F1](1) D1 [D2 E2](2) \"\n        +\"[D2 E2](2) [D2 E2](2) [D1 E1](1) [C1 E1](1) A1 D1 A1 C1 A1 D1 A1 C1 A1 A1 A1 A2 z2 A3 G1/3 F1/3 E1/3 D1 z1 B1 z1 G1 z1 E1 z1 A1 z1 z2 F3 E1/3 D1/3 C1/3 B1 z1 G1 z1 F4 E2 z2 z1 A1 A1 A1 A1 A1 A1 A1 A1 A1 A1 A1 A1 A1 B1 C1 C1 D1 z1 B1 B1 A1 z1 \"\n        +\"C1 D2 z1 A1 D1 C1 B1 A1 B1 A1 z1 A1 A1 A1 A1 A1 B1 A1 z1 A1 D1 C1 B1 A1 B1 A1 z1 A1 A1 A1 A1 A1 B1 A1 z2 [B3 B3](3) A1/3 G1/3 F1/3 G2 z2 [A3 A3](3) G1/3 F1/3 E1/3 F2 z2 B1 C1/2 D1/2 C1 B1 B1 A1 F1 A1 A1 G1 F1 E1 D2 z1 A1 D1 C1 B1 A1 B1 A1 z1 A1 \"\n        +\"A1 A1 A1 A1 B1 A1 z1 A1 D1 C1 B1 A1 B1 A1 z1 A1 A1 A1 A1 A1 B1 A1 z2 [B3 B3](3) A1/3 G1/3 F1/3 G2 z2 [A3 A3](3) G1/3 F1/3 E1/3 F2 z2 B1 C1/2 D1/2 C1 B1 B1 A1 F1 A1 A1 G1 F1 E1 D1 A1 B1 C1 D1 D1 E1 D1/2 E1/2 F1 C1 D1 E1 F1 F1 G1 F1/2 G1/2 A1 A1 A1 G1/2 A1/2 B2 z2 B3 E1 D1 C1 B1 A1 D1 z1 F1 z1 D1 z1 z2|]\\n\"\n        +\"[<b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . ., . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . ., . . \"\n        +\"<b>.</b> . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . \"\n        +\"<b>.</b> . . . . . ., . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . ., . \"\n        +\"<b>.</b> . . . . . . . ., . . <b>.</b> . . . . . . ., . . . <b>.</b> . . . . . ., . . . . <b>.</b> . . . . ., . . . . . <b>.</b> . . . ., . . . . . . <b>.</b> . . ., . . . . . . . <b>.</b> . ., . . . . . . . . <b>.</b> ., . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . ., . \"\n        +\"<b>.</b> . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . ., . . . . . <b>.</b> . . . . . . . ., . . . . . . <b>.</b> . . . . . . ., . . . . . . . <b>.</b> . . . . . ., . . . . . . . . \"\n        +\"<b>.</b> . . . . ., . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b>, <b>.</b> . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . \"\n        +\"<b>.</b> . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . \"\n        +\"<b>.</b> ., . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . <b>.</b>, \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . . . . . ., . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . ., . . . . . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . ., . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . ., . <b>.</b> . . . . . . ., . . <b>.</b> . . . . . ., . . . <b>.</b> . . . . ., . . . . <b>.</b> . . . ., . . . . . <b>.</b> . . ., . . . . . . \"\n        +\"<b>.</b> . ., . . . . . . . <b>.</b> ., . . . . . . . . <b>.</b>, <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . ., . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . ., . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . ., . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . ., . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . ., . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . ., . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . ., . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>]\";\n        assertEquals(expected,staffs);  \n    }\n    \n    @Test // This test covers input: contains requirements + other_fields, field_composer, field_default_length, field_meter, field_tempo\n    // parsable, return: Piece object, voices: 1 voice, lyrics: lyrics for every line of notes, comments: does not contain, whitespace: extra white space\n    public void testParseSample3Song() throws UnableToParseException  {\n        String input = \"X:4\\n\" + \n                \"T:voices\\n\" + \n                \"V:1\\n\" + \n                \"V:2\\n\" + \n                \"V:3\\n\" + \n                \"K:Cm\\n\" + \n                \"%\\n\" + \n                \"V: 1\\n\" + \n                \"C\\n\" + \n                \"V: 2\\n\" + \n                \"E\\n\" + \n                \"V: 3\\n\" + \n                \"G\\n\";\n        final Piece p = PieceParser.parse(input);\n        assertEquals(\"index doesn't match\",4,p.getKaraokeIndex());\n        assertEquals(\"title doesn't match\",\"voices\",p.getTitle());\n        assertEquals(\"key doesn't match\",\"Cm\",p.getKey()); \n        assertTrue(\"meter doesn't match\", \"4/4\".equals(p.getMeter()));\n        assertTrue(\"note length doesn't match\",1.0/8.0==p.getNoteLength());\n        assertTrue(\"tempo doesn't match\",100==p.getTempo());\n        assertTrue(\"tempo note length\", 1/8.0==p.getTempoNoteLength()); \n        String staffs = p.getStaffs(); \n        // System.out.println(\"staffs \" + staffs);\n        assertEquals(\"0:\\n[| C1|]\\n\" + \n                \"[<b>.</b>]\\n\" + \n                \"1:\\n\" + \n                \"[| E1|]\\n\" + \n                \"[<b>.</b>]\\n\" + \n                \"2:\\n\" + \n                \"[| G1|]\\n\" + \n                \"[<b>.</b>]\",staffs);  \n    }\n    \n    @Test // This test covers input: contains requirements + other_fields, field_composer, field_default_length, field_meter, field_tempo\n    // parsable, return: Piece object, voices: 1 voice, lyrics: lyrics for some lines of notes, comments: does not contain, whitespace: extra white space\n    public void testParseWaxiesSong() throws UnableToParseException  {\n        String input = \"X:2167\\n\" + \n                \"T:Waxie's Dargle\\n\" + \n                \"M:4/4\\n\" + \n                \"L:1/8\\n\" + \n                \"Q:1/4=180\\n\" + \n                \"K:G\\n\" + \n                \" gf|e2dc B2A2|B2G2 E2D2|G2G2 GABc|d4 B2gf|\\n\" + \n                \"w: Sa-ys my au-l' wan to your aul' wan Will~ye come to the Wa-x-ies dar-gle? Sa-ys\\n\" + \n                \"e2dc B2A2|B2G2 E2G2|F2A2 D2EF|G2z2 G4|\\n\" + \n                \"B2d2 e2f2|g2d2 BAG2|Bcd2 e2f2|g4 f2gf|\\n\" + \n                \"w: I'll go down to Mon-to to-w-n To see un-cle Mc-Ar-dle A-nd\\n\" + \n                \"e2dc B2A2|B2G2 E2G2|F2A2 D2EF|G2z2 G4|\\n\" + \n                \"w: ask him for a half a crown For~to go to the Wa-x-ies dar-gle\\n\";\n        final Piece p = PieceParser.parse(input);\n        assertEquals(\"index doesn't match\",2167,p.getKaraokeIndex());\n        assertEquals(\"title doesn't match\",\"Waxie's Dargle\",p.getTitle());\n        assertEquals(\"key doesn't match\",\"G\",p.getKey()); \n        assertTrue(\"meter doesn't match\", \"4/4\".equals(p.getMeter()));\n        assertTrue(\"note length doesn't match\",1.0/8.0==p.getNoteLength());\n        assertTrue(\"tempo doesn't match\",180.0==p.getTempo());\n        assertTrue(\"tempo note length\", 1/4.0==p.getTempoNoteLength()); \n        String staffs = p.getStaffs(); \n        // System.out.println(\"staffs \" + staffs);\n        String expected = \"0:\\n[| G1 F1 E2 D1 C1 B2 A2 B2 G2 E2 D2 G2 G2 G1 A1 B1 C1 D4 B2 G1 F1 E2 D1 C1 B2 A2 B2 G2 E2 G2 F2 A2 D2 E1 F1 G2 z2 G4 B2 D2 E2 F2 G2 D2 B1 A1 G2 B1 C1 D2 E2 F2 G4 F2 G1 F1 E2 D1 C1 B2 A2 B2 G2 E2 G2 F2 A2 D2 E1 F1 G2 z2 G4|]\\n\"\n        +\"[<b>Sa</b>ys my aul' wan to your aul' wan Will ye come to the Waxies dargle? Says, Sa<b>ys</b> my aul' wan to your aul' wan Will ye come to the Waxies dargle? Says, Says <b>my</b> aul' wan to your aul' wan Will ye come to the Waxies dargle? Says, Says my \"\n        +\"<b>au</b>l' wan to your aul' wan Will ye come to the Waxies dargle? Says, Says my au<b>l'</b> wan to your aul' wan Will ye come to the Waxies dargle? Says, Says my aul' <b>wan</b> to your aul' wan Will ye come to the Waxies dargle? Says, Says my aul' wan \"\n        +\"<b>to</b> your aul' wan Will ye come to the Waxies dargle? Says, Says my aul' wan to <b>your</b> aul' wan Will ye come to the Waxies dargle? Says, Says my aul' wan to your <b>aul'</b> wan Will ye come to the Waxies dargle? Says, Says my aul' wan to your aul' \"\n        +\"<b>wan</b> Will ye come to the Waxies dargle? Says, Says my aul' wan to your aul' wan <b>Will ye</b> come to the Waxies dargle? Says, Says my aul' wan to your aul' wan Will ye <b>come</b> to the Waxies dargle? Says, Says my aul' wan to your aul' wan Will ye come \"\n        +\"<b>to</b> the Waxies dargle? Says, Says my aul' wan to your aul' wan Will ye come to <b>the</b> Waxies dargle? Says, Says my aul' wan to your aul' wan Will ye come to the <b>Wa</b>xies dargle? Says, Says my aul' wan to your aul' wan Will ye come to the Wa\"\n        +\"<b>x</b>ies dargle? Says, Says my aul' wan to your aul' wan Will ye come to the Wax<b>ies</b> dargle? Says, Says my aul' wan to your aul' wan Will ye come to the Waxies <b>dar</b>gle? Says, Says my aul' wan to your aul' wan Will ye come to the Waxies dar\"\n        +\"<b>gle?</b> Says, Says my aul' wan to your aul' wan Will ye come to the Waxies dargle? <b>Sa</b>ys, Says my aul' wan to your aul' wan Will ye come to the Waxies dargle? Sa<b>ys</b>, <b>.</b> . . . . . . . . . . . . . . . ., . <b>.</b> . . . . . . . . . . . . . . ., . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . ., . . . <b>.</b> . . . . . . . . . . . . ., . . . . <b>.</b> . . . . . . . . . . . ., . . . . . <b>.</b> . . . . . . . . . . ., . . . . . . <b>.</b> . . . . . . . . . ., . . . . . . . <b>.</b> . . . . . . . . ., . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . ., . . . . . . . . . <b>.</b> . . . . . . ., . . . . . . . . . . <b>.</b> . . . . . ., . . . . . . . . . . . <b>.</b> . . . . ., . . . . . . . . . . . . <b>.</b> . . . ., . . . . . . . . . . . . . <b>.</b> . . ., . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . ., . . . . . . . . . . . . . . . <b>.</b> ., . . . . . . . . . . . . . . . . <b>.</b>, <b>I'll</b> go down to Monto town To see uncle McArdle And, I'll <b>go</b> down to Monto town To see uncle McArdle And, I'll go <b>down</b> to Monto town To see uncle McArdle And, I'll go down \"\n        +\"<b>to</b> Monto town To see uncle McArdle And, I'll go down to <b>Mon</b>to town To see uncle McArdle And, I'll go down to Mon<b>to</b> town To see uncle McArdle And, I'll go down to Monto <b>to</b>wn To see uncle McArdle And, I'll go down to Monto to\"\n        +\"<b>w</b>n To see uncle McArdle And, I'll go down to Monto tow<b>n</b> To see uncle McArdle And, I'll go down to Monto town <b>To</b> see uncle McArdle And, I'll go down to Monto town To <b>see</b> uncle McArdle And, I'll go down to Monto town To see \"\n        +\"<b>un</b>cle McArdle And, I'll go down to Monto town To see un<b>cle</b> McArdle And, I'll go down to Monto town To see uncle <b>Mc</b>Ardle And, I'll go down to Monto town To see uncle Mc<b>Ar</b>dle And, I'll go down to Monto town To see uncle McAr\"\n        +\"<b>dle</b> And, I'll go down to Monto town To see uncle McArdle <b>A</b>nd, I'll go down to Monto town To see uncle McArdle A<b>nd</b>, <b>ask</b> him for a half a crown For to go to the Waxies dargle ., ask <b>him</b> for a half a crown For to go to the Waxies dargle ., ask him \"\n        +\"<b>for</b> a half a crown For to go to the Waxies dargle ., ask him for <b>a</b> half a crown For to go to the Waxies dargle ., ask him for a <b>half</b> a crown For to go to the Waxies dargle ., ask him for a half <b>a</b> crown For to go to the Waxies dargle ., ask him for a half a \"\n        +\"<b>crown</b> For to go to the Waxies dargle ., ask him for a half a crown <b>For to</b> go to the Waxies dargle ., ask him for a half a crown For to <b>go</b> to the Waxies dargle ., ask him for a half a crown For to go <b>to</b> the Waxies dargle ., ask him for a half a crown For to go to \"\n        +\"<b>the</b> Waxies dargle ., ask him for a half a crown For to go to the <b>Wa</b>xies dargle ., ask him for a half a crown For to go to the Wa<b>x</b>ies dargle ., ask him for a half a crown For to go to the Wax<b>ies</b> dargle ., ask him for a half a crown For to go to the Waxies \"\n        +\"<b>dar</b>gle ., ask him for a half a crown For to go to the Waxies dar<b>gle</b> ., ask him for a half a crown For to go to the Waxies dargle <b>.</b>]\";\n\n        assertEquals(expected, staffs);  \n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282927,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/parser/StaffParserTest.java",
    "data": "package karaoke.parser;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.Music;\nimport karaoke.sound.Note;\nimport karaoke.sound.Staff;\n/**\n * @category no_didit\n */\npublic class StaffParserTest {\n    /* Partition:\n     *     contains: accidentals, repeats, rests, chords, tuplets, repeats \n     *     repeats: 0, 1, >1\n     *          repeat back to: opening repeat, end of last major section,\n     *          beginning of the piece\n     *          alternate endings: true, false\n     *     note length: < 1 default note length, 1, > 1 default note length \n     *     lines of music: 1, 2, >2\n     *     lines of lyrics: 1, 2, >2\n     *          # lyric lines = # music lines: true, false\n     */\n    \n    @Test\n    public void testParseRepeatNotesOnly() throws  UnableToParseException {\n        List<String> inputNotesList = Arrays.asList(\"C D E F |: G A B C :|\");\n        List<String> inputLyricList = Arrays.asList(\"Syll-a-ble a lot of syll-a-bles ma-ny syll-a-bles\");\n        Staff staff = new Staff(\"K:C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputNotesList, inputLyricList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'D', 1));\n        outputMusicList.add(new Note( 'E', 1));\n        outputMusicList.add(new Note( 'F', 1));\n\n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n\n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n        \n        // System.out.println(\"lyrics: \" + actual.getLyrics());\n    }\n    \n    @Test\n    public void testParseNotesStaffNoFirstRepeat() throws  UnableToParseException {\n        List<String> inputNotesList = Arrays.asList(\"[| C D E F ||\", \"G A B C :|\");\n        Staff staff = new Staff(\"K:C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputNotesList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'D', 1));\n        outputMusicList.add(new Note( 'E', 1));\n        outputMusicList.add(new Note( 'F', 1));\n\n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n\n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    @Test\n    public void testparseNoFirstRepeat2() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"[| C D E F |]\",  \"G A B C :|\");\n        Staff staff = new Staff(\"K:C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'D', 1));\n        outputMusicList.add(new Note( 'E', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        \n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    @Test\n    public void testParseNotesStaffNoFirstRepeat3() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"[| C D E F |] G A B C :|\");\n        Staff staff = new Staff(\"K:C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'D', 1));\n        outputMusicList.add(new Note( 'E', 1));\n        outputMusicList.add(new Note( 'F', 1));\n\n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    //glass box test\n    @Test\n    public void testParseNotesStaffNoFirstRepeatMajorEnding() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"[| C D E F |] G A B C :| B A B B |]\");\n        Staff staff = new Staff(\"K:C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'D', 1));\n        outputMusicList.add(new Note( 'E', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        \n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n  //glass box test\n    @Test\n    public void testParseNotesStaffMultipleRepeats() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"[| |: C D E F :| G A B C |] B A B B :|\");\n        Staff staff = new Staff(\"K:C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        String expected = \"C D E F \"\n                + \"C D E F \"\n                + \"G A B C \"\n                + \"B A B B\"\n                + \"B A B B\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'D', 1));\n        outputMusicList.add(new Note( 'E', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        \n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'D', 1));\n        outputMusicList.add(new Note( 'E', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        \n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        \n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        \n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        \n        \n        // System.out.println(actual.getMusic());\n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    @Test\n    public void testParseNotesStaffAlternateEnding() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"|: B A C F\", \"|[1 E G F A\", \"| B C D F\", \":|[2 B B A B |]\");\n        Staff staff = new Staff(\"K:C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        //String expected = \"B A C F E F G A B C D F B A C F B B A B\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        \n        outputMusicList.add(new Note( 'E', 1));\n        outputMusicList.add(new Note( 'G', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        \n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'D', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        \n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        \n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    }\n        \n    @Test(expected=AssertionError.class)\n    public void testAssertionsEnabled() {\n        assert false; // make sure assertions are enabled with VM argument: -ea\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282928,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/ChordTest.java",
    "data": "package karaoke.sound;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.Music.MusicKeys;\n\n/**\n * @category no_didit\n */\npublic class ChordTest extends MusicTest{\n    /*\n     * Testing strategy\n     *      We begin by populating chord objects through the music parser, and testing that the rep invariants\n     *      assert the specification of chord as defined in the Karaoke spec. We then test the various\n     *      chord methods, and class specific methods. (i.e. getNotes()) that allow us to observe the properties of\n     *      chord objects from producer methods. Finally, we test the concrete implementations of the more complex\n     *      music interface methods: modifyKey() w/ and w/out naturals, addToMidiPlayer(), and transpose. \n     * \n     *      * parenthesis in input partitions indicate (default), other, other\n     * \n     * input partitions:\n     *      numNotes: 0, 1, n\n     *      type of Music objects: Notes, tuplets, rest, accidentals, \n     *      containsNatural: true, (false)\n     * \n     * methods:\n     *      Constructors (2)\n     *      isRest() - output false\n     *      numNotes() \n     *          output - 0, 1, n\n     *      duration() \n     *          output - 1/n, 1, n\n     *      changeDuration()\n     *          output - double 0, 1, n\n     *      getNotes()\n     *          -output array of length 1, 2, n\n     *      addToMidiPlayer()\n     *          - input: startBeat: 0, 1, >= 2, tupletSpec: 0, 1, >= 2 \n     *          - output: midiData (in)valid, size: 0, 1, 1<x<5,>5 \n     *      modifyKey()\n     *          - input: (valid) key \n     *          - output: Chord, other type of Music \n     *      toString()\n     *          - input: chord with 0, 1, n notes \n     *      transpose()\n     *          - input: semiTonesup: 0, 1, n notes \n     *          - output: Chord, other type of Music\n     */\n    \n    private static double epsilon = .0001;\n\n\n     // Covers: constructor\n     // inputs: invalidSyntax - null input\n     // expect Assertion Error\n    @Test(expected=AssertionError.class)\n    public void testEmptyChord() throws UnableToParseException{\n        Music[] notes = new Music[1];\n        new Chord(notes);\n    }\n\n\n\n    // Covers: constructor, isRest(), numNotes(), duration(), getNotes(), equals()\n    // inputs:\n    //       chord: numNotes - 1; c2: numNotes - 1;\n    // outputs:\n    //      constructor(): Success - chord object, isRest(): false, numNotes(): 1\n    //      duration(): 1/n, getNotes(): Music[], equals(): false;\n\n     @Test\n     public void testBasicChord() throws UnableToParseException{\n         Music[] notes = new Music[1];\n         notes[0] = Music.parseMusicString(\"A/2\");\n\n        Chord chord = new Chord(notes);\n        assertFalse(chord.isRest());\n        assertTrue(chord.numNotes() == 1);\n        assertTrue(chord.duration() == .5);\n        assertArrayEquals(chord.getNotes(), notes);\n\n        notes[0] = Music.parseMusicString(\"B\");\n        Chord c2 = new Chord(notes); // checks for aliasing\n\n        assertFalse(chord.equals(c2));\n     }\n\n     @Test // This test covers Chord constructor \n     // numNotes: 3, 5 containsNatural: true, false typesOfMusic: contains normal notes with accidentals, tuplets\n     // tests failure of method \n     @Override\n     public void testChordInvariant() throws UnableToParseException{\n         boolean test1 = false, test2 = false, test3 = false;\n \n         Music[] chordWithRestInput = Music.parseLine(\"E2z2G,\");\n         Music[] chordWithTupletInput = Music.parseLine(\"(3AAA EG\");\n         Music[] complexChordInput = Music.parseLine(\"E(2AB zG\");\n \n         try {\n             new Chord(chordWithRestInput);\n         } catch (AssertionError e) {\n             test1 = true;\n         }\n         try {\n             new Chord(chordWithTupletInput);\n         } catch (AssertionError e) {\n             test2 = true;\n         }\n         try {\n             new Chord(complexChordInput);\n         } catch (AssertionError e) {\n             test3 = true;\n         }\n \n         assertTrue(\"expected all tests to pass\", test1 && test2 && test3);\n    }\n\n     @Test // This test covers the behavior of a chord with naturals and Chord constructor \n     // numNotes() output: > 2, modifyKey() input: valid key, getNotes output: size 2 \n     public void testChordObeysNaturals() throws UnableToParseException{\n         Music[] notes = new Music[3];\n         notes[0] = Music.parseMusicString(\"A\");\n         notes[1] = Music.parseMusicString(\"=C\");\n         notes[2] = Music.parseMusicString(\"E\");\n\n         Music[] expected = new Music[3];\n         expected[0] = Music.parseMusicString(\"^A\");\n         expected[1] = Music.parseMusicString(\"C\");\n         expected[2] = Music.parseMusicString(\"^E\");\n\n        Chord chord = new Chord(notes);\n        assertEquals(chord.numNotes(), 3);\n\n        chord = (Chord) chord.modifyKey(MusicKeys.CS);\n        Music[] newNotes = chord.getNotes();\n\n        assertArrayEquals(expected, newNotes);\n     }\n\n     @Test // This test covers Chord constructor, modifyKey input: valid key note, output: Chord object\n     // getNotes: output: size 3\n     public void testChordObeysKey() throws UnableToParseException {\n        Music[] notes = new Music[3];\n        notes[0] = Music.parseMusicString(\"A\");\n        notes[1] = Music.parseMusicString(\"C\");\n        notes[2] = Music.parseMusicString(\"^E\");\n\n        Music[] expected = new Music[3];\n        expected[0] = Music.parseMusicString(\"A\");\n        expected[1] = Music.parseMusicString(\"C\");\n        expected[2] = Music.parseMusicString(\"E\");// should be flattened\n\n       Chord chord = new Chord(notes);\n\n       chord = (Chord) chord.modifyKey(MusicKeys.Bb);\n       Music[] newNotes = chord.getNotes();\n\n       assertArrayEquals(expected, newNotes);\n     }\n\n\n     @Test // This test covers transpose() method input: semiTonesup: -1, 1, n notes, output: Chord \n     // changeDuration() input: -1, 2 \n     public void testTransforms() throws UnableToParseException {\n        Music[] notes = new Music[3];\n        notes[0] = Music.parseMusicString(\"^B\");\n        notes[1] = Music.parseMusicString(\"^D\");\n        notes[2] = Music.parseMusicString(\"^F\");\n\n        Music[] expected = new Music[3];\n        expected[0] = Music.parseMusicString(\"B\");\n        expected[1] = Music.parseMusicString(\"D\");\n        expected[2] = Music.parseMusicString(\"F\");\n\n       Chord chord = new Chord(notes);\n\n       chord = (Chord) chord.transpose(-1);\n       Music[] newNotes = chord.getNotes();\n\n       assertArrayEquals(expected, newNotes);\n       assertEquals(1, chord.duration(), epsilon);\n\n       boolean invalidDurationTest = false;\n       try {\n           chord.changeDuration(-1);\n\n       } catch(AssertionError e ) {\n            invalidDurationTest = true;\n       }\n\n       chord = (Chord) chord.changeDuration(2);\n\n       assertTrue(\"expected -1 to be an invalid duration\", invalidDurationTest);\n       assertEquals(2, chord.duration(), epsilon);\n       assertFalse(chord.getNotes()[0].duration() == chord.getNotes()[1].duration());\n     }\n\n\n\n     @Test // This test covers toString input: 3 notes \n     public void testToString() throws UnableToParseException{\n\n        Music[] notes = new Music[3];\n        notes[0] = Music.parseMusicString(\"^B/2\");\n        notes[1] = Music.parseMusicString(\"^D\");\n        notes[2] = Music.parseMusicString(\"^F\");\n        Chord chord = new Chord(notes);\n\n        \n         assertEquals(\"[B1/2 D1 F1](1/2)\", chord.toString());\n     }\n\n     @Test // This test covers add to MidiSequencePlayer\n     public void testAddToMidi() throws UnableToParseException{\n        Chord chord = (Chord) Music.parseMusicString(\"[A/2^CG]\");\n        List<Double> midiNotes = chord.addToMidiPlayer(0);\n        \n        assertEquals(9, midiNotes.size());\n        assertEquals(9, midiNotes.get(1), epsilon);\n        assertEquals(.5, midiNotes.get(2), epsilon);\n        assertEquals(1, midiNotes.get(4), epsilon);\n        assertEquals(1, midiNotes.get(5), epsilon);\n        assertEquals(7, midiNotes.get(7), epsilon);\n        assertEquals(1, midiNotes.get(8), epsilon);\n     }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282929,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/MusicTest.java",
    "data": "package karaoke.sound;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.Music.MusicKeys;\n\n/**\n * Tests the methods of the music class. Focuses on parseMusicString\n *\n * @category no_didit\n */\n\npublic class MusicTest {\n    \n    private static double epsilon = .0001;\n    \n    /* parseMusicString test partition\n     * \n     * General Testing Strategy\n     *      Start by testing the Musci.Parse() method on simple inputs and,\n     * concrete variants. Then build to more complex structures and variants\n     * with duration modifiers. Assert the valididty of parser output by testing\n     * the variosu methods of the Music ADT.\n     * \n     * concrete variant: Rest, Note, Chord, Tuplet\n     * duration:\n     *      numerator digit: null, 0, 1, n\n     *      denominator digit: null, 0, 1, n\n     *      slash present: true, false     \n     * \n     * \n     * \"A chord may not contain any rests or tuplets.\"\n     * \n     * \n     * parseLine()\n     *     inputs\n     *              numEles: 0, 1, n\n     *              validInpus: true, false\n     *      ouptuts:\n     *         success - list of music eles\n     *         failure - throws assertion error, throws UnableToParseException\n     * \n     * \n     * \n     * keyToEnum():\n     *      inputs\n     *          inValidKeys: true, false;\n     *      outputs:\n     *          MusicKeys enum\n     * \n     * \n     * numAccidentals():\n     *      inputs\n     *          MusicKeys Enum\n     *      outputs\n     *          int [-7, 7]\n     * \n     * baseNotesToModify():\n     *      inputs \n     *          int abs < 8 abs >=8\n     *      outputs:\n     *          assertion error if input is 8+\n     *          char[] of proper accidentals otherwise\n     * \n     */\n\n     //rest tests\n    \n    //covers\n    // numerator digit n, slash present false, Rest 1\n    //  Music.ParseMusicString() - Music obejct\n    //  Music.toString() - String\n    @Test\n    public void testLongRest() throws UnableToParseException {\n        String input = \"z64\";\n        Music output = Music.parseMusicString(input);\n        //System.out.println(output.toString());\n        assertEquals(\"z64\", output.toString());\n        assertEquals(64, output.duration(), epsilon);\n    }\n    \n    //Covers:\n    // nurator digit 1, demoninator digit 1, slash present true, Rest 1\n    // tests methods, Music.parseMusicString()\n    // rest.duration 1/n\n    @Test\n    public void testHalfRest() throws UnableToParseException {\n        String input = \"z1/2\";\n        Music output = Music.parseMusicString(input);\n        \n        assertEquals(.5, output.duration(), epsilon);\n    }\n\n    //covers\n    // numerator digit null, denominaor digit 1, slash present true, Rest 1\n    // tests methods, Music.parseMusicString()\n    // Rst.Duration 1/n\n    @Test\n    public void testNoNumeratorRest() throws UnableToParseException {\n        String input = \"z/2\";\n        Music output = Music.parseMusicString(input);\n        \n        assertEquals(.5, output.duration(), epsilon);\n    }\n\n    //covers\n    //numerator digit null, 0, denominator digit 1, 0, Note 1\n    // tests Music.parseMusicElement() - Success\n    // Note Contructor() throws assertion error\n    @Test\n    public void testZeroLengthModifiers() throws UnableToParseException {\n        boolean test1 = false, test2 = false, test3 = false;\n\n        String numZeroInput = \"D0/1\";\n        String denomZeroInput = \"D0/1\";\n        String noNumSlashDenomZeroInput = \"D/0\";\n\n        try {\n            Music.parseMusicString(numZeroInput);\n        } catch (AssertionError e) {\n            test1 = true;\n        }\n        try {\n            Music.parseMusicString(denomZeroInput);\n        } catch (AssertionError e) {\n            test2 = true;\n        }\n        try {\n            Music.parseMusicString(noNumSlashDenomZeroInput);\n        } catch (AssertionError e) {\n            test3 = true;\n        }\n\n        assertTrue(\"expected all tests to pass\", test1 && test2 && test3);\n\n    }\n\n\n    //invariant: a chord may not contain a rest or tuplet\n    //covers\n    // chordWithRest: numeratorDigit null, n, hasOctaves, Chord 1, Notes n, rest 1\n    // chordWithTuplet: numeratorDigit null, n, Tuplet 1, Chord 1, Notes n\n    // complex chord: Note n , Tuplet 1, rest 1 Chord 1\n    // tests methods Music.parseMusicElement() - Music\n    @Test\n    public void testChordInvariant() throws UnableToParseException{\n        boolean test1 = false, test2 = false, test3 = false;\n\n        String chordWithRestInput = \"[E2z2G,]\";\n        String chordWithTuplet = \"[(3AAAEG]\";\n        String complexChord = \"[E(2ABzG]\";\n\n        try {\n            Music.parseMusicString(chordWithRestInput);\n        } catch (AssertionError e) {\n            test1 = true;\n        }\n        try {\n            Music.parseMusicString(chordWithTuplet);\n        } catch (UnableToParseException e) {\n            test2 = true;\n        }\n        try {\n            Music.parseMusicString(complexChord);\n        } catch (UnableToParseException e) {\n            test3 = true;\n        }\n\n        assertTrue(\"expected all tests to pass\", test1 && test2 && test3);\n   }\n    \n    \n    \n    //Note tests\n    \n    /*\n     * octaves up: -2, -1, 0, 1, 2\n     * sharps: 0, 1, 2\n     * flats: 0, 1, 2\n     * natural present: true, false\n     */\n    \n     //covers\n     // Note 1, sharps 2, octaves 2, slashPresent\n     // tests methods: duration() - 1/n , Music.parseMusicElement()\n    @Test\n    public void testHighOctaveDoubleSharp() throws UnableToParseException {\n        String input = \"^^c\\'\\'/\";\n        Music output = Music.parseMusicString(input);\n        \n        assertTrue(output instanceof Note);\n        Note outputNote = (Note) output;\n        // assertEquals(0, outputNote.getPitchValue(), epsilon);\n        assertEquals(.5, outputNote.duration(), epsilon);\n    }\n    \n    //Chord tests\n    // input: Note n, hasFlats 1 2, hasSharps 1 2, hasOctaves 1 2, numeratorDigit n, slashPresestn\n    // testMethods duration(), Music.parseMusicElement()\n    @Test\n    public void testFirstNoteShort() throws UnableToParseException {\n        String input = \"[__C,,/^^b\\'\\'5^a\\'9_D,14F]\";\n        Music output = Music.parseMusicString(input);\n        assertEquals(.5, output.duration(), epsilon);\n    }\n    \n    //Tuplet tests\n    //invariant: A tuplet may not contain rests, but it may contain chords.\n\n    //covers: Tuplet 1, tuplet spec 3, Note n, slashPresent\n    // testMethods:  Music.parseMusicElement()\n    @Test\n    public void testChordInATuplet() throws UnableToParseException {\n        String input = \"(3[_F,/GB]AC\";\n        Music output = Music.parseMusicString(input);\n        assertEquals(1.66666, output.duration(), epsilon);\n    }\n\n    // covers invariatn\n    // input tuplet spec 2, rest 1, note 1\n    // testMethods: Musci.parseMusicString\n    // TupletConstructor throws AssertionError\n    @Test (expected = AssertionError.class)\n    public void testRestInTuplet() throws UnableToParseException {\n        String input = \"(2Az\";\n        Music.parseMusicString(input);\n    }\n    // covers\n    // input tuplet spec 4, note 3\n    // testMethods: Music.parseMusicString\n    // TupletConstructor throws AssertionError\n    @Test (expected = AssertionError.class)\n    public void testFalseTupletPrefix() throws UnableToParseException {\n        String input = \"(4A^^f_C\";\n        Music.parseMusicString(input);\n    }\n\n    // covers\n    // input tuplet spec 4, note 3\n    // testMethods: Music.parseMusicString\n    // TupletConstructor throws AssertionError\n    @Test\n    public void testComplexTuplet() throws UnableToParseException {\n        String input = \"(4__A'/G/2[f/3_C]E,,5\";\n        Music output = Music.parseMusicString(input);\n        //System.out.print(output);\n    }\n\n/**\n * parseLine inputs\n * can contain music elemtns followeb by the following grammar variants \n *  |, |], [|, [1, [2 |: :|, \" \"\n * numMusicEles: 0, 1, n\n * \n */\n\n    //covers\n    //input numMusic eles 0\n    // testMethods: Music.parseLine()\n        @Test(expected=UnableToParseException.class)\n        public void testEmptyBarString() throws UnableToParseException{\n            String input = \"\";\n            Music.parseLine(input);\n        }\n\n    //covers\n    //input numMusicEles 1, numVariratns nm |:1, |] 1\n    // testMethods: Music.parseLine()\n    // outputs Music[] 1\n        @Test\n        public void testBarStringSingleton() throws UnableToParseException{\n            String input = \"|:e,,|]\";\n             Music note = Music.parseMusicString(\"e,,\");\n            Music[] notes = Music.parseLine(input);\n            assertEquals(notes.length, 1);\n            assertTrue(notes[0].equals(note));\n        }\n\n\n        //covers\n        // inptus, numMusicEles n, | 1, :|1, \" \" n\n        // output Music[] n\n        @Test\n        public void testBarStringMultiple() throws UnableToParseException{\n            String input = \"A [^^CD/2E/2] | f\\'\\'/2 G e:|\";\n            Music[] notes = Music.parseLine(input);\n            assertEquals(notes.length, 5);\n        }\n\n        //covers\n        // possuible keys to enum values\n        // outputs proper keys\n        @Test\n        public void testKeyToEnum() {\n\n            MusicKeys maj = Music.keyToEnum(\"Gb\");\n            MusicKeys maj2 = Music.keyToEnum(\"Db\");\n            MusicKeys maj3 = Music.keyToEnum(\"Bb\");\n            MusicKeys maj4 = Music.keyToEnum(\"C#\");\n            MusicKeys maj5 = Music.keyToEnum(\"F#\");\n            MusicKeys maj6 = Music.keyToEnum(\"B\");\n\n            assertEquals(maj, MusicKeys.FS);\n            assertEquals(maj2, MusicKeys.CS);\n            assertEquals(maj3, MusicKeys.Bb);\n            assertEquals(maj4, MusicKeys.CS);\n            assertEquals(maj5, MusicKeys.FS);\n            assertEquals(maj6, MusicKeys.B);\n\n            MusicKeys min = Music.keyToEnum(\"G#m\");\n            MusicKeys min2 = Music.keyToEnum(\"D#m\");\n            MusicKeys min3 = Music.keyToEnum(\"Bbm\");\n            MusicKeys min4 = Music.keyToEnum(\"Cm\");\n            MusicKeys min5 = Music.keyToEnum(\"F#m\");\n            MusicKeys min6 = Music.keyToEnum(\"Bm\");\n\n            assertEquals(min, MusicKeys.F);\n            assertEquals(min2, MusicKeys.C);\n            assertEquals(min3, MusicKeys.G);\n            assertEquals(min4, MusicKeys.A);\n            assertEquals(min5, MusicKeys.Eb);\n            assertEquals(min6, MusicKeys.Ab);\n\n            MusicKeys nonexistent1 = Music.keyToEnum(\"key\");\n            MusicKeys nonexistent2 = Music.keyToEnum(\"default\");\n            MusicKeys nonexistent3 = Music.keyToEnum(\"\");\n            assertEquals(nonexistent1, MusicKeys.C);\n            assertEquals(nonexistent2, MusicKeys.C);\n            assertEquals(nonexistent3, MusicKeys.C);\n\n        }\n\n        //covers\n        // asserts that this static metho returns the proper outputs in the correct order\n        // tests methods: baseNotesToModify()\n        @Test\n        public void testBasenotes() {\n            // assertEquals(\"expected 1 sharp\", 1, Music.baseNotesToModify(Music.numAccidentals(MusicKeys.F)));\n            // assertEquals(\"expected no sharps or flats\", 0, Music.baseNotesToModify(Music.numAccidentals(MusicKeys.C)));\n            char[] flats = Music.baseNotesToModify(Music.numAccidentals(MusicKeys.Eb));\n            char[] sharps = Music.baseNotesToModify(Music.numAccidentals(MusicKeys.CS));\n            assertEquals(\"expected 1st flast to be B\", 'B', flats[0] );\n            assertEquals(\"expected 2nd flat to be E\", 'E', flats[1] );\n            assertEquals(\"expected 3rd Flat to be A\", 'A', flats[2] );\n            assertEquals(\"expected  7 accidentals \", 7, sharps.length);\n            assertEquals(\"expected 1st sharp to be F\", 'F', sharps[0] );\n            assertEquals(\"expected 2nd sharp to be C\", 'C', sharps[1] );\n            assertEquals(\"expected 3rd sharp to be G\", 'G', sharps[2] );\n            assertEquals(\"expected 4th sharp to be D\", 'D', sharps[3] );\n            assertEquals(\"expected 5th sharp to be A\", 'A', sharps[4] );\n            assertEquals(\"expected 6th sharp to be E\", 'E', sharps[5] );\n            assertEquals(\"expected 7th sharp to be B\", 'B', sharps[6] );\n\n            assertEquals(\"expected 1 sharp\", 1, Music.baseNotesToModify(Music.numAccidentals(MusicKeys.F)).length);\n\n        }\n\n        //covers\n        // asserts the invairant in the specification of baseNotes to modify that tht numerical input must be \n        // abs < 8\n        @Test(expected=AssertionError.class)\n        public void testBaseNotesIllegalInput() {\n            Music.baseNotesToModify(19);\n        }\n\n\n        //covers modify key on Music objects\n        @Test\n        public void testChangeKeyNote() throws UnableToParseException {\n            Music fNote = Music.parseMusicString(\"F\");\n            Music fInG = fNote.modifyKey(MusicKeys.G);\n            Music fInC = fNote.modifyKey(MusicKeys.C);\n            // Music cNote = Music.parseMusicString(\"C\");\n            Music fInAbm = fNote.modifyKey(Music.keyToEnum(\"Abm\"));\n            assertFalse(fNote.equals(fInG));\n            assertTrue(fNote.equals(fInAbm));\n            assertTrue(fNote.equals(fInC));\n        }\n\n\n        // covers\n        //testMethods: addToMidiPlayer List<Double>\n    @Test\n    public void testAddToMidiPlayer() throws UnableToParseException {\n        Music chord = Music.parseMusicString(\"[A^C2E4]\");\n\n        List<Double> midiInput = chord.addToMidiPlayer(0.0);\n        int i = 0;\n        \n        double startOffset = midiInput.get((int)i++);\n        double pitch = midiInput.get((int)i++);\n        double duration = midiInput.get((int)i++);\n\n        assertEquals(0, startOffset, epsilon);\n        assertEquals(9, pitch, epsilon);\n        assertEquals(1, duration, epsilon);\n\n        startOffset = midiInput.get(i++);\n        pitch = midiInput.get(i++);\n        duration = midiInput.get(i++);\n        assertEquals(0, startOffset, epsilon);\n        assertEquals(1, pitch, epsilon);\n        assertEquals(2, duration, epsilon);\n\n        startOffset = midiInput.get(i++);\n        pitch = midiInput.get(i++);\n        duration = midiInput.get(i++);\n        assertEquals(0, startOffset, epsilon);\n        assertEquals(4, pitch, epsilon);\n        assertEquals(4, duration, epsilon);\n\n        }\n}\n\n\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282930,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/NoteTest.java",
    "data": "package karaoke.sound;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\n/**\n * Tests the methods of the Note class \n * @category no_didit\n */\npublic class NoteTest extends MusicTest {\n    /* \n     * middle octave C\n     * higher octave c\n     * 2 octaves up c'\n     * 3 octaves up c'' \n     * lower octaves: C, C,,\n     * \n     * numerators and denominators can be \n     * BUT don't have to be omitted\n     * \n     * an omitted numerator should be treated as a 1\n     * an omitted denominator should be treated as a 2\n     * \n     * \n     * Methods\n     * Constructors && invariants: \n     *      duration > 0, 0, 0<x<1, >1\n     *      pitch: (in)valid baseNote\n     *      pitchValue: 0. 0<x<11, >=11\n     *      natural: true, false\n     *      accidental: #,^,= one, multiple occidentals \n     *      octave: C, c, c' c'', C,; C,,\n     * numNotes():\n     *      return: 1\n     * duration():\n     *      return: > 0, 0, 0<x<1, >1\n     * transpose():\n     *      \n     * changeDuration()\n     *          - output: double 0, 1, n\n     * getPitchValue()\n     * setNatural()\n     *      getNotes()\n     *          -output array of length 1, 2, n\n     *      addToMidiPlayer()\n     *          - input: startBeat: 0, 1, >= 2, tupletSpec: 0, 1, >= 2 \n     *          - output: midiData (in)valid, size: 0, 1, 1<x<5,>5 \n     *      modifyKey()\n     *          - input: (valid) key \n     *          - output: Chord, other type of Music \n     *      toString()\n     *          - input: 1 valid note\n     *      transpose()\n     *          - input: semiTonesup: 0, 1, n  \n     *          - output: Chord, other type of Music\n     *      equals():\n     *          - input: two similar objects, two dissimilar\n     *          - return: true, false\n     *      hashCode():\n     *          - return: int identical for two equal() objects\n     */\n    \n    //\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013durationStringToDouble tests\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\n    /*\n     * numerator digits: 0, 1, >1\n     * denominator digits: 0, 1, >1\n     * slash present: true, false\n     */\n    private static double epsilon = .0001;\n\n    @Test // This test covers note constructor, duration, numNotes, getPitchValue, toString\n    // with input: simple basenote \n    // duration: 2\n    public void testSimpleNote() {\n        Note n = new Note('A', 2);\n        assertEquals(2, n.duration(), epsilon);\n        assertEquals(1, n.numNotes(), epsilon);\n        assertEquals(9, n.getPitchValue(), epsilon);\n        assertEquals(\"A2\", n.toString());\n    }\n    \n    @Test // This test covers note constructor, duration, numNotes, getPitchValue, toString\n    // with input: simple basenote  \n    // duration: 5\n    public void testMediumComplicatedNote() {\n        Note n = new Note('D', 5);\n        assertEquals(5, n.duration(), epsilon);\n        assertEquals(1, n.numNotes(), epsilon);\n        assertEquals(2, n.getPitchValue(), epsilon);\n        assertEquals(\"D5\", n.toString());\n    }\n    \n    @Test // this test covers transpose by one octave\n    public void testTransposeNoteOneOctave() {\n        Note n = new Note('C', .5);\n        n = (Note) n.transpose(Pitch.OCTAVE);\n\n        assertEquals(.5, n.duration(), epsilon);\n        assertEquals(1, n.numNotes(), epsilon);\n        assertEquals(12, n.getPitchValue(), epsilon);\n        assertEquals(\"C1/2\", n.toString());\n    }\n    \n    @Test // this test covers transpose by two octave\n    public void testTransposeNoteTwoOctaves() {\n        Note n = new Note('C', .5);\n        n = (Note) n.transpose(Pitch.OCTAVE);\n        n = (Note) n.transpose(Pitch.OCTAVE);\n        \n        assertEquals(.5, n.duration(), epsilon);\n        assertEquals(1, n.numNotes(), epsilon);\n        assertEquals(24, n.getPitchValue(), epsilon);\n        assertEquals(\"C1/2\", n.toString());\n    }\n\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282931,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/PieceTest.java",
    "data": "package karaoke.sound;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\nimport org.junit.Test;\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.parser.PieceParser;\nimport karaoke.parser.StaffParser;\n\n/**\n * @category no_didit\n */\npublic class PieceTest {\n\n    public static final double EPSILON = .0001;\n\n    /*\n     * Testing Strategy\n     * \n     * Input Partitions\n     *  isValid: true, false\n     *  \n     * Getters (partitioned on return):\n     * \n     * getKaraokeIndex(): 0, 1, >1\n     * getTitle(): (non)empty string\n     * getComposer(): (non)empty string\n     * getKey(): basenote, basenote with accidental, basenote with note minor\n     * getMeter(): < 0.75, =0.75, >0.75\n     * getNoteLength(): 0<x<1/16, 1/16<=x<1/8, 1/8<=x<1\n     * getTempo(): <10, =10, >10\n     * \n     * Setters (use same partitions as for getters as input):\n     * \n     * setIndex()\n     * setTitle() \n     * setComposer()\n     * setKey()\n     * setMeter(): when noteLength is (not) at the default value, \n     * setDefaultNoteLength()\n     * setTempo()\n     * \n     * Other Methods: \n     * decimalValueOfString():\n     *      input: string of the form A, A/B both of which can be < 1, 1, >1\n     *             string is a special value C or C|\n     * equals()\n     *      input: all fields of the input object identical to the current object, different\n     *      return: true, false\n     * toString(): \n     *      param values: \n     * hashCode():\n     *      return: int that should be identical for two objects considered .equal to each other\n     * addStaff(): \n     *      input in relation to staffs field: first staff being added, second staff\n     * initializePiece():\n     *      environment: contains 0, 1, >1 staffs\n     *      tested by play's dependency on it \n     * play():\n     *      environment: (not) isValid, (not) this.player.isPlaying()\n     */\n\n    @Test // This test covers creating a basic Piece object. \n    // This test covers all getters. karaokeIndex = 0, title = non empty string, \n    // key = basenote, meter = < 0.75, notelength = 1/8<=x<1, tempo > 10\n    public void testPieceConstructorAndGetters() throws  UnableToParseException {\n        Piece piece = new Piece(0, \"name\", \"comp\", \"C\", \"2/4\", 1.0/4, 200);\n        \n        assertEquals(0, piece.getKaraokeIndex());\n        assertEquals(\"name\", piece.getTitle());\n        assertEquals(\"comp\", piece.getComposer());\n        assertEquals(\"C\", piece.getKey());\n        assertEquals(\"2/4\", piece.getMeter());\n        assertEquals(.25, piece.getNoteLength(), EPSILON);\n        assertEquals(200, piece.getTempo(), EPSILON);\n    }\n    \n    @Test // This test covers creating a basic Piece object. \n    // This test covers all getters. karaokeIndex = 0, title = non empty string, \n    // key = basenote, meter = < 0.75, notelength = 1/8<=x<1, tempo = 10\n    // This test covers all setters. karaokeIndex = >1, title = non empty string, \n    // key = basenote with accidental and minor, meter = > 0.75, notelength = 1/16<=x<1/8, tempo < 10\n    public void testPieceSettersAndGetters() throws  UnableToParseException {\n        Piece piece = new Piece(0, \"name\", \"comp\", \"C\", \"2/4\", 1.0/4, 10);\n        assertEquals(0, piece.getKaraokeIndex());\n        assertEquals(\"name\", piece.getTitle());\n        assertEquals(\"comp\", piece.getComposer());\n        assertEquals(\"C\", piece.getKey());\n        assertEquals(\"2/4\", piece.getMeter());\n        assertEquals(.25, piece.getNoteLength(), EPSILON);\n        assertEquals(10, piece.getTempo(), EPSILON);\n        \n        piece.setIndex(2);\n        assertEquals(2, piece.getKaraokeIndex());\n        piece.setTitle(\"fluffy\");\n        assertEquals(\"fluffy\", piece.getTitle());\n        piece.setComposer(\"dog\");\n        assertEquals(\"dog\", piece.getComposer());\n        piece.setKey(\"D#m\");\n        assertEquals(\"D#m\", piece.getKey());\n        piece.setMeter(\"4/5\");\n        assertEquals(\"4/5\", piece.getMeter());\n        piece.setDefaultNoteLength(0.11);\n        assertEquals(.11, piece.getNoteLength(), EPSILON);\n        piece.setTempo(7);\n        assertEquals(7, piece.getTempo(), EPSILON);\n    }\n    \n    @Test // This test covers input: A > 1\n    public void testDecimalValueOfStringABigger() {\n        assertEquals(2,Piece.decimalValueOfString(\"2\"),EPSILON); \n    }\n    \n    @Test // This test covers input: A = 1\n    public void testDecimalValueOfStringASmaller() {\n        assertEquals(1,Piece.decimalValueOfString(\"1\"),EPSILON); \n    }\n    \n    @Test // This test covers input: A/B > 1\n    public void testDecimalValueOfStringABBigger() {\n        assertEquals(1.5,Piece.decimalValueOfString(\"3/2\"),EPSILON); \n    }\n    \n    @Test // This test covers input: A/B < 1\n    public void testDecimalValueOfStringA() {\n        assertEquals(6.0/4,Piece.decimalValueOfString(\"6/4\"),EPSILON); \n    }\n    \n    @Test // This test covers input: special value \"C\"\n    public void testDecimalValueOfStringC() {\n        assertEquals(1,Piece.decimalValueOfString(\"C\"),EPSILON); \n    }\n    \n    @Test // This test covers addStaff = first staff being added, initializePiece, play \n    public void testAddStaffs() throws   UnableToParseException {\n        Piece piece = new Piece(0, \"Mario\", \"Nintendo\", \"C\", \"2/4\", 1.0/4, 200);\n        List<String> inputNotesList = Arrays.asList(\"[| |: C D E F :| G A B C |]\", \"B A B B :| G G A B\");\n        Staff staff = new Staff(\"C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputNotesList, Arrays.asList(\"it's poppin\", \"say goodbye\"), staff);    \n\n        piece.addStaff(actual);\n        piece.initializePiece(); \n        piece.play();\n        String expected  = \"0:\\n[| C1 D1 E1 F1 C1 D1 E1 F1 G1 A1 B1 C1 B1 A1 B1 B1 B1 A1 B1 B1 G1 G1 A1 B1|]\\n\"\n        +\"[<b>it's</b> poppin . . . . . ., it's <b>poppin</b> . . . . . ., it's poppin <b>.</b> . . . . ., it's poppin . <b>.</b> . . . ., <b>it's</b> poppin . . . . . ., it's \"\n        +\"<b>poppin</b> . . . . . ., it's poppin <b>.</b> . . . . ., it's poppin . <b>.</b> . . . ., it's poppin . . <b>.</b> . . ., it's poppin . . . <b>.</b> . ., it's poppin . . . . \"\n        +\"<b>.</b> ., it's poppin . . . . . <b>.</b>, <b>say</b> goodbye . . . . . ., say <b>goodbye</b> . . . . . ., say goodbye <b>.</b> . . . . ., say goodbye . <b>.</b> . . . ., \"\n        +\"<b>say</b> goodbye . . . . . ., say <b>goodbye</b> . . . . . ., say goodbye <b>.</b> . . . . ., say goodbye . <b>.</b> . . . ., say goodbye . . <b>.</b> . . ., say goodbye . . . \"\n        +\"<b>.</b> . ., say goodbye . . . . <b>.</b> ., say goodbye . . . . . <b>.</b>]\";\n\n        assertEquals(expected, piece.getStaffs());\n    }\n    \n    @Test // This test covers addStaff = second staff being added, initializePiece, play \n    public void testAddMoreStaffsWeirdRepeat() throws   UnableToParseException {\n        Piece piece = new Piece(0, \"Bagatelle No.25 in A, WoO.59\", \"Ludwig van Beethoven\", \"Am\", \"3/8\", 1.0/16,140);\n        List<String> inputNotesList = Arrays.asList(\"e^d|e^deB=dc|A2 z CEA|B2 z E^GB|c2 z Ee^d|\", \"e^deB=dc|A2 z CEA|B2 z EcB|[1A2 z2:|[2A2z Bcd|\", \"|:e3 Gfe|d3 Fed|c3 Edc|B2 z Ee z|z ee' z z ^d|\",\"e z z ^ded|e^deB=dc|A2 z CEA|B2 zE^GB|c2 z Ee^d|\");\n        List<String> inputLyricsList = Arrays.asList(\"a\", \"b\", \"c\", \"d\"); \n        Staff staff = new Staff(\"Am\", \"3/8\", 1.0/16, 140,1.0/8);\n        Staff actual = StaffParser.parse(inputNotesList, inputLyricsList, staff);    \n        \n        List<String> inputNotestList2 = Arrays.asList(\"z2|z6|A,,E,A, z z2|E,,E,^G, z z2|A,,E,A, z z2|\",\"z6|A,,E,A, z z2|E,,E,^G, z z2|[1A,,E,A, z :|[2A,,E,A, z z2|\",\"|:C,E,C z z2|G,,G,B, z z2|A,,E,A, z z2|E,,E,E z z E|e z z ^de z|\",\"z ^de z z2|z6|A,,E,A, z z2|E,,E,^G, z z2|A,,E,A, z z2|\"); \n        Staff staff2 = new Staff(\"Am\", \"3/8\", 1.0/16, 140,1.0/8);\n        Staff actual2 = StaffParser.parse(inputNotestList2, inputLyricsList, staff2); \n\n        piece.addStaff(actual);\n        piece.addStaff(actual2);\n        piece.initializePiece();\n        piece.play();\n        System.out.println(piece.getStaffs());\n        String expected = \"0:\\n[| E1 D1 E1 D1 E1 B1 D1 C1 A2 z1 C1 E1 A1 B2 z1 E1 G1 B1 C2 z1 E1 E1 D1 E1 D1 E1 B1 D1 C1 A2 z1 C1 E1 A1 B2 z1 E1 C1 B1 A2 z2 E1 D1 E1 D1 E1 B1 D1 C1 A2 z1 C1 E1 A1 B2 z1 E1 G1 B1 C2 z1 E1 E1 D1 E1 D1 E1 B1 D1 C1 A2 z1 C1 E1 A1 B2 z1 E1 C1 B1 A2 z1 B1 C1 D1 E3 G1 F1 E1 D3 F1 E1 D1 C3 E1 D1 C1 B2 z1 E1 E1 z1 z1 E1 E1 z1 z1 D1 E1 z1 z1 D1 E1 D1 E1 D1 E1 B1 D1 C1 A2 z1 C1 E1 A1 B2 z1 E1 G1 B1 C2 z1 E1 E1 D1|]\\n\"\n        +\"[<b>a</b> . . . . . . . . . . . . . . . . . . . . . ., a <b>.</b> . . . . . . . . . . . . . . . . . . . . ., a . <b>.</b> . . . . . . . . . . . . . . . . . . . ., a . . <b>.</b> . . . . . . . . . . . . . . . . . . ., a . . . <b>.</b> . . . . . . . . . . . . . . . . . ., a . . . . <b>.</b> . . . . . . . . . . . . . . . . ., a . . . . . <b>.</b> . . . . . . . . . . . . . . . ., a . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . ., a . . . . . . . <b>.</b> . . . . . . . . . . . . . ., a . . . . . . . . <b>.</b> . . . . . . . . . . . . ., a . . . . . . . . . <b>.</b> . . . . . . . . . . . ., a . . . . . . . . . . <b>.</b> . . . . . . . . . . ., a . . . . . . . . . . . <b>.</b> . . . . . . . . . ., a . . . . . . . . . . . . <b>.</b> . . . . . . . . ., a . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . ., a . . . . . . . . . . . . . . <b>.</b> . . . . . . ., a . . . . . . . . . . . . . . . <b>.</b> . . . . . ., a . . . . . . . . . . . . . . . . <b>.</b> . . . . ., a . . . . . . . . . . . . . . . . . <b>.</b> . . . ., a . . . . . . . . . . . . . . . . . . <b>.</b> . . ., a . . . . . . . . . . . . . . . . . . . <b>.</b> . ., a . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> ., a . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>b</b> . . . . . . . . . . . . . . . . . . . . . ., b <b>.</b> . . . . . . . . . . . . . . . . . . . . ., b . <b>.</b> . . . . . . . . . . . . . . . . . . . ., b . . <b>.</b> . . . . . . . . . . . . . . . . . . ., b . . . <b>.</b> . . . . . . . . . . . . . . . . . ., b . . . . <b>.</b> . . . . . . . . . . . . . . . . ., b . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . ., b . . . . . . <b>.</b> . . . . . . . . . . . . . . ., b . . . . . . . <b>.</b> . . . . . . . . . . . . . ., b . . . . . . . . <b>.</b> . . . . . . . . . . . . ., b . . . . . . . . . <b>.</b> . . . . . . . . . . . ., b . . . . . . . . . . <b>.</b> . . . . . . . . . . ., b . . . . . . . . . . . <b>.</b> . . . . . . . . . ., b . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . ., b . . . . . . . . . . . . . <b>.</b> . . . . . . . ., b . . . . . . . . . . . . . . <b>.</b> . . . . . . ., b . . . . . . . . . . . . . . . <b>.</b> . . . . . ., b . . . . . . . . . . . . . . . . <b>.</b> . . . . ., <b>a</b> . . . . . . . . . . . . . . . . . . . . . ., a <b>.</b> . . . . . . . . . . . . . . . . . . . . ., a . <b>.</b> . . . . . . . . . . . . . . . . . . . ., a . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . ., a . . . <b>.</b> . . . . . . . . . . . . . . . . . ., a . . . . <b>.</b> . . . . . . . . . . . . . . . . ., a . . . . . <b>.</b> . . . . . . . . . . . . . . . ., a . . . . . . <b>.</b> . . . . . . . . . . . . . . ., a . . . . . . . <b>.</b> . . . . . . . . . . . . . ., a . . . . . . . . <b>.</b> . . . . . . . . . . . . ., a . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . ., a . . . . . . . . . . <b>.</b> . . . . . . . . . . ., a . . . . . . . . . . . <b>.</b> . . . . . . . . . ., a . . . . . . . . . . . . <b>.</b> . . . . . . . . ., a . . . . . . . . . . . . . <b>.</b> . . . . . . . ., a . . . . . . . . . . . . . . <b>.</b> . . . . . . ., a . . . . . . . . . . . . . . . <b>.</b> . . . . . ., a . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . ., a . . . . . . . . . . . . . . . . . <b>.</b> . . . ., a . . . . . . . . . . . . . . . . . . <b>.</b> . . ., a . . . . . . . . . . . . . . . . . . . <b>.</b> . ., a . . . . . . . . . . . . . . . . . . . . <b>.</b> ., a . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>b</b> . . . . . . . . . . . . . . . . . . . . . ., b <b>.</b> . . . . . . . . . . . . . . . . . . . . ., b . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . ., b . . <b>.</b> . . . . . . . . . . . . . . . . . . ., b . . . <b>.</b> . . . . . . . . . . . . . . . . . ., b . . . . <b>.</b> . . . . . . . . . . . . . . . . ., b . . . . . <b>.</b> . . . . . . . . . . . . . . . ., b . . . . . . <b>.</b> . . . . . . . . . . . . . . ., b . . . . . . . <b>.</b> . . . . . . . . . . . . . ., b . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . ., b . . . . . . . . . <b>.</b> . . . . . . . . . . . ., b . . . . . . . . . . <b>.</b> . . . . . . . . . . ., b . . . . . . . . . . . <b>.</b> . . . . . . . . . ., b . . . . . . . . . . . . <b>.</b> . . . . . . . . ., b . . . . . . . . . . . . . <b>.</b> . . . . . . . ., b . . . . . . . . . . . . . . <b>.</b> . . . . . . ., b . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . ., b . . . . . . . . . . . . . . . . . . <b>.</b> . . ., b . . . . . . . . . . . . . . . . . . . <b>.</b> . ., b . . . . . . . . . . . . . . . . . . . . <b>.</b> ., b . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>c</b> . . . . . . . . . . . . . . . . . . . . . ., c <b>.</b> . . . . . . . . . . . . . . . . . . . . ., c . <b>.</b> . . . . . . . . . . . . . . . . . . . ., c . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . ., c . . . <b>.</b> . . . . . . . . . . . . . . . . . ., c . . . . <b>.</b> . . . . . . . . . . . . . . . . ., c . . . . . <b>.</b> . . . . . . . . . . . . . . . ., c . . . . . . <b>.</b> . . . . . . . . . . . . . . ., c . . . . . . . <b>.</b> . . . . . . . . . . . . . ., c . . . . . . . . <b>.</b> . . . . . . . . . . . . ., c . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . ., c . . . . . . . . . . <b>.</b> . . . . . . . . . . ., c . . . . . . . . . . . <b>.</b> . . . . . . . . . ., c . . . . . . . . . . . . <b>.</b> . . . . . . . . ., c . . . . . . . . . . . . . <b>.</b> . . . . . . . ., c . . . . . . . . . . . . . . <b>.</b> . . . . . . ., c . . . . . . . . . . . . . . . <b>.</b> . . . . . ., c . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . ., c . . . . . . . . . . . . . . . . . <b>.</b> . . . ., c . . . . . . . . . . . . . . . . . . <b>.</b> . . ., c . . . . . . . . . . . . . . . . . . . <b>.</b> . ., c . . . . . . . . . . . . . . . . . . . . <b>.</b> ., c . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>d</b> . . . . . . . . . . . . . . . . . . . . . . . . . ., d <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., d . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., d . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., d . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., d . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., d . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., d . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., d . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . ., d . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., d . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., d . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . ., d . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., d . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., d . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . ., d . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., d . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., d . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., d . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., d . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., d . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . ., d . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., d . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., d . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . ., d . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., d . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., d . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>]\\n\"\n        +\"1:\\n[| z2 z6 A1 E1 A1 z1 z2 E1 E1 G1 z1 z2 A1 E1 A1 z1 z2 z6 A1 E1 A1 z1 z2 E1 E1 G1 z1 z2 A1 E1 A1 z1 z2 z6 A1 E1 A1 z1 z2 E1 E1 G1 z1 z2 A1 E1 A1 z1 z2 z6 A1 E1 A1 z1 z2 E1 E1 G1 z1 z2 A1 E1 A1 z1 z2 C1 E1 C1 z1 z2 G1 G1 B1 z1 z2 A1 E1 A1 z1 z2 E1 E1 E1 z1 z1 E1 E1 z1 z1 D1 E1 z1 z1 D1 E1 z1 z2 z6 A1 E1 A1 z1 z2 E1 E1 G1 z1 z2 A1 E1 A1 z1 z2|]\\n\"\n        +\"[<b>a</b> . . . . . . . . . . . . . . . ., a <b>.</b> . . . . . . . . . . . . . . ., a . <b>.</b> . . . . . . . . . . . . . ., a . . <b>.</b> . . . . . . . . . . . . ., a . . . <b>.</b> . . . . . . . . . . . ., a . . . . <b>.</b> . . . . . . . . . . ., a . . . . . <b>.</b> . . . . . . . . . ., a . . . . . . <b>.</b> . . . . . . . . ., a . . . . . . . <b>.</b> . . . . . . . ., a . . . . . . . . \"\n        +\"<b>.</b> . . . . . . ., a . . . . . . . . . <b>.</b> . . . . . ., a . . . . . . . . . . <b>.</b> . . . . ., a . . . . . . . . . . . <b>.</b> . . . ., a . . . . . . . . . . . . <b>.</b> . . ., a . . . . . . . . . . . . . <b>.</b> . ., a . . . . . . . . . . . . . . <b>.</b> ., a . . . . . . . . . . . . . . . <b>.</b>, <b>b</b> . . . . . . . . . . . . . . . . . . ., b <b>.</b> . . . . . . . . . . . . . . . . . ., b . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . ., b . . <b>.</b> . . . . . . . . . . . . . . . ., b . . . <b>.</b> . . . . . . . . . . . . . . ., b . . . . <b>.</b> . . . . . . . . . . . . . ., b . . . . . <b>.</b> . . . . . . . . . . . . ., b . . . . . . <b>.</b> . . . . . . . . . . . ., b . . . . . . . <b>.</b> . . . . . . . . . . ., b . . . . . . . . <b>.</b> . . . . . . . . . ., b . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . ., b . . . . . . . . . . <b>.</b> . . . . . . . ., b . . . . . . . . . . . <b>.</b> . . . . . . ., b . . . . . . . . . . . . <b>.</b> . . . . . ., b . . . . . . . . . . . . . <b>.</b> . . . . ., <b>a</b> . . . . . . . . . . . . . . . ., a <b>.</b> . . . . . . . . . . . . . . ., a . <b>.</b> . . . . . . . . . . . . . ., a . . <b>.</b> . . . . . . . . . . . . ., a . . . \"\n        +\"<b>.</b> . . . . . . . . . . . ., a . . . . <b>.</b> . . . . . . . . . . ., a . . . . . <b>.</b> . . . . . . . . . ., a . . . . . . <b>.</b> . . . . . . . . ., a . . . . . . . <b>.</b> . . . . . . . ., a . . . . . . . . <b>.</b> . . . . . . ., a . . . . . . . . . <b>.</b> . . . . . ., a . . . . . . . . . . <b>.</b> . . . . ., a . . . . . . . . . . . <b>.</b> . . . ., a . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., a . . . . . . . . . . . . . <b>.</b> . ., a . . . . . . . . . . . . . . <b>.</b> ., a . . . . . . . . . . . . . . . <b>.</b>, <b>b</b> . . . . . . . . . . . . . . . . . . ., b <b>.</b> . . . . . . . . . . . . . . . . . ., b . <b>.</b> . . . . . . . . . . . . . . . . ., b . . <b>.</b> . . . . . . . . . . . . . . . ., b . . . <b>.</b> . . . . . . . . . . . . . . ., b . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . ., b . . . . . <b>.</b> . . . . . . . . . . . . ., b . . . . . . <b>.</b> . . . . . . . . . . . ., b . . . . . . . <b>.</b> . . . . . . . . . . ., b . . . . . . . . <b>.</b> . . . . . . . . . ., b . . . . . . . . . <b>.</b> . . . . . . . . ., b . . . . . . . . . . . . . . <b>.</b> . . . ., b . . . . . . . . . . . . . . . <b>.</b> . . ., b . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . ., b . . . . . . . . . . . . . . . . . <b>.</b> ., b . . . . . . . . . . . . . . . . . . <b>.</b>, <b>c</b> . . . . . . . . . . . . . . . . . . . . . . . . . ., c <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., c . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., c . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., c . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., c . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . ., c . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., c . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., c . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . ., c . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., c . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., c . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . ., c . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., c . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., c . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., c . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., c . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., c . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . ., c . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., c . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., c . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., c . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., c . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., c . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., c . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., c . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., c . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>d</b> . . . . . . . . . . . . . . . . . . . ., d <b>.</b> . . . . . . . . . . . . . . . . . . ., d . <b>.</b> . . . . . . . . . . . . . . . . . ., d . . <b>.</b> . . . . . . . . . . . . . . . . ., d . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . ., d . . . . <b>.</b> . . . . . . . . . . . . . . ., d . . . . . <b>.</b> . . . . . . . . . . . . . ., d . . . . . . <b>.</b> . . . . . . . . . . . . ., d . . . . . . . <b>.</b> . . . . . . . . . . . ., d . . . . . . . . <b>.</b> . . . . . . . . . . ., d . . . . . . . . . <b>.</b> . . . . . . . . . ., d . . . . . . . . . . <b>.</b> . . . . . . . . ., d . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . ., d . . . . . . . . . . . . <b>.</b> . . . . . . ., d . . . . . . . . . . . . . <b>.</b> . . . . . ., d . . . . . . . . . . . . . . <b>.</b> . . . . ., d . . . . . . . . . . . . . . . <b>.</b> . . . ., d . . . . . . . . . . . . . . . . <b>.</b> . . ., d . . . . . . . . . . . . . . . . . <b>.</b> . ., d . . . . . . . . . . . . . . . . . . <b>.</b> ., d . . . . . . . . . . . . . . . . . . . <b>.</b>]\";\n        assertEquals(expected, piece.getStaffs());\n    }\n\n    //This test tests playing a specific piece\n    //this test has 2 Staffs\n    @Test \n    public void testPlayFurElisePiece() throws IOException, UnableToParseException, InvalidMidiDataException, MidiUnavailableException {\n        Scanner in = new Scanner(new File(\"sample-abc/fur_elise.abc\"));\n        String fileContent = in.useDelimiter(\"\\\\Z\").next();\n        Piece piece = PieceParser.parse(fileContent);\n        piece.play();\n        in.close();\n    }\n    //This test tests playing a specific piece\n    //This piece requires 1 Staff and it has no lyrics\n    @Test \n    public void testPlayPiece() throws IOException, UnableToParseException, InvalidMidiDataException, MidiUnavailableException {\n        Scanner in = new Scanner(new File(\"sample-abc/little_night_music.abc\"));\n        String fileContent = in.useDelimiter(\"\\\\Z\").next();\n        Piece piece = PieceParser.parse(fileContent);\n        piece.play();\n        in.close();\n    }\n    \n    @Test //This test covers addStaff = second staff being added, initializePiece, play\n    public void testAddMoreStaffs() throws   UnableToParseException {\n        Piece piece = new Piece(0, \"Invention no. 1\", \"Johann Sebastian Bach\", \"\", \"C\", 1.0/8,70);\n        List<String> inputNotesList = Arrays.asList(\"z/C/D/E/ F/D/E/C/ GcBc|d/G/A/B/ c/A/B/G/ dgfg|\", \"e/a/g/f/ e/g/f/a/ g/f/e/d/ c/e/d/f/|e/d/c/B/ A/c/B/d/ c/B/A/G/ ^F/A/G/B/|\", \"AD c3/d/ B/A/G/^F/ E/G/F/A/|G/B/A/c/ B/d/c/e/ d/B/4c/4d/g/ BA/G/|\");\n        List<String> inputLyricsList = Arrays.asList(\"a\", \"b\", \"c\"); \n        Staff staff = new Staff(\"\", \"C\", 1.0/8, 70, 1/4.0);\n        Staff actual = StaffParser.parse(inputNotesList, inputLyricsList, staff);    \n        List<String> inputNotestList2 = Arrays.asList(\"z4 z/C,/D,/E,/ F,/D,/E,/C,/|G,G,, z2 z/G,/A,/B,/ C/A,/B,/G,/|\",\"CB,CD EG,A,B,|CE,^F,G, A,B,C2|\",\"C/D,/E,/^F,/ G,/E,/F,/D,/ G,B,,C,D,|E,^F,G,E, B,,C, D,D,,|\"); \n        Staff staff2 = new Staff(\"\", \"C\", 1.0/8, 70, 1.0/4.0);\n        Staff actual2 = StaffParser.parse(inputNotestList2, inputLyricsList, staff2); \n        piece.addStaff(actual);\n        piece.addStaff(actual2);\n        piece.initializePiece();\n        piece.play();\n        System.out.println(\"staffsss\\n\" + piece.getStaffs());\n        String expected = \"0:\\n[| z1/2 C1/2 D1/2 E1/2 F1/2 D1/2 E1/2 C1/2 G1 C1 B1 C1 D1/2 G1/2 A1/2 B1/2 C1/2 A1/2 B1/2 G1/2 D1 G1 F1 G1 E1/2 A1/2 G1/2 F1/2 E1/2 G1/2 F1/2 A1/2 G1/2 F1/2 E1/2 D1/2 C1/2 E1/2 D1/2 F1/2 E1/2 D1/2 C1/2 B1/2 A1/2 C1/2 B1/2 D1/2 C1/2 B1/2\"\n        +\" A1/2 G1/2 F1/2 A1/2 G1/2 B1/2 A1 D1 C3/2 D1/2 B1/2 A1/2 G1/2 F1/2 E1/2 G1/2 F1/2 A1/2 G1/2 B1/2 A1/2 C1/2 B1/2 D1/2 C1/2 E1/2 D1/2 B1/4 C1/4 D1/2 G1/2 B1 A1/2 G1/2|]\\n\"\n        +\"[<b>a</b> . . . . . . . . . . . . . . . . . . . . . . ., a <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., a . <b>.</b> . . . . . . . . . . . . . . . . . . . . ., a . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., a . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . ., a . . . . <b>.</b> . . . . . . . . . . . . . . . . . ., a . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., a . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., a . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . ., a . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., a . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., a . . . . . . . . . . <b>.</b> . . . . . . . . . . . ., a . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . ., a . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., a . . . . . . . . . . . . . <b>.</b> . . . . . . . . ., a . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., a . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . ., a . . . . . . . . . . . . . . . . <b>.</b> . . . . . ., a . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., a . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., a . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., a . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., a . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., a . . . . . . . . . . . . . . . . . . . . . . <b>.</b>, <b>b</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., b \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., b . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., b . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . . ., b . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . . ., b . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . ., b . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., b . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., b . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., b . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., b . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . ., b . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., b . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., b . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . ., b . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., b . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., b . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . ., b . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., b . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., b . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . ., b . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., b . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., b . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . ., b . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., b . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., b . . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . ., b . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., b . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., b . . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., b . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., b . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., b . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b>, <b>c</b> . . . . . . . . . . . . . . . . . . . . . . . . . . ., c <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . . ., c . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . . . ., c . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . . . . ., c . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . . ., c . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . . . ., c . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . . . . ., c . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . . ., c . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . . . ., c . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . ., c . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . . ., c . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . . . ., c . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . ., c . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . . ., c . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . . . ., c . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . ., c . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . . ., c . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . . . ., c . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . ., c . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . . ., c . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . . . ., c . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . ., c . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . . ., c . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . . . ., c . . . . . . . . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., c . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> . ., c . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b> ., c . . . . . . . . . . . . . . . . . . . . . . . . . . <b>.</b>]\\n\"\n        +\"1:\\n[| z4 z1/2 C1/2 D1/2 E1/2 F1/2 D1/2 E1/2 C1/2 G1 G1 z2 z1/2 G1/2 A1/2 B1/2 C1/2 A1/2 B1/2 G1/2 C1 B1 C1 D1 E1 G1 A1 B1 C1 E1 F1 G1 A1 B1 C2 C1/2 D1/2 E1/2 F1/2 G1/2 E1/2 F1/2 D1/2 G1 B1 C1 D1 E1 F1 G1 E1 B1 C1 D1 D1|]\\n\"\n        +\"[<b>a</b> . . . . . . . . . . . . . . . . . . ., a <b>.</b> . . . . . . . . . . . . . . . . . ., a . <b>.</b> . . . . . . . . . . . . . . . . ., a . . <b>.</b> . . . . . . . . . . . . . . . ., a . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . . ., a . . . . <b>.</b> . . . . . . . . . . . . . ., a . . . . . <b>.</b> . . . . . . . . . . . . ., a . . . . . . <b>.</b> . . . . . . . . . . . ., a . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . . ., a . . . . . . . . <b>.</b> . . . . . . . . . ., a . . . . . . . . . <b>.</b> . . . . . . . . ., a . . . . . . . . . . <b>.</b> . . . . . . . ., a . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . . ., a . . . . . . . . . . . . <b>.</b> . . . . . ., a . . . . . . . . . . . . . <b>.</b> . . . . ., a . . . . . . . . . . . . . . <b>.</b> . . . ., a . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . . ., a . . . . . . . . . . . . . . . . <b>.</b> . ., a . . . . . . . . . . . . . . . . . <b>.</b> ., a . . . . . . . . . . . . . . . . . . <b>.</b>, <b>b</b> . . . . . . . . . . . . . ., b \"\n        +\"<b>.</b> . . . . . . . . . . . . ., b . <b>.</b> . . . . . . . . . . . ., b . . <b>.</b> . . . . . . . . . . ., b . . . <b>.</b> . . . . . . . . . ., b . . . . <b>.</b> . . . . . . . . ., b . . . . . \"\n        +\"<b>.</b> . . . . . . . ., b . . . . . . <b>.</b> . . . . . . ., b . . . . . . . <b>.</b> . . . . . ., b . . . . . . . . <b>.</b> . . . . ., b . . . . . . . . . <b>.</b> . . . ., b . . . . . . . . . . \"\n        +\"<b>.</b> . . ., b . . . . . . . . . . . <b>.</b> . ., b . . . . . . . . . . . . <b>.</b> ., b . . . . . . . . . . . . . <b>.</b>, <b>c</b> . . . . . . . . . . . . . . . . . . ., c \"\n        +\"<b>.</b> . . . . . . . . . . . . . . . . . ., c . <b>.</b> . . . . . . . . . . . . . . . . ., c . . <b>.</b> . . . . . . . . . . . . . . . ., c . . . <b>.</b> . . . . . . . . . . . . . . ., c . . . . \"\n        +\"<b>.</b> . . . . . . . . . . . . . ., c . . . . . <b>.</b> . . . . . . . . . . . . ., c . . . . . . <b>.</b> . . . . . . . . . . . ., c . . . . . . . <b>.</b> . . . . . . . . . . ., c . . . . . . . . \"\n        +\"<b>.</b> . . . . . . . . . ., c . . . . . . . . . <b>.</b> . . . . . . . . ., c . . . . . . . . . . <b>.</b> . . . . . . . ., c . . . . . . . . . . . <b>.</b> . . . . . . ., c . . . . . . . . . . . . \"\n        +\"<b>.</b> . . . . . ., c . . . . . . . . . . . . . <b>.</b> . . . . ., c . . . . . . . . . . . . . . <b>.</b> . . . ., c . . . . . . . . . . . . . . . <b>.</b> . . ., c . . . . . . . . . . . . . . . . \"\n        +\"<b>.</b> . ., c . . . . . . . . . . . . . . . . . <b>.</b> ., c . . . . . . . . . . . . . . . . . . <b>.</b>]\";\n        assertEquals(expected, piece.getStaffs());\n    }\n    \n    //this tests if adding listeners to a piece with one staff adds the listeners to that specific voice\n    //There is 1 Staff in this test\n    @Test\n    public void testAddListenerSingleStaffs() throws UnableToParseException, FileNotFoundException{\n        Piece piece = new Piece(0, \"test piece\", \"Junit\", \"\", \"C\", 1.0/8,70);\n        Staff staff1 = new Staff(\"C\", \"C\", 1.0/8, 70,1.0/4.0);\n\n        OutputStream  testStream = new OutputStream(){   \n            @Override\n            public void write(int b) throws IOException {\n                System.out.println(b);\n            }\n        };\n        PrintWriter listener = new PrintWriter(testStream);\n\n\n\n        piece.addStaff(staff1);\n        piece.initializePiece();\n        assertEquals(0, piece.getNumListeners());\n        piece.addListener(listener);\n\n\n        assertEquals(\"expected first staff object to have one listener\", 1, staff1.numListeners());\n        assertEquals(1, piece.getNumListeners());\n\n        piece.addListener(listener);\n        assertEquals(\"expected first staff object to have one listener\", 2, staff1.numListeners());\n        assertEquals(2, piece.getNumListeners());\n\n        piece.addListener(listener);\n        assertEquals(\"expected first staff object to have two listener\", 3, staff1.numListeners());\n        assertEquals(3, piece.getNumListeners());\n\n    }\n\n    //This method tests adding listeners to the piece when there are multiple voices to see if\n    //the listeners become evenly distributed\n    @Test\n    public void testAddListenerMultipleStaffs() throws UnableToParseException, FileNotFoundException{\n        Piece piece = new Piece(0, \"test piece\", \"Junit\", \"\", \"C\", 1.0/8,70);\n        Staff staff1 = new Staff(\"\", \"C\", 1.0/8, 70, 1.0/4.0);\n        Staff staff2 = new Staff(\"\", \"C\", 1.0/8, 70, 1.0/4.0);\n        OutputStream  testStream = new OutputStream(){\n        \n            @Override\n            public void write(int b) throws IOException {\n                System.out.println(b);\n            }\n        };\n        PrintWriter listener = new PrintWriter(testStream);\n\n\n\n        piece.addStaff(staff1);\n        piece.addStaff(staff2);\n        piece.initializePiece();\n\n        piece.addListener(listener);\n\n\n        assertEquals(\"expected first staff object to have one listener\", 1, staff1.numListeners());\n        assertEquals(\"expected second staff object to have no listeners\", 0, staff2.numListeners());\n        assertEquals(1, piece.getNumListeners());\n\n        piece.addListener(listener);\n        assertEquals(\"expected first staff object to have one listener\", 1, staff1.numListeners());\n        assertEquals(\"expected second staff object to have one listener\", 1, staff2.numListeners());\n        assertEquals(2, piece.getNumListeners());\n\n        piece.addListener(listener);\n        assertEquals(\"expected first staff object to have two listener\", 2, staff1.numListeners());\n        assertEquals(\"expected second staff object to have one listeners\", 1, staff2.numListeners());\n        assertEquals(3, piece.getNumListeners());\n\n    }\n\n    //This test tests invalid adding of listeners to the piece\n    @Test\n    public void testAddListenerInvalid() {\n        Piece piece = new Piece(0, \"test piece\", \"Junit\", \"\", \"C\", 1.0/8,70);\n\n        OutputStream  testStream = new OutputStream(){\n            @Override\n            public void write(int b) throws IOException {\n                System.out.println(b);\n            }\n        };\n\n        PrintWriter listener = new PrintWriter(testStream);\n\n        boolean inValidTest1 = false, invalidTest2 = false;\n        try {\n            piece.addListener(listener);\n        } catch( AssertionError e) {\n            inValidTest1 = true;\n        }\n        assertEquals(0, piece.getNumListeners());\n        \n        try{\n            piece.initializePiece();\n        } catch(AssertionError e) {\n            invalidTest2 = true;\n        }\n\n        assertTrue(\"expected assertion errors to be thrown for invalid state invariants\",\n                        inValidTest1 && invalidTest2);\n    }\n\n    //This test tests being able to initialize the piece more than once\n    //number of staffs = 2\n    @Test(expected=AssertionError.class)\n    public void testReInitializePiece() {\n        Piece piece = new Piece(0, \"test piece\", \"Junit\", \"\", \"C\", 1.0/8,70);\n        Staff staff1 = new Staff(\"Gb\", \"1/4\", 1.0/8, 70, 1.0/4.0);\n        Staff staff2 = new Staff(\"C#\", \"1/4\", 1.0/8, 70, 1.0/4.0);\n\n        piece.addStaff(staff1);\n\n        piece.addStaff(staff2);\n        piece.initializePiece();\n        piece.initializePiece();\n    }\n\n    //This test asserts that a staff cannot be added to the piece after it has been initialized\n    //as stated in the Piece spec\n    @Test(expected=AssertionError.class)\n    public void testAddStaffToValidPiece() {\n        Piece piece = new Piece(0, \"test piece\", \"Junit\", \"\", \"C\", 1.0/8,70);\n        Staff staff1 = new Staff(\"Am\", \"3/4\", 1.0/8, 70, 1.0/4.0);\n        Staff staff2 = new Staff(\"Fm\", \"3/4\", 1.0/8, 70, 1.0/4.0);\n\n        piece.addStaff(staff1);\n        piece.initializePiece();\n\n        piece.addStaff(staff2);\n    }\n\n    //This test tests that that an empty staff can be added to the piece and played\n    @Test\n    public void testPlayEmptyStaff() {\n        Piece piece = new Piece(0, \"test piece\", \"Junit\", \"\", \"C\", 1.0/8,70);\n        Staff staff1 = new Staff(\"Bb\", \"6/8\", 1.0/8, 70, 1.0/4.0);\n\n        piece.addStaff(staff1);\n        piece.initializePiece();\n\n        piece.play();\n        assert true;\n    }\n}",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282932,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/RestTest.java",
    "data": "package karaoke.sound;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\n/**\n * Tests the methods of the Rest ADT\n * @category no_didit\n */\npublic class RestTest {\n    /**\n     * general testing strategy, \n     * Rest partition:\n     *      duration: <1, 1, >1\n     *      number of rests: 1, >1\n     */\n    private final double epsilon = .0001;\n    \n    @Test\n    public void testConstructAndChangeRestDuration(){\n        Rest input = new Rest(2.0);\n        assertEquals(2.0, input.duration(), epsilon);\n        \n        input.changeDuration(4.0);\n        Rest testEqualTranspose = (Rest) input.transpose(3);\n        assertEquals(0, input.numNotes());\n        assertTrue(input.isRest());\n    }\n    \n    @Test\n    public void testEquals() {\n        Rest rest1 = new Rest(2.0);\n        Rest rest2 = new Rest(2.0);\n        \n        assertTrue(rest1.equals(rest2));\n        assertTrue(rest1.hashCode() == rest2.hashCode());\n    }\n    \n    @Test\n    public void testToStringDurationLessThanOne() {\n        String expected = \"z1/4\";\n        Rest input = new Rest(.25);\n        assertEquals(expected, input.toString());\n    }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282933,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/SequencePlayerTest.java",
    "data": "package karaoke.sound;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Consumer;\n\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\n\nimport org.junit.Test;\n\n/**\n * Plays the music of pieces 1, 2, and 3\n * @author brentsamuels\n * @category no_didit\n */\npublic class SequencePlayerTest {\n\n    @Test(expected=AssertionError.class)\n    public void testAssertionsEnabled() {\n        assert false; // make sure assertions are enabled with VM argument: -ea\n    }\n    \n//    @Test\n//    public void testPlayPiece1()  throws MidiUnavailableException, InvalidMidiDataException  {\n//        Instrument piano = Instrument.PIANO;\n//        \n//        final int beatsPerMinute = 120;\n//        final int ticksPerBeat = 64; // allows up to 1/64-beat notes to be played with fidelity\n//        SequencePlayer player = new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n//        \n//        final int beatsPerNote = 4;\n//        double defaultBeatLength = 1/4.0;\n//        \n//        List<Character> pitches = Arrays.asList('C', 'C', 'C', 'D', 'E',\n//                                            'E', 'D', 'E', 'F', 'G',\n//                                            'c', 'c', 'c', 'G', 'G', 'G', 'E', 'E', 'E', 'C', 'C', 'C',\n//                                            'G', 'F', 'E', 'D', 'C');\n//        List<Double> durations = Arrays.asList(\n//                defaultBeatLength, //C\n//                defaultBeatLength, //C\n//                3*defaultBeatLength/4.0, //C3/4\n//                defaultBeatLength/4.0, //D/4\n//                defaultBeatLength, //E\n//                3*defaultBeatLength/4.0, //E3/4\n//                defaultBeatLength/4.0, //D/4\n//                3*defaultBeatLength/4.0, //E3/4\n//                defaultBeatLength/4.0, //F/4\n//                2*defaultBeatLength, //G2\n//                defaultBeatLength/3.0, //3ccc #1 a third of a quarter note?\n//                defaultBeatLength/3.0, //3ccc #2\n//                defaultBeatLength/3.0, //3ccc #3\n//                defaultBeatLength/3.0, //3GGG\n//                defaultBeatLength/3.0, //3GGG\n//                defaultBeatLength/3.0, //3GGG\n//                defaultBeatLength/3.0, //3EEE\n//                defaultBeatLength/3.0, //3EEE\n//                defaultBeatLength/3.0, //3EEE\n//                defaultBeatLength/3.0, //3CCC\n//                defaultBeatLength/3.0, //3CCC\n//                defaultBeatLength/3.0, //3CCC\n//                3*defaultBeatLength/4.0, //G3/4\n//                defaultBeatLength/4.0, //F/4\n//                3*defaultBeatLength/4.0, //E3/4\n//                defaultBeatLength/4.0, //F/4\n//                2*defaultBeatLength //C2\n//                ); \n//        \n//        assert pitches.size() == durations.size();\n//        double startBeat = 0;\n//        \n//        for(int i=0; i<durations.size(); i++) {\n//            Character currentPitch = pitches.get(i);\n//            if(currentPitch.equals(Character.toLowerCase(currentPitch))) {\n//                player.addNote(piano, new Pitch(Character.toUpperCase(currentPitch)).transpose(Pitch.OCTAVE), startBeat, beatsPerNote*durations.get(i));\n//                startBeat += beatsPerNote*durations.get(i);\n//                \n//            }else {\n//                player.addNote(piano, new Pitch(currentPitch), startBeat, beatsPerNote*durations.get(i));\n//                startBeat += beatsPerNote*durations.get(i);\n//            }\n//        }\n//        \n//        // add a listener at the end of the piece to tell main thread when it's done\n//        Object lock = new Object();\n//        player.addEvent(startBeat, (Double beat) -> {\n//            synchronized (lock) {\n//                lock.notify();\n//            }\n//        });\n//        \n//        // print the configured player\n//        System.out.println(player);\n//        \n//        // play!\n//        player.play();\n//        \n//        // wait until player is done\n//        // (not strictly needed here, but useful for JUnit tests)\n//        synchronized (lock) {\n//            try {\n//                lock.wait();\n//            } catch (InterruptedException e) {\n//                return;\n//            }\n//        }\n//        System.out.println(\"done playing\");\n//    }\n//    \n//    @Test\n//    public void testPlayPiece2()  throws MidiUnavailableException, InvalidMidiDataException  {\n//        Instrument piano = Instrument.PIANO;\n//        \n//        final int beatsPerMinute = 200;\n//        final int beatsPerNote = 4;\n//        final int ticksPerBeat = 64; // allows up to 1/64-beat notes to be played with fidelity\n//        SequencePlayer player = new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n//        \n//        \n//        double defaultBeatLength = 1/4.0;\n//        \n//        List<Character> pitches = Arrays.asList(\n//            '[', '^', 'F', 'e', ']', \n//            '[', '^', 'F', 'e', ']' , 'z',\n//            '[', '^', 'F', 'e', ']' , 'z',\n//            '[', '^', 'F', 'c', ']' ,\n//            '[', '^', 'F', 'e', ']' ,\n//            '[', 'G', 'B', 'g', ']' ,\n//            'z', 'G', 'z', 'c', 'G', 'z', 'E',\n//            'E', 'A', 'B', '_','B', 'A',\n//            'G', 'e', 'g', 'a', 'f', 'g', \n//            'z', 'e', 'c', 'd', 'B', 'z'\n//        );\n//        List<Double> durations = Arrays.asList(\n//            0.0, 0.0, defaultBeatLength/2.0, defaultBeatLength/2.0, 0.0, // [^Fe]/2\n//            0.0, 0.0, defaultBeatLength/2.0, defaultBeatLength/2.0, 0.0, defaultBeatLength/2, // [^Fe]/2 z/2\n//            0.0, 0.0, defaultBeatLength/2.0, defaultBeatLength/2.0, 0.0, defaultBeatLength/2, // [^Fe]/2 z/2\n//            0.0, 0.0, defaultBeatLength/2.0, defaultBeatLength/2.0, 0.0, // [^Fc]/2\n//            0.0, 0.0, defaultBeatLength, defaultBeatLength, 0.0, // [^Fe]\n//            0.0, defaultBeatLength, defaultBeatLength, defaultBeatLength, 0.0, // [GBg]\n//            defaultBeatLength, defaultBeatLength, defaultBeatLength, // z G z\n//            3*defaultBeatLength/2.0, defaultBeatLength/2, defaultBeatLength, defaultBeatLength, // c3/2 G/2 z E\n//            defaultBeatLength/2.0, defaultBeatLength, defaultBeatLength, 0.0, defaultBeatLength/2.0, defaultBeatLength, // E/2 A B _B/2 A\n//            2*defaultBeatLength/3.0, 2*defaultBeatLength/3.0, 2*defaultBeatLength/3.0, defaultBeatLength, defaultBeatLength/2.0, defaultBeatLength/2.0, // (3Geg a f/2 g/2 \n//            defaultBeatLength/2.0, defaultBeatLength, defaultBeatLength/2.0, defaultBeatLength/2.0, // z/2 e c/2 d/2\n//            3*defaultBeatLength/2.0, defaultBeatLength/2.0 //  B3/2 z/2\n//            );\n//     \n//        assert pitches.size() == durations.size();\n//        double startBeat = 0;\n//        boolean inChord = false;\n//\n//        for (int i = 0; i < durations.size(); i++) {\n//            Character currentPitch = pitches.get(i);\n//            boolean sharp = false;\n//            boolean flat = false;\n//\n//            if(currentPitch.equals('z')) {\n//                startBeat += durations.get(i)*beatsPerNote;\n//                continue;// skip to next iteration\n//            }\n//\n//            if (currentPitch.equals('^')) {\n//                sharp = true;\n//                currentPitch = pitches.get(++i);\n//            } else if (currentPitch.equals('_')) {\n//                flat = true;\n//                currentPitch = pitches.get(++i);\n//            }\n//\n//            if (currentPitch.equals('[')) {\n//                inChord = true;\n//            } else if (currentPitch.equals(']')) {\n//                startBeat += durations.get(i-1)*beatsPerNote;\n//                inChord = false;\n//            } else if (currentPitch.equals(Character.toLowerCase(currentPitch))) {\n//                Pitch tone = new Pitch(Character.toUpperCase(currentPitch)).transpose(Pitch.OCTAVE);\n//                if (sharp)\n//                    tone = tone.transpose(1);\n//                else if (flat)\n//                    tone = tone.transpose(-1);\n//                player.addNote(piano, tone, startBeat, durations.get(i)*beatsPerNote);\n//                if (!inChord)\n//                    startBeat += durations.get(i)*beatsPerNote;\n//\n//            } else {\n//                Pitch tone = new Pitch(currentPitch);\n//                if (sharp)\n//                    tone = tone.transpose(1);\n//                else if (flat)\n//                    tone = tone.transpose(-1);\n//                player.addNote(piano, tone, startBeat, durations.get(i)*beatsPerNote);\n//                if (!inChord)\n//                    startBeat += durations.get(i)*beatsPerNote;\n//            }\n//            System.out.println(\"start beat: \" + durations.get(i)*beatsPerNote);\n//        }\n//\n//        // add a listener at the end of the piece to tell main thread when it's done\n//        Object lock = new Object();\n//        player.addEvent(startBeat, (Double beat) -> {\n//            synchronized (lock) {\n//                lock.notify();\n//            }\n//        });\n//\n//        // print the configured player\n//        System.out.println(player);\n//\n//        // play!\n//        player.play();\n//\n//        // wait until player is done\n//        // (not strictly needed here, but useful for JUnit tests)\n//        synchronized (lock) {\n//            try {\n//                lock.wait();\n//            } catch (InterruptedException e) {\n//                return;\n//            }\n//        }\n//        System.out.println(\"done playing\");\n//    }\n//\n//    \n//\n//    \n//    @Test\n//    public void testPlayPiece3() throws MidiUnavailableException, InvalidMidiDataException  {\n//Instrument piano = Instrument.PIANO;\n//        \n//        final int beatsPerMinute = 100;\n//        final int ticksPerBeat = 64; // allows up to 1/64-beat notes to be played with fidelity\n//        SequencePlayer player = new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n//        \n//        final int beatsPerNote = 4;\n//        double defaultBeatLength = 1/8.0;\n//        \n//        \n//        List<Character> pitches = Arrays.asList('D', 'G', 'B', 'G', 'B',\n//                                            'A', 'G', 'E', 'D', 'D',\n//                                            'G', 'B', 'G', 'B', 'A', 'd');\n//        List<Double> durations = Arrays.asList(\n//                2*defaultBeatLength, //D\n//                4*defaultBeatLength, //G\n//                defaultBeatLength, //B\n//                defaultBeatLength, //G\n//                4*defaultBeatLength, //B\n//                2*defaultBeatLength, //A\n//                4*defaultBeatLength, //G\n//                2*defaultBeatLength, //E\n//                4*defaultBeatLength, //D\n//                2*defaultBeatLength, //D\n//                4*defaultBeatLength, //G \n//                defaultBeatLength, //B\n//                defaultBeatLength, //G\n//                4*defaultBeatLength, //B\n//                2*defaultBeatLength, //A\n//                6*defaultBeatLength //d\n//                ); \n//\n//        List<String> lyrics = Arrays.asList(\"A\", \"ma\", \"zing\", \" \", \"Grace \" ,\"how \",\n//                         \"sweet \", \"the \", \"sound \", \"That \",\"saved \", \"a\", \" \", \"wretch \", \"like \", \"me\\n\");\n//\n//        class LyricPrinter implements Consumer<Double> {\n//            private List<String> lyrics;\n//            private int counter = 0;\n//\n//            LyricPrinter(List<String> in) {\n//                this.lyrics = in;\n//            }\n//            @Override\n//            public void accept(Double d) {\n//                System.out.print(lyrics.get(counter++));\n//            }\n//        }\n//\n//        assert pitches.size() == durations.size();\n//        double startBeat = 0;\n//        \n//        LyricPrinter l = new LyricPrinter(lyrics);\n//\n//        for(int i=0; i<durations.size(); i++) {\n//            Character currentPitch = pitches.get(i);\n//            if(currentPitch.equals(Character.toLowerCase(currentPitch))) {\n//                player.addNote(piano, new Pitch(Character.toUpperCase(currentPitch)).transpose(Pitch.OCTAVE), startBeat, beatsPerNote*durations.get(i));\n//                player.addEvent(startBeat, l);\n//                startBeat += beatsPerNote*durations.get(i);\n//                \n//            }else {\n//                player.addNote(piano, new Pitch(currentPitch), startBeat, beatsPerNote*durations.get(i));\n//                player.addEvent(startBeat, l);\n//                startBeat += beatsPerNote*durations.get(i);\n//            }\n//        }\n//        \n//        // add a listener at the end of the piece to tell main thread when it's done\n//        Object lock = new Object();\n//        player.addEvent(startBeat, (Double beat) -> {\n//            synchronized (lock) {\n//                lock.notify();\n//            }\n//        });\n//        \n//        // print the configured player\n//        System.out.println(player);\n//        \n//        // play!\n//        player.play();\n//        \n//        // wait until player is done\n//        // (not strictly needed here, but useful for JUnit tests)\n//        synchronized (lock) {\n//            try {\n//                lock.wait();\n//            } catch (InterruptedException e) {\n//                return;\n//            }\n//        }\n//        System.out.println(\"done playing\");\n//        \n//    }\n    \n\n    \n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282934,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/StaffTest.java",
    "data": "package karaoke.sound;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.Test;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.parser.StaffParser;\n\n/**\n * @category no_didit\n */\npublic class StaffTest {\n\n\n    /**\n     * Testing Strategy\n     *  Test the invariants of the Staff class and staff parser.\n     * \n     * Methods\n     * \n     * parseStaff():\n     *      inputs\n     *          Valid Voice String\n     *          invalid voice string\n     *          numBarlines:\n     *          numRepeats:\n     *          hasFirstEnding\n     *          hasSecondEnding\n     * \n     *      ouputs\n     *          valid staff object\n     *          throws UnableToParseExcpetion\n     *          \n     * special cases:\n     *      begin repeat bar may be omitted and would indicate to go to the beginning of \n     *      the major section. Major section indicated by [|, ||, or |]\n     *      Alternate ending using [1, [2\n     *      \n     *      fewer syllables than available lyrics, later have no lyrics\n     *      more syllables than available lyrics, excess syllables ignored\n     *     \n     * \n     * addMusicToMidiPlayer():\n     *      inputs\n     *          length: 1, >1\n     *          // NOTE, these are top level subdivisions. Don't count a note in a chord or tuplet etc.\n     *          numRests: 0, 1, >1\n     *          numTuplets: 0, 1, >1\n     *          numChords: 0, 1, >1\n     *          numNotes: 1, >1\n     *          \n     * \n     *          outputs\n     *              this.player plays proper music\n     *              this.player doesn't play proper music (expected toString is different)\n     *              this.player throws an error or some other error is thrown\n     * @throws UnableToParseException If the data given to the StaffParser is incapable of \n     * being parsed\n     */\n\n    //repeats: 1, repeat omit: false, length>1, alternate endings: false, \n    //lyrics: true, numNotes >1, num lines: 1\n    @Test\n    public void testParseRepeatNotesOnly() throws  UnableToParseException {\n        List<String> inputNotesList = Arrays.asList(\"C D E F |: G A B C :|\");\n        List<String> inputLyricList = Arrays.asList(\"Syll-a-ble a lot of syll-a-bles ma-ny syll-a-bles\");\n        Staff staff = new Staff(\"C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputNotesList, inputLyricList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'D',  1));\n        outputMusicList.add(new Note( 'E',  1));\n        outputMusicList.add(new Note( 'F',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n        \n        //System.out.println(\"lyrics: \" + actual.getLyrics());\n    }\n    \n    //repeats: 1, repeat omit: true, length>1, alternate endings: false, \n    //lyrics: true, numNotes >1, num lines: 1\n    @Test\n    public void testParseNotesStaffNoFirstRepeat() throws  UnableToParseException {\n        List<String> inputNotesList = Arrays.asList(\"[| C D E F ||\", \"G A B C :|\");\n        Staff staff = new Staff(\"C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputNotesList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'D',  1));\n        outputMusicList.add(new Note( 'E',  1));\n        outputMusicList.add(new Note( 'F',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    //repeats: 1, repeat omit: true, length>1, alternate endings: false, \n    //lyrics: true, numNotes >1, num lines: 2\n    @Test\n    public void testparseNoFirstRepeat2() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"[| C D E F |]\",  \"G A B C :|\");\n        Staff staff = new Staff(\"C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'D',  1));\n        outputMusicList.add(new Note( 'E',  1));\n        outputMusicList.add(new Note( 'F',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    //repeats: 1, repeat omit: true, length>1, alternate endings: false, \n    //lyrics: true, numNotes >1, num lines: 1\n    @Test\n    public void testParseNotesStaffNoFirstRepeat3() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"[| C D E F |] G A B C :|\");\n        Staff staff = new Staff(\"C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'D',  1));\n        outputMusicList.add(new Note( 'E',  1));\n        outputMusicList.add(new Note( 'F',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    //repeats: 1, repeat omit: true, length>1, alternate endings: false, \n    //lyrics: true, numNotes >1, num lines: 1\n    @Test\n    public void testParseNotesStaffNoFirstRepeatMajorEnding() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"[| C D E F |] G A B C :| B A B B |]\");\n        Staff staff = new Staff(\"C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        //String expected = \"C D E F G A B C G A B C\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'D',  1));\n        outputMusicList.add(new Note( 'E',  1));\n        outputMusicList.add(new Note( 'F',  1));\n\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        \n        outputMusicList.add(new Note(\"\", 'B', \"\", 1));\n        outputMusicList.add(new Note(\"\", 'A', \"\", 1));\n        outputMusicList.add(new Note(\"\", 'B', \"\", 1));\n        outputMusicList.add(new Note(\"\", 'B', \"\", 1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    //repeats: 2, repeat omit: false, length>1, alternate endings: false, \n    //lyrics: true, numNotes >1, num lines: 1\n    @Test\n    public void testParseNotesStaffMultipleRepeats() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"[| |: C D E F :| G A B C |] B A B B :|\");\n        Staff staff = new Staff(\"C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n//        String expected = \"C D E F \"\n//                + \"C D E F \"\n//                + \"G A B C \"\n//                + \"B A B B\"\n//                + \"B A B B\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'D',  1));\n        outputMusicList.add(new Note( 'E',  1));\n        outputMusicList.add(new Note( 'F',  1));\n        \n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'D',  1));\n        outputMusicList.add(new Note( 'E',  1));\n        outputMusicList.add(new Note( 'F',  1));\n\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'B', 1));\n\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        \n        \n        //System.out.println(actual.getMusic());\n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    } \n    \n    //repeats: 1, repeat omit: false, length>1, alternate endings: true, \n    //lyrics: true, numNotes >1, num lines: >2\n    @Test\n    public void testParseNotesStaffAlternateEnding() throws  UnableToParseException {\n        List<String> inputStringList = Arrays.asList(\"|: B A C F\", \"[1 E G F A\", \"B C D F\", \":|[2 B B A B |]\");\n        Staff staff = new Staff(\"C\", \"4/4\", 1.0/4, 100);\n        Staff actual = StaffParser.parse(inputStringList, staff);\n        \n        //String expected = \"B A C F E F G A B C D F B A C F B B A B\";\n        List<Music> outputMusicList = new ArrayList<Music>();\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'A',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'F',  1));\n\n        outputMusicList.add(new Note( 'E',  1));\n        outputMusicList.add(new Note( 'G',  1));\n        outputMusicList.add(new Note( 'F',  1));\n        outputMusicList.add(new Note( 'A',  1));\n\n        outputMusicList.add(new Note( 'B',  1));\n        outputMusicList.add(new Note( 'C',  1));\n        outputMusicList.add(new Note( 'D',  1));\n        outputMusicList.add(new Note( 'F',  1));\n\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'C', 1));\n        outputMusicList.add(new Note( 'F', 1));\n        \n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        outputMusicList.add(new Note( 'A', 1));\n        outputMusicList.add(new Note( 'B', 1));\n        \n        //mutating the input should not change actual or else there is a problem\n        assertEquals(outputMusicList, actual.getMusic());\n    }\n        \n    @Test(expected=AssertionError.class)\n    public void testAssertionsEnabled() {\n        assert false; // make sure assertions are enabled with VM argument: -ea\n    }\n\n\n\n    \n    \n}",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282935,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/TupletTest.java",
    "data": "package karaoke.sound;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.sound.Music.MusicKeys;\n\n\n/**\n * @category no_didit\n */\npublic class TupletTest extends MusicTest {\n    /*\n     * methods:\n     *      constructor()\n     *      isRest() - output false\n     *      numNotes() \n     *          output int: 0, 1, n\n     *      duration() \n     *          output - 0 n\n     *      changeDuration()\n     *          input - double 0, 1, n\n     * \n     *      getNotes()\n     *          -output array of length 1, 2, n\n     *      addToMidiPlayer()\n     *      modifyKey()\n     *      toString()\n     *      transpose()\n     *      num notes: 2, 3, 4\n     */\n    \n    private final double epsilon = .0001;\n\n    //numNotes=2, 3, 4\n    //methods used: Tuplet(), changeDuration(), duration()\n     @Test\n     public void testSimpleTuplets() throws UnableToParseException{\n        Music[] notes = new Music[3];\n        notes[0] = Music.parseMusicString(\"A\");\n        notes[1] = Music.parseMusicString(\"=C\");\n        notes[2] = Music.parseMusicString(\"E\");\n         Tuplet triplet = new Tuplet(notes);\n        assertFalse(triplet.isRest());\n        assertEquals(2, triplet.duration(), epsilon);\n        assertEquals(3, triplet.numNotes(), epsilon);\n\n        Music[] notes2 = new Music[2];\n        notes2[0] = Music.parseMusicString(\"_b\");\n        notes2[1] = Music.parseMusicString(\"c\\'\\'/2\");\n         Tuplet duplet = new Tuplet(notes2);\n        assertEquals(2.25, duplet.duration(), epsilon);\n        assertEquals(2, duplet.numNotes(), epsilon);\n        assertFalse(duplet.isRest());\n\n\n        Music[] notes3 = new Music[4];\n        notes3[0] = Music.parseMusicString(\"_b\");\n        notes3[1] = Music.parseMusicString(\"G\");\n        notes3[2] = Music.parseMusicString(\"_e\");\n        notes3[3] = Music.parseMusicString(\"^a\");\n         Tuplet quadruptlet = new Tuplet(notes3);\n        assertEquals(3, quadruptlet.duration(), epsilon);\n        assertEquals(4, quadruptlet.numNotes(), epsilon);\n        assertFalse(quadruptlet.isRest());\n\n        quadruptlet = (Tuplet) quadruptlet.changeDuration(4.0);\n        assertEquals(5.25, quadruptlet.duration(), epsilon);\n\n     }\n\n     //testing upper bound of notes in tuplet\n     //num notes > 4\n     //methods used: Tuplet()\n     @Test(expected=AssertionError.class)\n     public void testTupletTooLarge() throws UnableToParseException{\n        Music[] notes = new Music[5];\n        notes[0] = Music.parseMusicString(\"^B\");\n        notes[1] = Music.parseMusicString(\"^D\");\n        notes[2] = Music.parseMusicString(\"^F\");\n        notes[3] = Music.parseMusicString(\"G\\'\\'\");\n        notes[4] = Music.parseMusicString(\"__F\");\n        new Tuplet(notes);\n     }\n\n     //test lower bound of notes in a tuplet\n     //num notes<1\n     //methods used: Tuplet()\n     @Test(expected=AssertionError.class)\n     public void testTupletTooSmall() throws UnableToParseException{\n         Music[] notes = new Music[2];\n         notes[0] = Music.parseMusicString(\"__C\");\n\n         new Tuplet(notes);\n     }\n\n     //num notes=2\n     //methods used: modifyKey, addToMidiPlayer\n     @Test\n     public void testKeysAndNaturals() throws UnableToParseException{\n        Music[] notes = Music.parseLine(\"A B\");\n//        Music[] expected = Music.parseLine(\"A _B\");\n        Tuplet triplet = new Tuplet(notes);\n\n        Tuplet tripletInC = (Tuplet) triplet.modifyKey(MusicKeys.C);\n        List<Double> afterMod = tripletInC.addToMidiPlayer(0);\n\n        assertEquals(\"expected the first startbeat to ne -\", 0, afterMod.get(0), epsilon);\n        assertEquals(\"expected the first pitch to be -\", 9, afterMod.get(1), epsilon);\n        assertEquals(\"expected the first notes duration to be -\", 1.5, afterMod.get(2), epsilon);\n\n        assertEquals(\"expected the first startbeat to ne -\", 1.5, afterMod.get(3), epsilon);\n        assertEquals(\"expected the first pitch to be -\", 11, afterMod.get(4), epsilon);\n        assertEquals(\"expected the first notes duration to be -\", 1.5, afterMod.get(5), epsilon);\n\n        assertTrue(\"expected C to not modify key\", tripletInC.equals(triplet));\n        Tuplet tripletInF = (Tuplet) triplet.modifyKey(MusicKeys.F);\n        assertFalse(\"expected f to give a Bb\", tripletInF.equals(triplet));\n        List<Double> afterKeyChange = tripletInF.addToMidiPlayer(0);\n\n\n        assertEquals(\"expected the first startbeat to ne -\", 0, afterKeyChange.get(0), epsilon);\n        assertEquals(\"expected the first pitch to be -\", 9, afterKeyChange.get(1), epsilon);\n        assertEquals(\"expected the first notes duration to be -\", 1.5, afterKeyChange.get(2), epsilon);\n\n        assertEquals(\"expected the first startbeat to ne -\", 1.5, afterKeyChange.get(3), epsilon);\n        assertEquals(\"expected the first pitch to be -\", 10, afterKeyChange.get(4), epsilon);\n        assertEquals(\"expected the first notes duration to be -\", 1.5, afterKeyChange.get(5), epsilon);\n\n        /// testing incrememntally for pitch, basenote, startbest/offset, and duration\n     }\n}\n",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282936,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/bcsam-umustafi-yaatehr/test/karaoke/sound/happyBirthdayBrent.java",
    "data": "package karaoke.sound;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\n\nimport org.junit.Test;\n\n/**\n * Plays the music of pieces 1, 2, and 3\n * @author brentsamuels\n * @category no_didit\n */\npublic class happyBirthdayBrent {\n\n    @Test(expected=AssertionError.class)\n    public void testAssertionsEnabled() {\n        assert false; // make sure assertions are enabled with VM argument: -ea\n    }\n\n//@Test\n//public void testHappyBirthdayBrent() throws MidiUnavailableException, InvalidMidiDataException {\n//Instrument piano = Instrument.PIANO;\n//    \n//    final int beatsPerMinute = 100;\n//    final int ticksPerBeat = 64; // allows up to 1/64-beat notes to be played with fidelity\n//    SequencePlayer player = new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n//    \n//    final int beatsPerNote = 4;\n//    double defaultBeatLength = 1/8.0;\n//    \n//    \n//    List<Character> pitches = Arrays.asList('G', 'G', 'A', 'G', 'c', 'B',\n//                                            'G', 'G', 'A', 'G', 'd', 'c',\n//                                            'G', 'G', 'g', 'e', 'c', 'B', 'A',\n//                                             'f', 'f', 'e', 'c', 'd', 'c');\n//    List<Double> durations = Arrays.asList(\n//            3*defaultBeatLength/2.0,\n//            defaultBeatLength/2,\n//            2*defaultBeatLength,\n//            2*defaultBeatLength,\n//            2*defaultBeatLength,\n//            4*defaultBeatLength,\n//\n//            3*defaultBeatLength/2.0,\n//            defaultBeatLength/2,\n//            2*defaultBeatLength,\n//            2*defaultBeatLength,\n//            2*defaultBeatLength,\n//            4*defaultBeatLength,\n//\n//            3*defaultBeatLength/2.0,\n//            defaultBeatLength/2,\n//            2*defaultBeatLength,\n//            2*defaultBeatLength,\n//            2*defaultBeatLength,\n//            2*defaultBeatLength,\n//            6*defaultBeatLength,\n//\n//            3*defaultBeatLength/2.0,\n//            defaultBeatLength/2,\n//            2*defaultBeatLength,\n//            2*defaultBeatLength, \n//            2*defaultBeatLength,\n//            4*defaultBeatLength\n//            ); \n//    \n//    assert pitches.size() == durations.size();\n//    double startBeat = 0;\n//    \n//    for(int i=0; i<durations.size(); i++) {\n//        Character currentPitch = pitches.get(i);\n//        if(currentPitch.equals(Character.toLowerCase(currentPitch))) {\n//            player.addNote(piano, new Pitch(Character.toUpperCase(currentPitch)).transpose(Pitch.OCTAVE), startBeat, beatsPerNote*durations.get(i));\n//            startBeat += beatsPerNote*durations.get(i);\n//            \n//        }else {\n//            player.addNote(piano, new Pitch(currentPitch), startBeat, beatsPerNote*durations.get(i));\n//            startBeat += beatsPerNote*durations.get(i);\n//        }\n//    }\n//    \n//    // add a listener at the end of the piece to tell main thread when it's done\n//    Object lock = new Object();\n//    player.addEvent(startBeat, (Double beat) -> {\n//        synchronized (lock) {\n//            lock.notify();\n//        }\n//    });\n//    \n//    // print the configured player\n//    System.out.println(player);\n//    \n//    // play!\n//    player.play();\n//    \n//    // wait until player is done\n//    // (not strictly needed here, but useful for JUnit tests)\n//    synchronized (lock) {\n//        try {\n//            lock.wait();\n//        } catch (InterruptedException e) {\n//            return;\n//        }\n//    }\n//    System.out.println(\"done playing\");\n//    \n//}\n}",
    "submission": 36367,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282937,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/Junked./LyricElement.java",
    "data": "\n//TODO like just delete this idkwtf I'm doing. \n//package karaoke;\n//\n//import karaoke.sound.SequencePlayer;\n//\n//public class LyricElement {\n//    String element;\n////\n////    public double duration() {\n////        // TODO Auto-generated method stub\n////        return 0;\n////    }\n//    public LyricElement(String element) {\n//        this.element = element;\n//    }\n//\n//    @Override\n//    public int \n////    public void play(SequencePlayer player, double atBeat) {\n////        // TODO Auto-generated method stub\n////        \n////    }\n//\n//}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282938,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/Junked./LyricPlayer.java",
    "data": "//package karaoke.sound;\n//\n//import java.math.BigInteger;\n//import java.text.MessageFormat;\n//import java.time.Duration;\n//import java.util.HashMap;\n//import java.util.Map;\n//import java.util.SortedMap;\n//import java.util.TreeMap;\n//import java.util.function.Consumer;\n//\n//import javax.sound.midi.*;\n//\n///**\n// * Schedules and plays a sequence of notes using the MIDI synthesizer.\n// */\n//public class LyricPlayer /*implements SequencePlayer*/ {\n//\n//    /**\n//     * Default tempo.\n//     */\n//    public static final int DEFAULT_BEATS_PER_MINUTE = 120;\n//    /**\n//     * Default MIDI ticks per beat.\n//     */\n//    public static final int DEFAULT_TICKS_PER_BEAT = 64;\n//\n//    // the volume\n//    private static final int DEFAULT_VELOCITY = 100;\n//\n//    // the generic marker meta message type\n//    private static final int META_MARKER = 6;\n//    // the \"end_of_track\" meta message type\n//    private static final int META_END_OF_TRACK = 47;\n//\n////    // MIDI note number representing middle C\n////    private static final int MIDI_NOTE_MIDDLE_C = 60;\n//    \n////    // sound synthesizer\n////    private final Synthesizer synthesizer;\n//\n////    // active MIDI channels, assigned to instruments\n////    private final Map<Instrument, Integer> channelForInstrument = new HashMap<>();\n//\n////    // next available channel number (not assigned to an instrument yet)\n////    private int nextChannel = 0;\n//\n//    private final Sequencer sequencer;\n//    private final Track track;\n//    private final int beatsPerMinute;\n//    private final int ticksPerBeat;\n//\n//    // event callback functions\n//    private final SortedMap<Integer, Consumer<Double>> callbacks = new TreeMap<>();\n//    private final MetaMessage keepalive = new MetaMessage(META_MARKER, new byte[] { 0 }, 1);\n//\n//    /*\n//     * Rep invariant:\n//     *   sequencer and track are non-null,\n//     *   beatsPerMinute and ticksPerBeat are positive,\n//     *   callbacks are non-null,\n//     */\n//\n//    private void checkRep() {\n//        assert sequencer != null : \"sequencer should be non-null\";\n//        assert track != null : \"track should be non-null\";\n//        assert beatsPerMinute >= 0 : \"should be positive number of beats per minute\";\n//        assert ticksPerBeat >= 0 : \"should be positive number of ticks per beat\";\n//        assert callbacks != null : \"callbacks should be non-null\";\n//        assert callbacks.keySet().stream().allMatch(n -> n >= 1) : \"callback numbers should be positive\";\n////        assert ! channelForInstrument.values().contains(nextChannel) : \"nextChannel should not be assigned\";\n//    }\n//\n//    /**\n//     * Make a new MIDI sequence player with the default parameters.\n//     * @throws MidiUnavailableException if MIDI device unavailable\n//     * @throws InvalidMidiDataException if MIDI play fails\n//     */\n//    public LyricPlayer() throws MidiUnavailableException, InvalidMidiDataException {\n//        this(DEFAULT_BEATS_PER_MINUTE, DEFAULT_TICKS_PER_BEAT);\n//    }\n//\n//    /**\n//     * Make a new MIDI sequence player.\n//     * @param beatsPerMinute the number of beats per minute\n//     * @param ticksPerBeat the number of ticks per beat; every note plays for an integer number of ticks\n//     * @throws MidiUnavailableException if MIDI device unavailable\n//     * @throws InvalidMidiDataException if MIDI play fails\n//     */\n//    public LyricPlayer(int beatsPerMinute, int ticksPerBeat) throws MidiUnavailableException, InvalidMidiDataException{\n////        synthesizer = MidiSystem.getSynthesizer();\n////        synthesizer.open();\n////        synthesizer.loadAllInstruments(synthesizer.getDefaultSoundbank());\n//\n//        this.sequencer = MidiSystem.getSequencer();\n//\n//        // create a sequence object with with tempo-based timing, where\n//        // the resolution of the time step is based on ticks per quarter note\n//        Sequence sequence = new Sequence(Sequence.PPQ, ticksPerBeat);\n//        this.beatsPerMinute = beatsPerMinute;\n//        this.ticksPerBeat = ticksPerBeat;\n//\n//        // create an empty track; lyrics will be added to this track\n//        this.track = sequence.createTrack();\n//\n//        sequencer.setSequence(sequence);\n//\n//        checkRep();\n//    }\n//\n//    /**\n//     * Schedule a note to be played starting at startBeat for the duration numBeats.\n//     * @param startBeat the starting beat\n//     * @param numBeats the number of beats the note is played\n//     */\n//    public void addNote(String noteSound, double startBeat, double numBeats) {\n//        try {\n//            // schedule two events in the track, one for starting a note and\n//            // the other for ending the note.\n//            addMidiNoteEvent(ShortMessage.NOTE_ON, noteSound, (int) (startBeat * ticksPerBeat));  \n//            addMidiNoteEvent(ShortMessage.NOTE_OFF, noteSound, (int) ((startBeat + numBeats) * ticksPerBeat));\n//        } catch (InvalidMidiDataException imde) {\n//            String msg = MessageFormat.format(\"Cannot add note with the pitch {0} at beat {1} \" +\n//                                              \"for duration {2}\", noteSound, startBeat, numBeats);\n//            throw new RuntimeException(msg, imde);\n//        }\n//    }\n//\n//    /**\n//     * Schedule a MIDI note event.\n//     * @param eventType valid MidiMessage type in ShortMessage\n//     * @param channel valid channel\n//     * @param note valid pitch value\n//     * @param tick tick >= 0\n//     * @throws InvalidMidiDataException\n//     */\n//    private void addMidiNoteEvent(int eventType, String noteSound, int tick) throws InvalidMidiDataException {\n//        ShortMessage msg = new ShortMessage(eventType, noteSound, DEFAULT_VELOCITY);\n//        //ShortMessage msg = new ShortMessage(eventType, channel, note, DEFAULT_VELOCITY);\n//        this.track.add(new MidiEvent(msg, tick));\n//    }\n//\n//    /**\n//     * Schedule a callback when the synthesizer reaches a time.\n//     * @param atBeat beat at which to call the callback\n//     * @param callback function to call, with type double->void. \n//     *              The double parameter is the time when actually called, in beats.\n//     *              This time may be slightly different from atBeat because of rounding.\n//     */\n//    public void addEvent(double atBeat, Consumer<Double> callback) {\n//        int callbackNumber = saveCallback(callback);\n//        try {\n//            addMidiMetaEvent(callbackNumber, (int) (atBeat * ticksPerBeat));\n//        } catch (InvalidMidiDataException imde) {\n//            throw new RuntimeException(\"Cannot add event at beat \" + atBeat, imde);\n//        }\n//    }\n//\n//    /**\n//     * Schedule a callback when the synthesizer reaches a time.\n//     * @param atBeat beat at which to call the callback\n//     * @param callback function to call, with type double->void. \n//     *              The double parameter is the time when actually called, in beats.\n//     *              This time may be slightly different from atBeat because of rounding.\n//     */\n//    private int saveCallback(Consumer<Double> callback) {\n//        int key = callbacks.isEmpty() ? 1 : callbacks.lastKey() + 1;\n//        callbacks.put(key, callback);\n//        checkRep();\n//        return key;\n//    }\n//\n//    /**\n//     * Schedule a MIDI meta event.\n//     * @param callback active callback number\n//     * @param tick tick >= 0\n//     * @throws InvalidMidiDataException\n//     */\n//    private void addMidiMetaEvent(int callback, int tick) throws InvalidMidiDataException {\n//        byte[] bytes = BigInteger.valueOf(callback).toByteArray();\n//        MetaMessage msg = new MetaMessage(META_MARKER, bytes, bytes.length);\n//        this.track.add(new MidiEvent(msg, tick));\n//        this.track.add(new MidiEvent(keepalive, tick+1));\n//    }\n//\n//    /**\n//     * Play the scheduled lyrics.\n//     */\n//    public void play() {\n//        try {\n//            sequencer.open();\n//        } catch (MidiUnavailableException mue) {\n//            throw new RuntimeException(\"Unable to open MIDI sequencer\", mue);\n//        }\n//        sequencer.setTempoInBPM(this.beatsPerMinute);\n//\n//        sequencer.addMetaEventListener(meta -> {\n//            if (meta.getType() == META_MARKER) {\n//                // trigger event callback\n//                int callbackNumber = new BigInteger(meta.getData()).intValue();\n//                if (callbackNumber > 0) {\n//                    callbacks.remove(callbackNumber).accept(sequencer.getTickPosition() / (double)ticksPerBeat);\n//                }\n//            } else if (meta.getType() == META_END_OF_TRACK) {\n//                // allow the sequencer to finish\n//                try { Thread.sleep(Duration.ofSeconds(1).toMillis()); } catch (InterruptedException ie) { }\n//                // stop & close the sequencer\n//                sequencer.stop();\n//                sequencer.close();\n//            }\n//        });\n//\n//        // start playing!\n//        sequencer.start();\n//    }\n//\n////    /**\n////     * Get a MIDI channel for the given instrument, allocating one if necessary.\n////     * @param instr instrument\n////     * @return channel for the instrument\n////     */\n////    private int getChannel(Instrument instr) {\n////        // check whether this instrument already has a channel\n////        if (channelForInstrument.containsKey(instr)) {\n////            return channelForInstrument.get(instr);\n////        }\n////        \n////        int channel = allocateChannel();\n////        patchInstrumentIntoChannel(channel, instr);\n////        channelForInstrument.put(instr, channel);\n////        checkRep();\n////        return channel;\n////    }\n//\n////    /**\n////     * @return next available channel number\n////     */\n////    private int allocateChannel() {\n////        MidiChannel[] channels = synthesizer.getChannels();\n////        if (nextChannel >= channels.length) {\n////            throw new RuntimeException(\"Tried to use too many instruments: limited to \" + channels.length);\n////        }\n////        return nextChannel++;\n////    }\n//\n//    private void patchInstrumentIntoChannel(int channel, Instrument instr) {\n//        try {\n//            //addEvent(ShortMessage.PROGRAM_CHANGE, 0);\n//            addMidiNoteEvent(ShortMessage.PROGRAM_CHANGE, 0);\n//            //addNoteSoundEvent(ShortMessage.PROGRAM_CHANGE,0);\n//        } catch (InvalidMidiDataException imde) {\n//            throw new RuntimeException(\"Cannot set instrument\", imde);\n//        }\n//    }\n//\n////    /**\n////     * @return the MIDI note number for a pitch, defined as the number of\n////     *         semitones above C 5 octaves below middle C; for example,\n////     *         middle C is note 60\n////     */\n////    private static int getMidiNote(Pitch pitch) {\n////        return MIDI_NOTE_MIDDLE_C + pitch.difference(Pitch.MIDDLE_C);\n////    }\n//\n//    /**\n//     * @return a string that displays the entire track information as a\n//     *         sequence of MIDI events, where each event is either turning on\n//     *         or off a note at a certain tick, a marker event, or the end of\n//     *         the track\n//     */\n//    @Override\n//    public String toString() {\n//        String trackInfo = \"\";\n//\n//        for (int i = 0; i < track.size(); i++) {\n//            final MidiEvent e = track.get(i);\n//            final MidiMessage msg = e.getMessage();\n//            final String msgString;\n//\n//            if (msg instanceof ShortMessage) {\n//                final ShortMessage smg = (ShortMessage) msg;\n//                final int command = smg.getCommand();\n//                final String commandName;\n//\n//                if (command == ShortMessage.NOTE_OFF) {\n//                    commandName = \"NOTE_OFF\";\n//                } else if (command == ShortMessage.NOTE_ON) {\n//                    commandName = \"NOTE_ON \";\n//                } else {\n//                    commandName = \"Unknown command \" + command;\n//                }\n//\n//                msgString = \"Event: \" + commandName + \" Pitch: \" + smg.getData1() + \" \";\n//\n//            } else if (msg instanceof MetaMessage) {\n//                final MetaMessage mmg = (MetaMessage) msg;\n//                final int type = mmg.getType();\n//                final String typeName;\n//\n//                if (type == META_MARKER) {\n//                    typeName = \"MARKER\";\n//                } else if (type == META_END_OF_TRACK) {\n//                    typeName = \"END_OF_TRACK\";\n//                } else {\n//                    typeName = \"Unknown type \" + type;\n//                }\n//\n//                msgString = \"Meta event: \" + typeName;\n//\n//            } else {\n//                msgString = \"Unknown event\";\n//            }\n//\n//            trackInfo += msgString + \" Tick: \" + e.getTick() + \"\\n\";\n//        }\n//\n//        return trackInfo;\n//    }\n//\n////    public void addNote(Instrument instr, Pitch pitch, double startBeat, double numBeats) {\n////        // TODO Auto-generated method stub\n////        \n////    }\n////\n////    public void addNote(Instrument instr, Pitch pitch, double startBeat, double numBeats, LyricPlayer lyricPlayer) {\n////        // TODO Auto-generated method stub\n////        \n////    }\n//}\n//\n////package karaoke.sound;\n////import java.util.ArrayList;\n////import java.util.concurrent.LinkedBlockingQueue;\n////\n////import karaoke.Lyrics;\n////\n////public class LyricPlayer {\n////    private final LinkedBlockingQueue<String>lineOut;\n////    private int lineMemory;\n////    private final Lyrics lyrics; \n////    private int syllableMemory;\n////    \n////    //AF(lineOut, lineMemory, lyrics, syllableMemory): an externally-synced player for lyrics\n////    //  which shows a line (lineOut), defined by lineMemory, with a word (position defined by syllableMemory) emphasized.\n////    //  The line shown and word emphasized are determined by where the music is. \n////    //RI: lineOut and lyrics not null.  lineMemory and syllableMemory>=0.  lineMemory<length(lyrics)\n////    //Safety from rep exposure: all fields private. \n////    //  both blocking queue for the line to be printed and the lyrics are final and cannot be reassigned.\n////    //  public methods advance() and start() never pass a mutable or reassignable variable to client\n////    \n////    /**\n////     * create a new lyric player.\n////     * @param lyrics a string array of all the syllables in the music.\n////     */\n////    public LyricPlayer(Lyrics lyrics) {\n////        this.lineOut = new LinkedBlockingQueue<String>();\n////        this.lyrics = lyrics;\n////        this.syllableMemory = 0;\n////        this.lineMemory = 0;\n////    }\n////    \n////    /**\n////     * Advances through the lyrics\n////     * When advanced, goes ahead and puts in the blocking queue.\n////     * if have reached the end of the line, print the next, with the emphasis on the first syllable\n////     * if haven't, then advance a syllable \n////     */\n////    //TODO support repetition.  parser also needs this. \n////    public void advance() {  \n////        try {\n////            ArrayList<String>lyricLine = lyrics.getLyrics().get(lineMemory);\n////            if(lyricLine!=null) { //as long as there are more lines to read...\n////                if(lyricLine.get(syllableMemory)==null) {\n////                    lineMemory+=1;\n////                    syllableMemory = 0;\n////                }\n////                if (lyrics.getLyrics().get(lineMemory).get(syllableMemory).equals(\"_\")){\n////                    lyricLine.set(syllableMemory, \"*\"+lyricLine.get(syllableMemory-1)+\"*\");\n////                    lineOut.put(lyricLine.toString()); //TODO does not currently support multiple holds\n////                    syllableMemory+=1;\n////                }else {\n////                    lyricLine.set(syllableMemory, \"*\"+lyricLine.get(syllableMemory)+\"*\");\n////                    syllableMemory+=1;\n////                    lineOut.put(lyricLine.toString()); \n////                }\n////            }\n////        }catch(InterruptedException e) {\n////            System.out.println(\"something's wrong\");\n////        }\n////    }\n////    \n////    /**\n////     * starts a listener which blocks until there is something to pass to the listener\n////     * @return the changed board layout\n////     */\n////    public String start() {\n////        String lyricsOut;\n////        try {\n////            lyricsOut = lineOut.take();\n////            return lyricsOut;\n////        } catch (InterruptedException e) {\n////            e.printStackTrace();\n////        }\n////        return(\"should not be here\");//fail fast\n////    }\n////}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282939,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/Junked./Lyrics.java",
    "data": "//package karaoke;\n//import java.util.ArrayList;\n//import java.util.Arrays;\n//\n//public class Lyrics {\n//    private ArrayList<ArrayList<String>>lyrics;\n//    \n//    //AF(lyrics) = lyric data type consisting of the lyrics.\n//    //RI = lyrics not null\n//    //Limiting rep exposure: \n//    //  lyric field is private. \n//    //  defensive copy on the lyrics whenever returned to the client\n//    //  no other methods return a mutable or reassignable type to the client. \n//    \n//    //constructor\n//    public Lyrics(String text) {\n//        ArrayList<ArrayList<String>>lyricsByLine = new ArrayList<>();\n//        ArrayList<String>splitOnLine = new ArrayList<>(Arrays.asList(text.split(\"\\n\")));\n//        for(String line:splitOnLine) {\n//            ArrayList<String>lineBySyllable = new ArrayList<>(Arrays.asList(line.split(\"-| \"))); \n//            lyricsByLine.add(lineBySyllable);\n//        }\n//        this.lyrics = lyricsByLine;\n//        checkRep();\n//    }\n//    \n//    private void checkRep() {\n//        assert(lyrics!=null);\n//        for(ArrayList<String>line:lyrics) {\n//            assert (line!=null);\n//        }\n//    }\n//    \n//    /**\n//     * producer copies and returns the lyrics. \n//     * @return a copy of the lyrics\n//     */\n//    public ArrayList<ArrayList<String>> getLyrics() {\n//        ArrayList<ArrayList<String>>copyLyrics = new ArrayList<>();\n//        for(ArrayList<String>line:lyrics) {\n//            ArrayList<String>copyLine = new ArrayList<>();\n//            for(String syllable:line) {\n//                copyLine.add(syllable);\n//            }\n//            copyLyrics.add(copyLine);\n//        }\n//        checkRep();\n//        return copyLyrics; \n//    }\n//    \n//    @Override\n//    public int hashCode() {\n//        int hashCodeSum=0;\n//        for(ArrayList<String>line:this.lyrics) {\n//            for(String syllable:line) {\n//                hashCodeSum+=syllable.hashCode();\n//            }\n//        }\n//        checkRep();\n//        return hashCodeSum;\n//    }\n//\n//    @Override\n//    public boolean equals(Object obj) {\n//        if(!(obj instanceof Lyrics)) {\n//            checkRep();\n//            return false;\n//        }else {\n//            Lyrics lyricObj = (Lyrics) obj;\n//            checkRep();\n//            return(this.lyrics.equals(lyricObj.getLyrics()));  \n//        }\n//    }\n//    \n//    /**\n//     * @returns a string-representation of the lyrics with each line \n//     * on a new line.\n//     */\n//    @Override\n//    public String toString() {\n//        StringBuilder lyricString = new StringBuilder();\n//        for(ArrayList<String>line:lyrics) {\n//            for(String syllable:line) {\n//                if(syllable.equals(\"|\")|syllable.equals(\"-\")|syllable.equals(\"_\")) { //TODO check about the \"-\"\n//                    break;\n//                }else if(syllable.equals(\"~\")){\n//                    lyricString.append(\" \");\n//                }else{\n//                    lyricString.append(syllable);\n//                }\n//            }\n//            lyricString.append(\"\\n\");\n//        }\n//        checkRep();\n//        return lyricString.toString();\n//    }\n//}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282940,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/Junked./Syllable.java",
    "data": "\n//our alternative is to do this\n//when parsing make lyrics a list per line, each line a list of syllables with this. \n////play as normal. \n//package karaoke;\n//\n//import static karaoke.sound.Instrument.PIANO;\n//\n//import karaoke.sound.LyricPlayer;\n//import karaoke.sound.SequencePlayer;\n//\n///**\n// * Syllable represents a syllable to be sung in the piece\n// */\n//public class Syllable implements Music {\n//    private String syllable;\n//    private double duration;\n//    \n//    public Syllable(String syllable, double duration) {\n//        this.syllable = syllable;\n//        this.duration = duration;\n//    }\n//\n//    @Override public double duration() {\n//        return duration;\n//        // TODO return the duration of the note this syllable is on\n//    }\n//\n//    @Override public void play(LyricPlayer player, double atBeat) {\n//        player.addNote(noteSound, startBeat, numBeats);\n//    }\n//}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282941,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/examples/HostnameExample.java",
    "data": "package examples;\n\nimport java.io.IOException;\nimport java.net.Inet4Address;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.util.Collections;\n\npublic class HostnameExample {\n\n    /**\n     * Print the IPv4 hostnames that can be used to reach this machine.\n     * Falls back to an IP address if it can't find a hostname.\n     * Some of these addresses may not be usable from remote machines:\n     * examples include localhost, 10.x.x.x, 172.x.x.x, 192.x.x.x.\n     * \n     * @param args unused\n     * @throws IOException if network problem\n     */\n    public static void main(String[] args) throws IOException {\n        for (NetworkInterface iface : Collections.list(NetworkInterface.getNetworkInterfaces())) {\n            for (InetAddress address: Collections.list(iface.getInetAddresses())) {\n                if (address instanceof Inet4Address) {\n                    String name = address.getHostName();\n                    if(!(name.startsWith(\"10.\")) && !(name.startsWith(\"172.\")) && !(name.startsWith(\"192.\"))) {\n                        System.out.println(\"ADDRESS HERE\"+address.getHostName());\n                    }\n\n                }\n            }\n        }\n    }\n    \n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282942,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/examples/ScaleExample.java",
    "data": "//package examples;\n//\n//import javax.sound.midi.InvalidMidiDataException;\n//import javax.sound.midi.MidiUnavailableException;\n//\n//import karaoke.sound.Instrument;\n//import karaoke.sound.MidiSequencePlayer;\n//import karaoke.sound.Pitch;\n//import karaoke.sound.SequencePlayer;\n//\n//public class ScaleExample {\n//    \n//    /**\n//     * Play an octave up and back down starting from middle C.\n//     * \n//     * @param args not used\n//     * @throws MidiUnavailableException if MIDI device unavailable\n//     * @throws InvalidMidiDataException if MIDI play fails\n//    */\n//    public static void main(String[] args) throws MidiUnavailableException, InvalidMidiDataException {\n//\n//        Instrument piano = Instrument.PIANO;\n//\n//        // create a new player\n//        final int beatsPerMinute = 120; // a beat is a quarter note, so this is 120 quarter notes per minute\n//        final int ticksPerBeat = 64; // allows up to 1/64-beat notes to be played with fidelity\n//        SequencePlayer player = new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n//        \n//        // addNote(instr, pitch, startBeat, numBeats) schedules a note with pitch value 'pitch'\n//        // played by 'instr' starting at 'startBeat' to be played for 'numBeats' beats.\n//        \n//        int startBeat = 0;\n//        int numBeats = 1;\n//        player.addNote(piano, new Pitch('C'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('D'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('E'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('F'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('G'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('A'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('B'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('C').transpose(Pitch.OCTAVE), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('B'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('A'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('G'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('F'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('E'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('D'), startBeat++, numBeats);\n//        player.addNote(piano, new Pitch('C'), startBeat++, numBeats);\n//        \n//        // add a listener at the end of the piece to tell main thread when it's done\n//        Object lock = new Object();\n//        player.addEvent(startBeat, (Double beat) -> {\n//            synchronized (lock) {\n//                lock.notify();\n//            }\n//        });\n//        \n//        // print the configured player\n//        System.out.println(player);\n//\n//        // play!\n//        player.play();\n//        \n//        // wait until player is done\n//        // (not strictly needed here, but useful for JUnit tests)\n//        synchronized (lock) {\n//            try {\n//                lock.wait();\n//            } catch (InterruptedException e) {\n//                return;\n//            }\n//        }\n//        System.out.println(\"done playing\");\n//    }\n//}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282943,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/examples/StreamingExample.java",
    "data": "package examples;\n\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.Executors;\n\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpServer;\n\npublic class StreamingExample {\n\n    /**\n     * Web server that demonstrates several ways to stream text to a web browser.\n     *     \n     * @param args not used\n     * @throws IOException if network failure\n     */\n    public static void main(String[] args) throws IOException {\n        \n        // make a web server\n        final int serverPort = 4567;\n        final HttpServer server = HttpServer.create(new InetSocketAddress(serverPort), 0);\n        \n        // handle concurrent requests with multiple threads\n        server.setExecutor(Executors.newCachedThreadPool());\n\n        // register handlers\n        server.createContext(\"/textStream\", StreamingExample::textStream);\n        server.createContext(\"/htmlStream\", StreamingExample::htmlStream);\n        server.createContext(\"/htmlWaitReload\", StreamingExample::htmlWaitReload);\n\n        // start the server\n        server.start();\n        System.out.println(\"server running, browse to one of these URLs:\");\n        System.out.println(\"http://localhost:4567/textStream\");\n        System.out.println(\"http://localhost:4567/htmlStream\");\n        System.out.println(\"http://localhost:4567/htmlStream/autoscroll\");\n        System.out.println(\"http://localhost:4567/htmlWaitReload\");\n    }\n    \n    /**\n     * This handler sends a plain text stream to the web browser,\n     * one line at a time, pausing briefly between each line.\n     * Returns after the entire stream has been sent.\n     * \n     * @param exchange request/reply object\n     * @throws IOException if network problem\n     */\n    private static void textStream(HttpExchange exchange) throws IOException {\n        final String path = exchange.getRequestURI().getPath();\n        System.err.println(\"received request \" + path);\n\n        // plain text response\n        exchange.getResponseHeaders().add(\"Content-Type\", \"text/plain; charset=utf-8\");\n\n        // must call sendResponseHeaders() before calling getResponseBody()\n        final int successCode = 200;\n        final int lengthNotKnownYet = 0;\n        exchange.sendResponseHeaders(successCode, lengthNotKnownYet);\n\n        // get output stream to write to web browser\n        final boolean autoflushOnPrintln = true;\n        PrintWriter out = new PrintWriter(\n                              new OutputStreamWriter(\n                                  exchange.getResponseBody(), \n                                  StandardCharsets.UTF_8), \n                              autoflushOnPrintln);\n        \n        try {\n            // IMPORTANT: some web browsers don't start displaying a page until at least 2K bytes\n            // have been received.  So we'll send a line containing 2K spaces first.\n            final int enoughBytesToStartStreaming = 2048;\n            for (int i = 0; i < enoughBytesToStartStreaming; ++i) {\n                out.print(' ');\n            }\n            out.println(); // also flushes\n            \n            final int numberOfLinesToSend = 100;\n            final int millisecondsBetweenLines = 200;\n            for (int i = 0; i < numberOfLinesToSend; ++i) {\n                \n                // print a line of text\n                out.println(System.currentTimeMillis()); // also flushes\n\n                // wait a bit\n                try {\n                    Thread.sleep(millisecondsBetweenLines);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n            \n        } finally {\n            exchange.close();\n        }\n        System.err.println(\"done streaming request\");\n    }\n\n    /**\n     * This handler sends a stream of HTML to the web browser,\n     * pausing briefly between each line of output.\n     * Returns after the entire stream has been sent.\n     * \n     * @param exchange request/reply object\n     * @throws IOException if network problem\n     */\n    private static void htmlStream(HttpExchange exchange) throws IOException {\n        final String path = exchange.getRequestURI().getPath();\n        System.err.println(\"received request \" + path);\n    \n        final boolean autoscroll = path.endsWith(\"/autoscroll\");\n        \n        // html response\n        exchange.getResponseHeaders().add(\"Content-Type\", \"text/html; charset=utf-8\");\n        \n        // must call sendResponseHeaders() before calling getResponseBody()\n        final int successCode = 200;\n        final int lengthNotKnownYet = 0;\n        exchange.sendResponseHeaders(successCode, lengthNotKnownYet);\n\n        // get output stream to write to web browser\n        final boolean autoflushOnPrintln = true;\n        PrintWriter out = new PrintWriter(\n                              new OutputStreamWriter(\n                                  exchange.getResponseBody(), \n                                  StandardCharsets.UTF_8), \n                              autoflushOnPrintln);\n        \n        try {\n\n            // IMPORTANT: some web browsers don't start displaying a page until at least 2K bytes\n            // have been received.  So we'll send a line containing 2K spaces first.\n            final int enoughBytesToStartStreaming = 2048;\n            for (int i = 0; i < enoughBytesToStartStreaming; ++i) {\n                out.print(' ');\n            }\n            out.println(); // also flushes\n            \n            final int numberOfLinesToSend = 100;\n            final int millisecondsBetweenLines = 200;\n            for (int i = 0; i < numberOfLinesToSend; ++i) {\n                \n                // print a line of text\n                out.println(System.currentTimeMillis() + \"<br>\"); // also flushes\n                \n                if (autoscroll) {\n                    // send some Javascript to browser that makes it scroll down to the bottom of the page,\n                    // so that the last line sent is always in view\n                    out.println(\"<script>document.body.scrollIntoView(false)</script>\");\n                }\n                \n                // wait a bit\n                try {\n                    Thread.sleep(millisecondsBetweenLines);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n            \n        } finally {\n            exchange.close();\n        }\n        System.err.println(\"done streaming request\");\n    }\n\n\n    /**\n     * This handler waits for an event to occur in the server\n     * before sending a complete HTML page to the web browser.\n     * The page ends with a Javascript command that immediately starts\n     * reloading the page at the same URL, which causes this handler to be\n     * run, wait for the next event, and send an updated HTML page.\n     * In this simple example, the \"server event\" is just a brief timeout, but it\n     * could synchronize with another thread instead.\n     * \n     * @param exchange request/reply object\n     * @throws IOException if network problem\n     */\n    private static void htmlWaitReload(HttpExchange exchange) throws IOException {\n        final String path = exchange.getRequestURI().getPath();\n        System.err.println(\"received request \" + path);\n\n        // html response\n        exchange.getResponseHeaders().add(\"Content-Type\", \"text/html; charset=utf-8\");\n        \n        // must call sendResponseHeaders() before calling getResponseBody()\n        final int successCode = 200;\n        final int lengthNotKnownYet = 0;\n        exchange.sendResponseHeaders(successCode, lengthNotKnownYet);\n\n        // get output stream to write to web browser\n        final boolean autoflushOnPrintln = true;\n        PrintWriter out = new PrintWriter(\n                              new OutputStreamWriter(\n                                  exchange.getResponseBody(), \n                                  StandardCharsets.UTF_8), \n                              autoflushOnPrintln);\n        \n        try {\n\n            // Wait until an event occurs in the server.\n            // In this example, the event is just a brief fixed-length delay, but it\n            // could synchronize with another thread instead.\n            final int millisecondsToWait = 200;\n            try {\n                Thread.sleep(millisecondsToWait);\n            } catch (InterruptedException e) {\n                return;\n            }\n            \n            // Send a full HTML page to the web browser\n            out.println(System.currentTimeMillis() + \"<br>\");\n            \n            // End the page with Javascript that causes the browser to immediately start \n            // reloading this URL, so that this handler runs again and waits for the next event\n            out.println(\"<script>location.reload()</script>\");\n            \n        } finally {\n            exchange.close();\n        }\n        System.err.println(\"done streaming request\");\n    }\n\n\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282944,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Chord.java",
    "data": "package karaoke;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\nimport karaoke.sound.SequencePlayer;\n\n/**\n * Chord represents a several notes played by an instrument at the same time.\n */\npublic class Chord implements Music {\n\n    private final List<Note> notes;\n    private final String lyric;\n    \n    // Abstraction function\n    //    AF(notes,lyrics) \n    //      = represents 2 or more musical notes that start at the same beat and are played \n    //        by the same instrument,\n    //      also has the lyric sung to it\n    // Rep invariant\n    //    notes.length() >= 1\n    // Safety from rep exposure\n    //    all fields are final\n    //    fields are private and all methods used by clients return immutable types\n    \n    private void checkRep() {\n        assert notes.size()>=1;\n        assert lyric !=null;\n    }\n\n    /**\n     * Make a Chord played by instrument for duration beats.\n     * @param notes Notes that make up the chord\n     * @param lyric lyric sung with chord\n     */\n    public Chord(List<Note> notes, String lyric) {\n        this.notes = notes;\n        this.lyric = lyric;\n        checkRep();\n    }\n\n    /**\n     * @return pitches of the Notes\n     */\n    public List<Pitch> pitches() {\n        final ArrayList<Pitch> pitches = new ArrayList<>();\n        for (Note n:notes) {\n            pitches.add(n.pitch());\n        }\n        checkRep();\n        return Collections.unmodifiableList(pitches);\n    }\n\n    /**\n     * @return duration of this chord in number of beats\n     */\n    @Override\n    public double duration() { \n        Note firstNote = notes.get(0);\n        return firstNote.duration();\n    }\n\n    /**\n     * Adds the notes to the sequence player so the player can play this chord.\n     */\n    @Override\n    public void play(SequencePlayer player, double atBeat, Optional<LyricListener> listener) {\n        for (int noteIdx = 0; noteIdx<notes.size(); noteIdx++) {\n            notes.get(noteIdx).play(player, atBeat, listener);\n        }\n        checkRep();\n    }\n    \n    @Override\n    public boolean hasVoices() {\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int hashSum = 0;\n        for(Note n:notes) {\n            hashSum+=n.hashCode();\n        }\n        return hashSum;\n    }\n\n    @Override \n    public boolean equals(Object obj) {\n        if(!(obj instanceof Chord)) {\n            return false;\n        }else {\n            Chord chordObj = (Chord) obj;\n            return (notes.equals(chordObj.notes));\n        }\n    }\n    \n    /**\n     * @return string representing the chord in the form:\n     * [notes] where notes is 1+ notes separated by commas\n     */\n    @Override\n    public String toString() {\n        ArrayList<String>noteString = new ArrayList<>();\n        for(Note n: notes) {\n            noteString.add(n.toString());\n        }\n        return noteString.toString();\n    }\n}",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282945,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Composition.java",
    "data": "package karaoke;\n\nimport java.io.IOException;\n\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.parser.KaraokeParser;\n\n/**\n * An immutable data type containing a Header and body of Music.\n * Header contains information about the music. Information entails:\n * composer, piece number, title, key, default note length, meter and voices\n * The body contains a Music datatype that represents the music to be played\n */\npublic class Composition {\n    private final Header header;\n    private final Music body;\n    \n    \n    /**\n     * Creates a composition with information in Header and Music in body\n     * @param header contains information about the composition\n     * @param body a music of \n     */\n    public Composition(Header header, Music body) {\n        this.header = header;\n        this.body = body;\n    }\n    \n    /**\n     * Parse body of music and header.\n     * @param filename path of music to parse, as defined in the karaoke Spec.\n     * @return music AST for the input\n     * @throws IllegalArgumentException if syntactically invalid.\n     * @throws IOException if file can't be read\n     */\n    public static Composition parse(String filename) throws IOException{\n       try {\n           return KaraokeParser.parse(filename);\n       } catch (UnableToParseException e) {\n           throw new IllegalArgumentException(\"Composition is invalid\");\n       }\n    }\n    \n    /**\n     * \n     * @return the header of the composition\n     */\n    public Header getHeader() {\n        return header;\n    }\n    \n    \n    /**\n     * \n     * @return the composer of the composition\n     */\n    public String getComposer() {\n        return header.getComposer();\n    }\n    \n    /**\n     * \n     * @return the title of the composition\n     */\n    public  String getTitle() {\n        return header.getTitle();\n    }\n    \n    /**\n     * @return the body of the composition\n     */\n    public Music getBody() {\n        return body;\n    }\n    \n    /**\n     *  plays the body of the composition\n     */\n    public void play() {\n        \n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282946,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Concat.java",
    "data": "package karaoke;\n\nimport java.util.Optional;\n\nimport karaoke.sound.SequencePlayer;\n\n/**\n * Concat represents two pieces of music played one after the other.\n */\npublic class Concat implements Music {\n\n    private final Music first;\n    private final Music second;\n    \n    // Abstraction function\n    //    AF(first, second) \n    //      = represents a piece of music that is first followed by second in chronological order of sound\n    // Rep invariant\n    //    first != null, second != null\n    // Safety from rep exposure\n    //    all fields are final.\n    //    no public methods return a mutable type or alias\n    \n    private void checkRep() {\n        assert first!=null;\n        assert second!=null;\n    }\n\n    /**\n     * Make a Music sequence that plays m1 followed by m2.\n     * @param m1 music to play first\n     * @param m2 music to play second\n     */\n    public Concat(Music m1, Music m2) {\n        this.first = m1;\n        this.second = m2;\n        checkRep();\n    }\n\n    /**\n     * @return first piece in this concatenation\n     */\n    private Music first() {\n        return first;\n    }\n\n    /**\n     * @return second piece in this concatenation\n     */\n    private Music second() {\n        return second;\n    }\n\n    /**\n     * @return duration of this concatenation\n     */\n    @Override\n    public double duration() {\n        return first.duration() + second.duration();\n    }\n\n    /**\n     * Play this concatenation.\n     */\n    @Override\n    public void play(SequencePlayer player, double atBeat, Optional<LyricListener> listener) {\n        first.play(player, atBeat, listener);\n        second.play(player, atBeat + first.duration(), listener);\n    }\n    \n    @Override\n    public boolean hasVoices() {\n        return false;\n    }\n    \n    @Override\n    public int hashCode() {\n        return (first.hashCode()+second.hashCode());\n    }\n\n    @Override \n    public boolean equals(Object obj) {\n        if(!(obj instanceof Concat)) {\n            return false;\n        }\n        Concat concatObj = (Concat) obj;\n        checkRep();\n        return(first.equals(concatObj.first())\n                &&second.equals(concatObj.second()));\n    }\n    /**\n     * @returns a string representing the combined music \n     * by taking two music string representations and putting one after the other with a space between\n     */\n    @Override \n    public String toString() {\n        StringBuilder concat = new StringBuilder();\n        concat.append(first.toString());\n        concat.append(\" \");\n        concat.append(second.toString());\n        return concat.toString();\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282947,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Header.java",
    "data": "package karaoke;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * An immutable data type containing information about a piece of music. Information entails:\n * composer, piece number, title, key, default note length, meter and voices\n */\npublic class Header {\n    \n    private final int pieceNumber;\n    private final String title;\n    private final String composer;\n    private final double meter;\n    private final double noteLength;\n    private final int tempo;  \n    private final String key;\n    private final List<String> voices;\n    \n    // Abstraction function\n    //    AF(int pieceNumber, String title, String composer, double meter, double noteLength, double tempo, String key) \n    //      = information about a musical piece: Index Number, Title, Composer, Default Note Length, Voices, Meter Tempo, Key Signature\n    // Rep invariant\n    //    all variables are not-null\n    //    meter, notelength, and tempo are all non-negative\n    // Safety from rep exposure\n    //    all fields are final.\n    //    no mutable fields ore aliases are shared with the client.\n    \n    private void checkRep() {\n       assert(title!=null);\n       assert(composer!=null);\n       assert meter>=0;\n       assert noteLength>=0;\n       assert tempo>=0;\n       assert(key!=null);\n       assert(voices!=null);\n    }\n    \n    /**\n     * \n     * @param pieceNumber  Index number, similar to the track number in a recording \n     * @param title Title of the piece.\n     * @param composer Name of the composer.\n     * @param meter Meter. It determines the sum of the durations of all notes within a bar.\n     * @param noteLength Default length or duration of a note.\n     * @param tempo Tempo. It represents the number of beats of the given length to play per minute.\n     * @param key Key, which determines the key signature for the piece.\n     * @param voices The list of voices \n     */\n    public Header(int pieceNumber, String title, String composer, double meter, double noteLength, int tempo, String key, List<String> voices) {\n        this.pieceNumber = pieceNumber;\n        this.title = title;\n        this.composer = composer;\n        this.meter = meter;\n        this.noteLength = noteLength;\n        this.tempo = tempo;\n        this.key = key;\n        this.voices = new ArrayList<>(voices); \n        checkRep();\n    }\n    \n    /**\n     * \n     * @return the index of the piece\n     */\n    public double getIdx() {\n        return this.pieceNumber;\n    }\n    \n    /**\n     * \n     * @return the key of the piece\n     */\n    public String getKey() {\n        return this.key;\n    }\n    \n    /**\n     * \n     * @return the meter of the piece\n     */\n    public double getMeter() {\n        return this.meter;\n    }\n    \n    /**\n     * \n     * @return the default note length of the piece\n     */\n    public double getNoteLength() {\n        return this.noteLength;\n    }\n    \n    /**\n     * \n     * @return the tempo of the piece\n     */\n    public int getTempo() {\n        return this.tempo;\n    }\n    \n    \n    /**\n     * \n     * @return the composer of the piece\n     */\n    public String getComposer() {\n        return this.composer;\n    }\n    \n    /**\n     * \n     * @return the title of the piece\n     */\n    public String getTitle() {\n        return this.title;\n    }\n   \n    /**\n     * @return the voices used in this piece\n     */\n    public List<String> getVoices() {\n        return new ArrayList<>(voices); // make a copy to prevent rep exposure\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282948,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/LyricListener.java",
    "data": "package karaoke;\n\nimport java.io.PrintWriter;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class LyricListener {\n    private final LinkedBlockingQueue<String> lyrics;\n    private final PrintWriter printer; \n    \n    //AF(lyrics, printer) = a listener that, when given a message prints it on printer for the caller\n    //Represention invariant: lyrics is not null\n    //Safety from rep exposure: fields are private and final.  \n    //  no mutable copy of it is shared with callers.\n    //  in particular: lyrics queue is not passed for mutation\n    //  printer is accessed through a method as a way of printing, and only allows writes into it\n    //Thread safety: only ever called from one thread. \n    \n    private void checkRep() {\n        assert lyrics !=null;\n        assert printer !=null;\n    }\n    /**\n     * creates a lyricListener object\n     * @param printer which prints to the machine on which it originated\n     */\n    public LyricListener(PrintWriter printer) {\n        this.lyrics = new LinkedBlockingQueue<String>();\n        this.printer = printer;\n        checkRep();\n    }\n    \n    /**\n     * starts the listener which blocks until there is something to pass to the caller\n     */\n    public void start() {\n        try {\n            lyrics.take();\n        } catch(InterruptedException e) {\n            e.printStackTrace();\n        }\n        checkRep();\n    }\n    \n    /**\n     * puts a lyric into the printer.\n     * @param lyricString the lyrics to be streamed\n     */\n    public void p(String lyricString) {\n        printer.println(lyricString);\n        checkRep();\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282949,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Main.java",
    "data": "package karaoke;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.parser.KaraokeParser;\nimport karaoke.sound.MidiSequencePlayer;\nimport karaoke.sound.WebServer;\nimport java.net.Inet4Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.util.Collections;\n\n/**\n * Main entry point of karaoke application.\n * Console interface with the karaoke.  \n * If a path to a valid music file is entered into console:\n *      gives URL of where lyrics can be shown\n *      instructs participants to enter command play\n * Upon entering another key, starts music playback for whomever pressed first\n * and stops others from entering.  \n */\npublic class Main {\n    \n    /**\n     * read in music file.  Give URL of web server to show the lyrics,\n     * starts waiter for playing music and if any key is pressed, will start to play music \n     * on that server \n     * @param args music's file path\n     * @throws IOException \n     */\n    public static void main(String[] args) throws IOException {\n        \n        LinkedBlockingQueue<String>time = new LinkedBlockingQueue<>(); \n        final Queue<String> arguments = new LinkedList<>(Arrays.asList(args));\n        final String filePath;\n        final Composition composition;\n        \n        //filename for composition taken from serverMain of ps4.  \n        if (arguments.size() == 1) {\n            filePath = arguments.remove();\n            composition = Composition.parse(filePath);\n        } else {\n            throw new IllegalArgumentException(\"expected COMPOSITION...\");\n        }\n        \n        //make web server listening on port 8080 \n        int portDefault = 8080;\n        String host = getHost();\n        InetSocketAddress addr = new InetSocketAddress(host, portDefault);\n        MidiSequencePlayer player=makePlayer(filePath); \n        new WebServer(player, filePath, addr, time).start();\n       \n        //instructions on what to do to start play back and streaming.\n        Music body = composition.getBody(); \n        System.out.print(getTitleComposer(composition)+\n                \"\\nTo view music use your browser to navigate to \" );\n        if (body.hasVoices()) { //multiple voices\n            MultipleVoice multivoice = (MultipleVoice)body;\n            System.out.println(\"one of \");\n            for(String voice:multivoice.getVoices()) {\n                System.out.println(\"http://\"+host+\":\"+portDefault+\"/play/\"+filePath+\"/\"+voice);  \n            }\n        }else { //single voice\n            System.out.println(\"http://\"+host+\":\"+portDefault+\"/play/\"+filePath); //build the correct URL\n        }\n        System.out.println(\"\\nTo play music press enter\");\n        \n        //set up wait for cue to start\n        final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        in.readLine();\n        try {\n            time.put(\" \");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }  \n    }\n    \n    /**\n     * Gets the song title and composer name (if applicable) from the Music type\n     * @param composition whose title and composer is being sought\n     * @return the title and composer of the music, spaced on two lines.\n     */\n    private static String getTitleComposer(Composition composition) {\n        return composition.getTitle() + \"\\n\" + composition.getComposer();\n    }\n    \n    \n    /**\n     * Makes a MidiSequencePlayer\n     * @param filePath the file intended to play.\n     * @return a Midi Sequence Player with the appropriate tempo to match the piece specified.\n     */\n    public static MidiSequencePlayer makePlayer(String filePath) {\n        try {\n            Header header = KaraokeParser.parse(filePath).getHeader();\n            int beatsPerMinute = header.getTempo();\n            int ticksPerBeat = MidiSequencePlayer.DEFAULT_TICKS_PER_BEAT; \n            MidiSequencePlayer player =  new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n            return player;\n        }catch(IOException IOE) {\n            IOE.printStackTrace();\n        }catch (UnableToParseException UnableToParseE) {\n            UnableToParseE.printStackTrace();\n        }catch (MidiUnavailableException MidiUnavailableE) {\n            MidiUnavailableE.printStackTrace();\n        }catch (InvalidMidiDataException InvalidMidiE) {\n            InvalidMidiE.printStackTrace();\n        }\n        return null; \n    }\n    \n    /**\n     * Getting the IP address of a viable server.  \n     * @return IP address of the localhost: IPV4, with private servers filtered out.\n     * @throws SocketException \n     */\n    private static String getHost() throws SocketException {\n        for (NetworkInterface iface : Collections.list(NetworkInterface.getNetworkInterfaces())) {\n            for (InetAddress address: Collections.list(iface.getInetAddresses())) {\n                if (address instanceof Inet4Address) {\n                    String name = address.getHostAddress();\n                    if(!(name.startsWith(\"10.\")) && !(name.startsWith(\"172.\")) && !(name.startsWith(\"192.\"))) {\n                        return name;\n                \n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282950,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/MultipleVoice.java",
    "data": "package karaoke;\n\nimport java.util.HashMap;\nimport java.util.Optional;\nimport java.util.ArrayList;\n\nimport karaoke.sound.SequencePlayer;\n\npublic class MultipleVoice implements Music{\n    private final HashMap<String, Music> voiceMap;\n    \n    // Abstraction function\n    //    AF(voiceMap)=  \n    //          a map of voice name to a music piece. \n    //    Rep invariant\n    //          each voice has an equal duration\n    //    Safety from rep exposure\n    //          voiceMap field is private and final\n    //          public methods never return it, or any aliases to it, to the client.\n    \n    private void checkRep() {\n        ArrayList<Double> durations = new ArrayList<>();\n        for (String voice : voiceMap.keySet()) {\n            durations.add(voiceMap.get(voice).duration());\n        }\n       //checks if all durations are the same\n        assert durations.stream().distinct().limit(2).count() <= 1;\n    }\n    \n    /**\n     * Constructor creates a piece consisting of multiple voices that play at the same time\n     * each piece may have its own \n     * @param voiceMap a lookup of the Multiple Voice's components: an ID of the component to its music.\n     */\n    public MultipleVoice(HashMap<String,Music> voiceMap) {\n        this.voiceMap = voiceMap;\n        checkRep();\n    }\n    \n    /**\n     * adds a new voice to the Multiple Voice \n     * @param iD the name of the voice\n     * @param music the melody and lyrics that the ID identifies. \n     */\n    public void addVoice(String iD, Music music) {\n        voiceMap.put(iD, music);\n        checkRep();\n    }\n    \n    @Override\n    public boolean hasVoices() {\n        return true;\n    }\n    \n    /**\n     * returns a list of the voices that the MultipleVoice has\n     * @return voices list of voices that MultipleVoice has. \n     */\n    public ArrayList<String> getVoices(){\n        ArrayList<String>voices = new ArrayList<>();\n        for(String voice:voiceMap.keySet()) {\n            voices.add(voice);\n        }\n        return voices;\n    }\n    \n    /**\n     * gets a particular piece of music based on its ID\n     * @param iD of the music desired\n     * @return music identified by the ID.\n     */\n    public Music getPiece(String iD) {\n        return voiceMap.get(iD);\n    }\n    /**\n     * the duration of the longest voice in the music\n     * @return the duration of the longest voice\n     */\n    @Override\n    public double duration() {\n        double maxDuration = 0;\n        for(String pieceID:voiceMap.keySet()) {\n            Music musicPiece = voiceMap.get(pieceID);\n            if(musicPiece.duration()>maxDuration) {\n                maxDuration = musicPiece.duration();\n            }\n        }\n        checkRep();\n        return maxDuration;\n    }\n    \n    @Override\n    public void play(SequencePlayer player, double atBeat, Optional<LyricListener> listener) {\n        for(String pieceID:voiceMap.keySet()) {\n            Music musicPiece = voiceMap.get(pieceID);\n            musicPiece.play(player, atBeat, listener);\n        }\n        checkRep();\n    }\n    @Override\n    public String toString() {\n        return voiceMap.toString();\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282951,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Music.java",
    "data": "package karaoke;\n\nimport java.util.Optional;\n\nimport karaoke.sound.SequencePlayer;\n\n/**\n * An immutable data type representing a piece of music played by multiple instruments.\n */\npublic interface Music {\n    \n    // Datatype definition\n    //    Music = Note(duration:double, pitch:Pitch, instrument:instrument)\n    //                 + Rest(duration:double)\n    //                 + Chord(notes:List<Note>)\n    //                 + Concat(first:Music, second:Music)\n    //                 + Lyrics(soundedelements)\n    \n    \n    /**\n     * @return total number of beats in the duration of this piece\n     */\n    double duration();\n\n    /**\n     * Play this piece along with its lyrics\n     * @param player player to play on\n     * @param atBeat the beat at when to play\n     * @param listener whom to report lyrics to when the lyrics are required\n     * can be null\n     */\n    void play(SequencePlayer player, double atBeat, Optional<LyricListener> listener);\n    \n    /**\n     * if the music type has voices in it.\n     * @return true if the music is represented as multiple voices, false otherwise \n     */\n    boolean hasVoices();\n    \n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282952,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Note.java",
    "data": "package karaoke;\n\nimport karaoke.sound.SequencePlayer;\nimport static karaoke.sound.Instrument.*;\n\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\n/**\n * Note represents a note played by an instrument and the lyric that accompanies it.\n */\npublic class Note implements Music {\n\n    private final double duration;\n    private final Pitch pitch;\n    private final String lyric;\n    \n    // Abstraction function\n    //    AF(duration, pitch, lyric) \n    //      = represents a musical note that lasts duration beats and has a lyric sung to it\n    // Rep invariant\n    //    duration > 0\n    // Safety from rep exposure\n    //    all fields are immutable and final\n\n    private void checkRep() {\n        assert duration >= 0;\n        assert pitch != null;\n        assert lyric != null;\n    }\n    \n    /**\n     * Make a Note played by instrument for duration beats.\n     * @param duration duration in beats, must be >= 0\n     * @param pitch pitch to play\n     * @param lyric the lyric sung with the note\n     */\n    public Note(double duration, Pitch pitch, String lyric) {\n        this.duration = duration;\n        this.pitch = pitch;\n        this.lyric = lyric;\n        checkRep();\n    }\n\n    /**\n     * @return pitch of this note\n     */\n    public Pitch pitch() {\n        return pitch;\n    }\n\n    /**\n     * @return duration of this note in number of beats\n     */\n    @Override\n    public double duration() {\n        return duration;\n        \n    }\n    \n    /**\n     * @return lyric sung to this note\n     */\n    public String lyric() {\n        return lyric;\n    }\n    \n    @Override\n    public boolean hasVoices() {\n        return false;\n    }\n\n    /**\n     * Adds the note to the sequence player so the player can play this note.\n     * Creates a callback so when played, the lyrics are output to a listener\n     * @param player to populate with notes\n     * @param atBeat how many beats after the player start the note should be placed\n     * @param listener to be notified when the note is played. \n     */\n    @Override\n    public void play(SequencePlayer player, double atBeat, Optional<LyricListener> listener) {\n        player.addNote(NYLON_STR_GUITAR, pitch, atBeat, duration);\n        if(listener.isPresent()) {\n          //add a lyric event player takes the callback. \n            Consumer<Double>callBack = callBackBeat -> {listener.get().p(lyric);}; \n            player.addEvent(atBeat, callBack); \n            checkRep();\n        }\n\n        \n    }\n\n    @Override\n    public int hashCode() {\n        return (Double.hashCode(duration)+pitch.hashCode());\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if(!(obj instanceof Note)) {\n            checkRep();\n            return false;\n        }\n        Note noteObj = (Note) obj;\n        checkRep();\n        return(duration==noteObj.duration \n                &&pitch.equals(noteObj.pitch));\n    }\n    \n    @Override\n    /**\n     * @returns a string-representation of a given note in the form.\n     * accidental? noteBase octave? length?\n     * Where accidental is ' or ''\n     *      noteBase is one of A-G, \n     *      octave is one of ^,^^, _, or __\n     *      and length is given as an integer or fraction if other than default \n     *          length specified by the music.\n     */\n    public String toString() {\n        return pitch.toString() + duration;\n    }\n}\n\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282953,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Rest.java",
    "data": "package karaoke;\n\nimport java.util.Optional;\n\nimport karaoke.sound.SequencePlayer;\n\n/**\n * Rest represents a number of beats with no notes being played.\n */\npublic class Rest implements Music {\n\n    private final double duration;\n    \n    // Abstraction function\n    //    AF(duration) \n    //      = represents a musical silence that lasts duration beats\n    // Rep invariant\n    //    duration >= 0\n    // Safety from rep exposure\n    //    all fields are immutable and final\n\n    private void checkRep() {\n        assert duration >= 0;\n    }\n\n    /**\n     * Make a Rest that lasts for duration beats.\n     * @param duration duration in beats, must be >= 0\n     */\n    public Rest(double duration) {\n        this.duration = duration;\n        checkRep();\n    }\n\n    /**\n     * @return duration of this rest\n     */\n    @Override\n    public double duration() {\n        return duration;\n    }\n\n    /**\n     * Play this rest.\n     */\n    @Override\n    public void play(SequencePlayer player, double atBeat, Optional<LyricListener> listener) {\n    }\n    \n    @Override\n    public boolean hasVoices() {\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        long durationBits = Double.doubleToLongBits(duration);\n        return (int) (durationBits ^ (durationBits >>> Integer.SIZE));\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null) return false;\n        if (getClass() != obj.getClass()) return false;\n        \n        final Rest other = (Rest) obj;\n        return duration == other.duration;\n    }\n\n    @Override\n    public String toString() {\n        return \"z\" + duration;\n    }\n}\n\n\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282954,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/Pitch.java",
    "data": "package karaoke;\n\n/**\n * Pitch is an immutable type representing the frequency of a musical note.\n * Standard music notation represents pitches by letters: A, B, C, ..., G.\n * Pitches can be sharp or flat, or whole octaves up or down from these\n * primitive generators.\n * \n * <p> For example:\n * <br> new Pitch('C') makes middle C\n * <br> new Pitch('C').transpose(1) makes C-sharp\n * <br> new Pitch('E').transpose(-1) makes E-flat\n * <br> new Pitch('C').transpose(OCTAVE) makes high C\n * <br> new Pitch('C').transpose(-OCTAVE) makes low C\n */\npublic class Pitch {\n\n    private final int value;\n\n    /*\n     * Rep invariant: true.\n     *\n     * Abstraction function AF(value):\n     *   AF(0),...,AF(11) map to middle C, C-sharp, D, ..., A, A-sharp, B.\n     *   AF(i+12n) maps to n octaves above middle AF(i)\n     *   AF(i-12n) maps to n octaves below middle AF(i)\n     */\n    \n    private static final int[] SCALE = {\n            9,  // A\n            11, // B\n            0,  // C\n            2,  // D\n            4,  // E\n            5,  // F\n            7,  // G\n    };\n\n    private static final String[] VALUE_TO_STRING = {\n            \"C\", \"^C\", \"D\", \"^D\", \"E\", \"F\", \"^F\", \"G\", \"^G\", \"A\", \"^A\", \"B\"\n    };\n    \n    /**\n     * Middle C.\n     */\n    public static final Pitch MIDDLE_C = new Pitch('C');\n\n    /**\n     * Number of pitches in an octave.\n     */\n    public static final int OCTAVE = 12;\n\n    private Pitch(int value) {\n        this.value = value;\n    }\n\n    /**\n     * Make a Pitch named c in the middle octave of the piano keyboard.\n     * For example, new Pitch('C') constructs middle C.\n     * @param c letter in {'A',...,'G'}\n     */\n    public Pitch(char c) {\n        try {\n            value = SCALE[c-'A'];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(c + \" must be in the range A-G\", e);\n        }\n    }\n\n    /**\n     * @param semitonesUp \n     * @return pitch made by transposing this pitch by semitonesUp semitones;\n     *         for example, middle C transposed by 12 semitones is high C, and\n     *         E transposed by -1 semitones is E flat\n     */\n    public Pitch transpose(int semitonesUp) {\n        return new Pitch(value + semitonesUp);\n    }\n\n    /**\n     * @param that \n     * @return number of semitones between this and that; i.e., n such that\n     *         that.transpose(n).equals(this)\n     */\n    public int difference(Pitch that) {\n        return this.value - that.value;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null) return false;\n        if (obj.getClass() != this.getClass()) return false;\n        \n        Pitch that = (Pitch) obj;\n        return this.value == that.value;\n    }\n\n    @Override\n    public int hashCode() {\n        return value;\n    }\n\n    /**\n     * @return this pitch in abc music notation\n     * @see \"http://www.walshaw.plus.com/abc/examples/\"\n     */\n    @Override\n    public String toString() {\n        String suffix = \"\";\n        int v = value;\n\n        while (v < 0) {\n            suffix += \",\";\n            v += OCTAVE;\n        }\n\n        while (v >= OCTAVE) {\n            suffix += \"'\";\n            v -= OCTAVE;\n        }\n\n        return VALUE_TO_STRING[v] + suffix;\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282955,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/parser/Abc.g",
    "data": "// Grammar for ABC music notation.  Mostly from the given.\n//contains a header(title, composer, tempo, meter, note length) and a body (notes sequence)\n@skip endLine {\n    music ::= header body endLine*;\n}\n\n//////////HEADER///////////\n@skip whitespace {\n    header ::='X:'x endLine 'T:'t endLine opt* 'K:'k endLine;\n    opt ::= ('C:'c endLine)|('V:'v endLine)|('L:'l endLine)|('M:'m endLine)|('Q:'q endLine);\n}\n         \nx ::= [0-9]+;\nt ::= text+;\n//key signature notation http://abcnotation.com/wiki/abc:standard:v2.1#kkey\nk ::= [A-G][#|b]?\"m\"?; //one of (A-G), maybe # or b, then maybe m\n\nc ::= text+; //composer is any string\nv ::= text+; //any string \nl ::= digit+ \"/\" digit+;\nm ::= [1-9][0-9]?('/'[1-9]+) | \"C\" | \"C|\";\nq ::= m \"=\" [1-9][0-9]*; \ntext ::= [^\\n\\r]*; \nwhitespace ::= spaceTab+;\n/////////BODY/////////\n@skip endLine {\n    body ::= abcLine+;\n}\nbody ::= abcLine+;\nabcLine ::= element+ endLine (lyric endLine)?  | middleOfBodyField | comment;\nelement ::= noteElement | restElement | tupletElement | barline | nthRepeat | spaceTab;\n\n//notes\nnoteElement ::= note | chord;\n\nnote ::= pitch noteLength?;\npitch ::= accidental? basenote octave?;\noctave ::= \"'\"+ | \",\"+;\nnoteLength ::= (digit+)? (\"/\" (digit+)?)?;\n\n// \"^\" is sharp, \"_\" is flat, and \"=\" is neutral\naccidental ::= \"^\" | \"^^\" | \"_\" | \"__\" | \"=\";\n\nbasenote ::= \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"A\" | \"B\"\n        | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"a\" | \"b\";\n\n//rests\nrestElement ::= \"z\" noteLength?;\n\n//tuplets\ntupletElement ::= tupletSpec noteElement+;\ntupletSpec ::= \"(\" digit;\n\n//chords\nchord ::= \"[\" note+ \"]\";\n\nbarline ::= \"|\" | \"||\" | \"[|\" | \"|]\" | \":|\" | \"|:\";\nnthRepeat ::= \"[1\" | \"[2\";\n\n//A voice field might reappear in the middle of a piece\n//to indicate the change of a voice\n@skip whitespace {\n    middleOfBodyField ::= 'V:'v endLine;\n}\n\nlyric ::= \"w:\" lyricalElement*;\n\nlyricalElement ::= \" \"+ | \"-\" | \"--\" | \"_\" | \"*\" | \"~\" | backslashDash | \"|\" | lyricText;\nlyricText ::= [^\\s|\\-_*~\\n\\\\]+;\n\n//backslash immediately followed by hyphen\nbackslashDash ::= \"\\\\-\";\n\n///////GENERAL////\n\ncomment ::= spaceTab* \"%\" commentText newline;\ncommentText ::= text;\n\nendLine ::= comment | newline;\n\ndigit ::= [0-9];\nnewline ::= \"\\n\" | \"\\r\" \"\\n\"?;\nspaceTab ::= \" \" | \"\\t\";\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282956,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/parser/KaraokeParser.java",
    "data": "package karaoke.parser;\n//TODO done: music player removed. \nimport java.util.List;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport edu.mit.eecs.parserlib.ParseTree;\nimport edu.mit.eecs.parserlib.Parser;\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport karaoke.Chord;\nimport karaoke.Composition;\nimport karaoke.Concat;\nimport karaoke.Header;\nimport karaoke.Music;\nimport karaoke.Note;\nimport karaoke.Pitch;\nimport karaoke.Rest;\nimport karaoke.MultipleVoice;\n\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\n\npublic class KaraokeParser {\n    \n    private static final HashMap<Integer,Double> TUPLET_LOOKUP = new HashMap<Integer,Double>(){{\n        put(2,3.0/2.0); //duplet note ratio\n        put(3,2.0/3.0); //triplet note ratio\n        put(4,3.0/4.0); //quadruplet note ratio\n    }};\n    private static final HashMap<String,String> ACCIDENTAL_MEMORY = new HashMap<>();\n    private static int sungLyricIdx = 0;\n    \n  /**\n  * Main method. Parses and then reprints an example expression.\n  * \n  * @param args command line arguments, not used\n  * @throws UnableToParseException if example expression can't be parsed\n  * @throws IOException if file can't be read\n  */\n public static void main(final String[] args) throws UnableToParseException, IOException {\n     final String input = \"sample-abc/rains_of_castamere.abc\";\n     final String abcFile = readABCFile(input);\n     //System.out.println(abcFile);\n     final Composition expression = KaraokeParser.parse(input);\n//     try {\n//         Header header = expression.getHeader();\n//         int tempo = header.getTempo();\n//         MusicPlayer.play(expression.getBody(), tempo);\n//     } catch (InvalidMidiDataException imde) {\n//         System.out.println(imde.getStackTrace());\n//     } catch (MidiUnavailableException mue) {\n//         System.out.println(mue.getStackTrace());\n//     }\n }\n\n    \n    //Grammar nonterminals\n    private static enum MusicGrammar{\n        MUSIC,\n        HEADER, X, K, T, OPT, C, V, L, M, Q, \n        BODY, ABCLINE, ELEMENT, LYRIC, MIDDLEOFBODYFIELD, NOTEELEMENT, RESTELEMENT,TUPLETELEMENT,\n        BARLINE, NTHREPEAT, NOTE, CHORD, PITCH, NOTELENGTH, ACCIDENTAL, BASENOTE, OCTAVE, DIGIT,\n        TUPLETSPEC, LYRICALELEMENT, LYRICTEXT, TEXT, COMMENTTEXT,\n        WHITESPACE,SPACETAB, BACKSLASHDASH, ENDLINE, COMMENT, NEWLINE\n    }\n    \n    private static Parser<MusicGrammar> parser = makeParser();\n    \n    /**\n     * Parser compiles grammar into parser\n     * @return parser for the grammar\n     * @throws RuntimeException if grammar file can't be read or has syntax errors\n     */\n    private static Parser<MusicGrammar> makeParser(){\n        //read grammar as file \n        try {\n            final File grammarFile = new File(\"src/karaoke/parser/Abc.g\");\n            return Parser.compile(grammarFile, MusicGrammar.MUSIC); \n        }catch (IOException e) {\n          throw new RuntimeException(\"can't read the grammar file\", e);\n        }catch (UnableToParseException e) {\n          throw new RuntimeException(\"the grammar has a syntax error\", e);\n        }\n    }\n    \n    /**\n     * Returns the text in a file in a String\n     * @param filename name of file to read\n     * @return the file in a String format\n     * @throws IOException if file can't be read\n     */\n    private static String readABCFile(String filename) throws IOException{\n        File file = new File(filename);\n        int fileLength = (int) file.length();\n        FileInputStream reader = new FileInputStream(file);\n        byte[] data = new byte[fileLength];\n        reader.read(data, 0, fileLength);\n        reader.close();\n        return new String(data)+\"\\n\";//add endLine in case file doesn't have one at last line\n    }\n        \n    /**\n     * Parse string into a Music data type\n     * @param filename name of file containing music to parse\n     * @return a musical expression parsed from the string\n     * @throws UnableToParseException if string cannot be matched to abc's grammar\n     * @throws IOException if file can't be read\n     */\n    public static Composition parse(final String filename) throws UnableToParseException,IOException { \n        String abcFile = readABCFile(filename);\n        //make into parse tree\n        final ParseTree<MusicGrammar> parseTree = parser.parse(abcFile);\n        // make an AST from the parse tree\n        final Composition composition = makeAbstractSyntaxTree(parseTree);\n        \n        return composition;\n    }\n    \n    /**\n     * Convert a parse tree into an abstract syntax tree.\n     * @param parseTree constructed according to the grammar in Abc.g\n     * @return abstract syntax tree corresponding to parseTree\n     */\n    private static Composition makeAbstractSyntaxTree(final ParseTree<MusicGrammar> parseTree) {\n        final List<ParseTree<MusicGrammar>> children = parseTree.children();\n        final int headerIdx = 0;\n        final int musicIdx = 1;\n        \n        //Header:\n        final ParseTree<MusicGrammar> headerTree = children.get(headerIdx);\n        Header header = headerParser(headerTree);\n        String key = header.getKey();\n        List<String> voices = header.getVoices();\n        \n        //Body:\n        final ParseTree<MusicGrammar> musicTree = children.get(musicIdx);\n        // Parse body according to grammar Abc.g:\n        // Obtain Lyrics, notes and rests with respective durations and construct a music data type\n        // Rests are z and notes are [A-G]|[a-g] with accidentals '^'|'^^'|'_'|'__' and octaves \"'\"+|','+\n        // Lyrics follow the notes and rest durations in the line above and start with \"w:\"\n        // For example:\n        // z4 D2 | G4 B G | B4 A2 | G4 E2 | D4 D2 | G4 B G | B4 A2 | d6 ||\n        // w: A- | ma-zing_ | grace! How | sweet the | sound That | saved a_ | wretch like | me. ||\n        Music body = bodyParser(musicTree, key, voices);\n        return new Composition(header, body);\n    }\n    \n    ////////////////////HEADER and associated helpers/////////////////////////\n    /**\n     * Creates a Header datatype that contains information about a musical piece:\n     * Index Number, Title, Composer, Default Note Length, Voices, Meter Tempo, Key Signature, Voices\n     * @param headerTree The parse Tree containing the information in the header\n     * @return a Header containing musical piece information\n     */\n    private static Header headerParser(final ParseTree<MusicGrammar> headerTree) {\n        final List<ParseTree<MusicGrammar>> headerChildren = headerTree.children();\n        \n        //The first field in the header must be the index number (X).\n        //The second field in the header must be the title (T).\n        final int numberIdx = 0;\n        final int titleIdx = 2;\n        //x ::= [0-9]+;\n        final int pieceNumber = Integer.parseInt(headerChildren.get(numberIdx).text()); \n        //t ::= [^\\n\\r]+;\n        final String pieceTitle = headerChildren.get(titleIdx).text();\n        \n        final int defaultTempo = 100;\n        final String defaultTempoBaseNote = \"1/8\";\n        String tempoBaseNote = defaultTempoBaseNote;\n        int tempo = defaultTempo;\n        String meter = \"4/4\"; // default meter\n        String noteLength = \"\";\n        String composer = \"\";\n        List<String> voices = new ArrayList<>();\n        \n        //Obtains all optional fields\n        for (int i=titleIdx+1; i<headerChildren.size()-2; i++) {\n            List<ParseTree<MusicGrammar>> optionalChildren = headerChildren.get(i).children();\n            for (int j = 0; j< optionalChildren.size(); j++) {\n                MusicGrammar optionalField = optionalChildren.get(j).name();\n                String fieldInfo = optionalChildren.get(j).text();\n                if (optionalField.equals(MusicGrammar.Q)) { // q ::= m \"=\" [1-9][0-9]*;\n                    String[] tempoComponents = fieldInfo.split(\"=\");\n                    tempoBaseNote = tempoComponents[0];\n                    tempo = (int) parseDuration(tempoComponents[1]);\n                } else if (optionalField.equals(MusicGrammar.M)) { // m ::=[1-9]('/'[1-9]*)?;\n                    if (fieldInfo.equals(\"C\")) { //common time\n                        meter = \"4/4\";\n                    } else if (fieldInfo.equals(\"C|\")){ //cut common time\n                        meter = \"2/2\";\n                    } else {\n                        meter = fieldInfo;\n                    }\n                } else if (optionalField.equals(MusicGrammar.C)) { //c ::= [^\\n\\r]+;\n                    composer = fieldInfo;\n                } else if (optionalField.equals(MusicGrammar.L)) { // l ::=[1-9]('/'[1-9]*)?;\n                    noteLength = fieldInfo;\n                } else if (optionalField.equals(MusicGrammar.V)) { //v ::= [^\\n\\r]+;\n                    voices.add(fieldInfo);\n                }\n            }\n        }\n        \n        // When the field L is omitted, a unit note length is set based on the meter.]\n        // If the meter is less than 0.75, the default unit note length is a sixteenth note.]\n        // If the meter is 0.75 or greater, it is an eighth note\n        double meterValue = parseDuration(meter);\n        final double meterThreshold = 0.75;\n        if (noteLength.isEmpty()) {\n            if (meterValue < meterThreshold) { \n                noteLength = \"1/16\";\n            } else {\n                noteLength = \"1/8\";\n            }\n        }\n        double noteLengthValue = parseDuration(noteLength);\n        \n        //Adjust tempo to note length\n        double tempoBaseNoteValue = parseDuration(tempoBaseNote);\n        final double tempoRatio = tempoBaseNoteValue/noteLengthValue;\n        int adjustedTempo = (int) (tempoRatio*tempo);\n        \n        //The last field in the header must be the key (K).\n        final int keyIdx = headerChildren.size()-2;\n        String key = headerChildren.get(keyIdx).text();\n        \n        return new Header(pieceNumber, pieceTitle, composer, meterValue, noteLengthValue, adjustedTempo, key, voices);\n    }\n\n     /** Obtains a numerical value for a string representing the duration of a musical element\n      * Follow the grammar: noteLength ::= (digit+)? (\"/\" (digit+)?)?;\n     * @param duration a string that represents a number or fraction\n     * @return the numerical value of the string duration\n     */\n    private static double parseDuration(String duration) {\n        final double halfValue = 0.5;\n        if (duration.matches(\"\\\\/\")) { // '/'\n            return halfValue;\n        } else if (duration.matches(\"\\\\d+\")) { // numertator\n            double numerator = Double.parseDouble(duration);\n            return numerator;\n        } else if (duration.matches(\"\\\\d+\\\\/\")) { // numerator/\n            double numerator = Double.parseDouble(duration.substring(0, duration.length()-1));\n            return numerator*halfValue;\n        } else if (duration.matches(\"\\\\/\\\\d+\")) { // /denominator\n            double denominator = Double.parseDouble(duration.substring(1));\n            return 1/denominator;\n        } else if (duration.matches(\"\\\\d+\\\\/\\\\d+\")) { //numerator/denominator\n            String[] durationComponents = duration.split(\"\\\\/\");\n            double numerator = Double.parseDouble(durationComponents[0]);\n            double denominator = Double.parseDouble(durationComponents[1]);\n            return numerator/denominator;\n        } else {\n            return 1;\n        }\n    }\n    \n    /**\n     * matches the key that the music is played in the patterns of sharps that\n     * should occur in the piece. \n     * @param key that the music is played in.\n     * @return the notes that should be sharp as defined by the key..\n     */\n    private static String getSharps(String key) {\n        \n        //sharps always appear in the same order in the key signatures.\n        String sequenceSharps = \"FCGDAEB\"; \n        \n        HashMap<String, Integer>sharpKeys=new HashMap<String,Integer>(){{\n            //the values index into the sequence of flats to determine which notes should have flats\n            put(\"G\",1); \n            put(\"Em\",1);\n            put(\"D\",2);\n            put(\"Bm\",2);\n            put(\"A\",3);\n            put(\"F#m\",3); \n            put(\"E\", 4);\n            put(\"C#m\",4);\n            put(\"B\",5);\n            put(\"G#m\",5);\n            put(\"F#\",6);\n            put(\"D#m\",6);\n            put(\"C#\",7);\n            put(\"A#m\",7);\n        }};\n        \n        if(sharpKeys.containsKey(key)) {\n            return sequenceSharps.substring(0,sharpKeys.get(key));\n        }else {\n            return \"\";\n        }\n    }\n    \n    /**\n     * matches the key that the music is played in the patterns of flats that\n     * should occur in the piece. \n     * @param key that the music is played in.\n     * @return the notes that should be flat as defined by the key.\n     */\n    private static String getFlats(String key) {\n        \n        //flats always appear in the same order in the key signatures.\n        String sequenceFlats = \"BEADGCF\";\n        \n        HashMap<String, Integer>flatKeys=new HashMap<String,Integer>(){{\n            //the values index into the sequence of flats to determine which notes should have flats\n            put(\"F\",1); \n            put(\"Dm\",1);\n            put(\"Bb\",2);\n            put(\"Gm\",2);\n            put(\"Eb\",3);\n            put(\"Cm\",3);\n            put(\"Ab\", 4);\n            put(\"Fm\",4);\n            put(\"Db\",5);\n            put(\"Bbm\",5);\n            put(\"Gb\",6);\n            put(\"Ebm\",6);\n            put(\"Cb\",7);\n            put(\"Abm\",7);\n        }};\n        if(flatKeys.containsKey(key)) {\n            return sequenceFlats.substring(0,flatKeys.get(key));\n        }else {\n            return \"\";\n        }\n    }\n    \n//////////////////////BODY and associated helpers/////////////////////////\n    /**\n     * Creates a Music's datatype based on the music's body,\n     * @param musicTree The musicTree containing the music to be parsed\n     * @return a Music containing musical piece to be played\n     */\n    private static Music bodyParser(final ParseTree<MusicGrammar> musicTree, String key, List<String> voices) {\n        \n        final List<ParseTree<MusicGrammar>> abcLines = musicTree.children();\n        \n        if (!voices.isEmpty()) {\n            final HashMap<String,List<ParseTree<MusicGrammar>>> voiceLines =  splitVoices(abcLines, voices);\n            final HashMap<String,Music> voiceMusicMap = new HashMap<>();\n            for (String voice : voiceLines.keySet()) {\n                voiceMusicMap.put(voice, voiceParser(voiceLines.get(voice), key));\n            }\n            return new MultipleVoice(voiceMusicMap);\n        } else {\n            return voiceParser(abcLines,key);\n        }\n        \n    }\n    \n    /*\n     * Splits the abclines from body by voice(including lyrics). Returns a map of voices to list of abclines\n     */\n    private static HashMap<String,List<ParseTree<MusicGrammar>>> splitVoices(List<ParseTree<MusicGrammar>> abcLines, List<String> voices) {\n        final HashMap<String,List<ParseTree<MusicGrammar>>> voiceLines = new HashMap<>();\n        for (String voice : voices) {\n            voiceLines.put(voice, new ArrayList<ParseTree<MusicGrammar>>());\n        }\n        \n        for (int lineIdx = 0; lineIdx<abcLines.size(); lineIdx++) {\n            ParseTree<MusicGrammar> line = abcLines.get(lineIdx).children().get(0);\n            MusicGrammar lineType = line.name();\n            if (lineType.equals(MusicGrammar.MIDDLEOFBODYFIELD)) {\n                String voice = line.childrenByName(MusicGrammar.V).get(0).text();\n                for (int voiceLineIdx=lineIdx+1; voiceLineIdx<abcLines.size(); voiceLineIdx++) {\n                    ParseTree<MusicGrammar> voiceLine = abcLines.get(voiceLineIdx).children().get(0);\n                    MusicGrammar voiceLineType = voiceLine.name();\n                    if (voiceLineType.equals(MusicGrammar.MIDDLEOFBODYFIELD)) {\n                        break;\n                    }\n                    List<ParseTree<MusicGrammar>> linesInVoice = voiceLines.get(voice);\n                    linesInVoice.add(abcLines.get(voiceLineIdx));\n                    voiceLines.put(voice,linesInVoice);\n                }\n            }\n        }\n        return voiceLines;\n    }\n    \n    /*\n     * Returns music for individual voices\n     * Determine major sections in music and takes care of repeats and multiple endings\n     * Every time a line ends, the sungLyricIdx gets reset\n     */\n    private static Music voiceParser(final List<ParseTree<MusicGrammar>> abcLines, String key) {\n        Music voiceMusic = new Rest(0);\n        List<ParseTree<MusicGrammar>> majorSectionElements = new ArrayList<>(); \n        Music majorSectionMusic = new Rest(0);\n        boolean multipleEndings = false;\n        for (int lineIdx = 0; lineIdx<abcLines.size(); lineIdx++) {\n            List<ParseTree<MusicGrammar>> lyrics = abcLines.get(lineIdx).childrenByName(MusicGrammar.LYRIC);\n            List<ParseTree<MusicGrammar>> lineElements = abcLines.get(lineIdx).childrenByName(MusicGrammar.ELEMENT);\n            List<String> lyricWords = lyricsParser(lyrics, noteElementsInBar(lineElements));\n            \n            for (int lineElementIdx = 0; lineElementIdx<lineElements.size(); lineElementIdx++) {     \n                ParseTree<MusicGrammar> subElement = lineElements.get(lineElementIdx).children().get(0);\n                majorSectionElements.add(subElement);\n                MusicGrammar subElementType = subElement.name();\n                \n                //handles multiple endings\n                if (subElementType.equals(MusicGrammar.NTHREPEAT)) {\n                    String repeat = subElement.text();\n                    if (repeat.equals(\"[1\")) { //repeat major section up to here\n                        multipleEndings = true;\n                        majorSectionMusic = new Concat(majorSectionMusic,elementParser(majorSectionElements,key,lyricWords));\n                        majorSectionElements.clear(); \n                    } else if (repeat.equals(\"[2\")) { //majorSectionElements contains only first ending elements at this point\n                        Music majorSectionRepeatFirstEnding = new Concat(majorSectionMusic,elementParser(majorSectionElements,key,lyricWords));\n                        majorSectionMusic = new Concat(majorSectionRepeatFirstEnding,majorSectionMusic);\n                        majorSectionElements.clear();\n                        multipleEndings = false; // end of multiple endings\n                    }\n                } else if (subElementType.equals(MusicGrammar.BARLINE)) {\n                    String barline = subElement.text();\n                    if (barline.equals(\"||\") || barline.equals(\"[|\") || barline.equals(\"|]\") || barline.equals(\"|:\")) {\n                        //end of major section\n                        majorSectionMusic = new Concat(majorSectionMusic,elementParser(majorSectionElements,key,lyricWords));\n                        voiceMusic = new Concat(voiceMusic,majorSectionMusic);\n                        majorSectionElements.clear();\n                        majorSectionMusic = new Rest(0);\n                        //repeats\n                    } else if (barline.equals(\":|\") && !multipleEndings) {\n                        Music repeatMusic = new Concat(majorSectionMusic,elementParser(majorSectionElements,key,lyricWords));\n                        majorSectionMusic = new Concat(repeatMusic,repeatMusic);\n                        voiceMusic = new Concat(voiceMusic,majorSectionMusic);\n                        majorSectionElements.clear();\n                        majorSectionMusic = new Rest(0); //reset major section\n                    }\n                } \n            }\n            if (!multipleEndings) {\n                majorSectionMusic = new Concat(majorSectionMusic,elementParser(majorSectionElements,key,lyricWords));\n                majorSectionElements.clear();\n            }\n            sungLyricIdx = 0; //reset index of lyric for next line\n        }\n        if (!majorSectionMusic.equals(new Rest(0))) {\n            voiceMusic = new Concat(voiceMusic,majorSectionMusic);\n        }\n        return voiceMusic;\n    }\n    \n    /*\n     * Determines the number of noteElements (note or chord) in a bar to match with lyrics\n     */\n    private static List<Integer> noteElementsInBar(List<ParseTree<MusicGrammar>> lineElements) {\n        List<Integer> barNoteElements = new ArrayList<>();\n        int barIdx = 0;\n        int numToAddToBar = 0;\n        for (int i = 0; i<lineElements.size(); i++) {\n            ParseTree<MusicGrammar> subElement = lineElements.get(i).children().get(0);\n            MusicGrammar subElementType = subElement.name();\n            if (subElementType.equals(MusicGrammar.BARLINE) && i>0) {\n                barNoteElements.add(barIdx, numToAddToBar);\n                barIdx++;\n                numToAddToBar = 0;\n            } else if (subElementType.equals(MusicGrammar.NOTEELEMENT)) {\n                numToAddToBar++;\n            } else if (subElementType.equals(MusicGrammar.TUPLETELEMENT)) {\n                int tupletSize = subElement.children().size()-1;\n                numToAddToBar += tupletSize;\n            }\n        }\n        if (numToAddToBar > 0) { //end of line has no bar\n            barNoteElements.add(barIdx, numToAddToBar);\n        }\n        return barNoteElements;\n    }\n    \n    /*\n     * Parses lyrics for each abcline\n     */\n    private static List<String> lyricsParser(List<ParseTree<MusicGrammar>> lyrics, List<Integer> noteElementsInBar) {\n        List<String> lyricWords  = new ArrayList<>();\n        int lyricsInBar = 0;\n        int barIdx = 0;\n        boolean checkHyphen = false;\n        if (!lyrics.isEmpty()) {\n            List<ParseTree<MusicGrammar>> lyricElements = lyrics.get(0).children();\n            for (int lyricIdx = 0; lyricIdx<lyricElements.size(); lyricIdx++) {\n                ParseTree<MusicGrammar> lyricElement = lyricElements.get(lyricIdx);\n                String lyricText = lyricElement.text();\n                if (lyricText.equals(\"*\")) {\n                    lyricWords.add(\"????\");\n                    lyricsInBar++;\n                } else if (lyricText.equals(\"-\") || lyricText.equals(\"--\")) {\n                    int previousSyllableIdx = lyricWords.size()-1;\n                    while(lyricWords.get(previousSyllableIdx).equals(\"_\")) {\n                        previousSyllableIdx--;\n                    }\n                    String previousSyllable = lyricWords.get(previousSyllableIdx);\n                    lyricWords.set(previousSyllableIdx, previousSyllable+\"-\");\n                    if ((checkHyphen && lyricText.equals(\"-\")) || lyricText.equals(\"--\")) {\n                        lyricWords.add(\"????\");\n                        lyricsInBar++;\n                    }\n                } else if (lyricText.equals(\"~\")) {\n                    String word = lyricWords.get(lyricWords.size()-1);\n                    word += \" \"+lyricElements.get(lyricIdx+1).text();\n                    lyricWords.set(lyricWords.size()-1, word);\n                    lyricIdx++;\n                } else if (lyricText.equals(\"\\\\-\")) {\n                    String syllable = lyricWords.get(lyricWords.size()-1);\n                    syllable += \"-\"+lyricElements.get(lyricIdx+1).text();\n                    lyricWords.set(lyricWords.size()-1, syllable);\n                    lyricIdx++;\n                } else if (lyricText.charAt(0) == ' ') {\n                    checkHyphen = true;\n                } else if (lyricText.equals(\"|\")) {\n                    if (lyricsInBar > 0 && noteElementsInBar.get(barIdx)>lyricsInBar) {\n                        lyricWords.add(\"????\");  \n                        barIdx++;\n                        lyricsInBar = 0;\n                    }\n                } else {\n                    lyricWords.add(lyricText);\n                    lyricsInBar++;\n                    checkHyphen = false;\n                } \n                //\n                if (noteElementsInBar.size() > barIdx && lyricsInBar==noteElementsInBar.get(barIdx)) {\n                    lyricsInBar = 0;\n                    barIdx++;\n                }\n                if (barIdx >= noteElementsInBar.size()) { //if excess lyrics, just ignore\n                    return lyricWords;\n                }\n            }\n        }\n        return lyricWords;\n    }\n    \n    /*\n     * Puts * around syllable associated with the noteElement in abcLine\n     * Returns full line of lyrics with highlighted syllable\n     */\n    private static String highlightLyric(List<String> lyricWords, int lyricToBeSungIdx) {\n        String lyricsWithHighlight = \"\";\n        String lyricToHighlight = \"\";\n        boolean holdingLyrics = false;\n        String heldSyllable = \"\";\n        boolean hasSpace = false;\n        if (lyricToBeSungIdx < lyricWords.size()) {\n            for (int i=0; i<lyricWords.size(); i++) {\n                String lyric = lyricWords.get(i);\n                if (lyric.equals(\"_\") && !holdingLyrics) {\n                    holdingLyrics = true;\n                    heldSyllable = lyricWords.get(i-1);\n                } else if (lyricsWithHighlight.length() > 0){\n                    final int lastIdx = lyricsWithHighlight.length()-1;\n                    if (lyric.equals(\"????\") && lyricsWithHighlight.charAt(lastIdx) == '-') {\n                        lyricsWithHighlight += \" \";\n                    }\n                }\n                if (i==lyricToBeSungIdx) {\n                    if (lyric.equals(\"_\")) {\n                        //remove repeated syllable\n                        int numSpace = hasSpace ? 1 : 0;\n                        String lyricsWithoutHeldSyllable = lyricsWithHighlight.substring(0,lyricsWithHighlight.length()-heldSyllable.length()-numSpace);\n                        lyricsWithHighlight = lyricsWithoutHeldSyllable;\n                        lyricToHighlight = heldSyllable;\n                    } else {\n                        lyricToHighlight = lyric;\n                    }\n                    int lastCharIdx = lyricToHighlight.length()-1;\n                    if (lyricToHighlight.charAt(lastCharIdx)=='-') {\n                        String lyricWithNoHyphen = lyricToHighlight.substring(0, lastCharIdx);\n                        lyricsWithHighlight += \"*\"+lyricWithNoHyphen+\"*-\";\n                    } else {\n                        lyricsWithHighlight += \"*\"+lyricToHighlight+\"* \";\n                    }\n                } else if (!lyric.equals(\"_\")) {\n                    holdingLyrics = false;\n                    int lastCharIdx = lyric.length()-1;\n                    lyricsWithHighlight += lyric;\n                    if (lyric.charAt(lastCharIdx)!='-') {\n                        lyricsWithHighlight += \" \";\n                        hasSpace = true;\n                    } else {\n                        hasSpace = false;\n                    }\n                }\n            }\n            //remove last space\n            lyricsWithHighlight = lyricsWithHighlight.substring(0, lyricsWithHighlight.length()-1);\n        } else {\n            lyricsWithHighlight = \"???? ???? ????\";\n        }\n        return lyricsWithHighlight;\n    }\n    \n    /*\n     * Splits lines into elements and divides work to parse each different type of element\n     *  element ::= noteElement | restElement | tupletElement | barline | nthRepeat | spaceTab;\n     *  Clears accidental memory at end of each bar\n     */\n    private static Music elementParser(List<ParseTree<MusicGrammar>> elements, String key, List<String> lyricWords) {\n        Music elementMusic = new Rest(0);\n        String lyricsWithHighlight;\n\n        for (int i = 0; i<elements.size(); i++) {     \n            ParseTree<MusicGrammar> subElement = elements.get(i);\n            MusicGrammar subElementType = subElement.name();\n            \n            if (subElementType.equals(MusicGrammar.NOTEELEMENT)) {\n                lyricsWithHighlight = highlightLyric(lyricWords,sungLyricIdx);\n                int durationAdjustment = 1; // note is not part of tuplet\n                elementMusic = new Concat(elementMusic,noteElementParser(subElement, key, durationAdjustment, lyricsWithHighlight));\n                sungLyricIdx++;\n                \n\n            } else if (subElementType.equals(MusicGrammar.RESTELEMENT)) {\n                    elementMusic = new Concat(elementMusic,restParser(subElement));    \n                    \n            } else if (subElementType.equals(MusicGrammar.TUPLETELEMENT)) {\n                List<ParseTree<MusicGrammar>> tupletComponents = subElement.children();\n                final int tupletSpecIdx = 0;\n                \n                //type of tuplet: duplet, triplet, quadruplet\n                ParseTree<MusicGrammar> tupletSpec = tupletComponents.get(tupletSpecIdx);\n                int numNotes = Integer.parseInt(tupletSpec.childrenByName(MusicGrammar.DIGIT).get(0).text());\n                double noteRatio = TUPLET_LOOKUP.get(numNotes);\n                \n                //parser each note in tuplet\n                for(int noteElementIdx=1; noteElementIdx<tupletComponents.size(); noteElementIdx++) {\n                  lyricsWithHighlight = highlightLyric(lyricWords,sungLyricIdx);\n                  ParseTree<MusicGrammar> noteElement = tupletComponents.get(noteElementIdx);\n                  elementMusic = new Concat(elementMusic,noteElementParser(noteElement, key, noteRatio, lyricsWithHighlight));\n                  sungLyricIdx++;\n                }\n                \n            } else if (subElementType.equals(MusicGrammar.BARLINE)) { \n                String barlineType = subElement.text();\n                //clear accidental memory at end of bar\n                if (barlineType.equals(\"|\") || barlineType.equals(\"||\") || barlineType.equals(\"|]\")\n                        || barlineType.equals(\"[|\") || barlineType.equals(\":|\")) {\n                    ACCIDENTAL_MEMORY.clear();\n                }\n            }\n        }\n        return elementMusic;\n    }\n    \n    /*\n     * Parses individual notes and chords\n     */\n    private static Music noteElementParser(ParseTree<MusicGrammar> noteElement, String key, double durationAdjustment,  String lyrics) {\n        Music noteElementMusic = new Rest(0);\n        \n        ParseTree<MusicGrammar> subNoteElement = noteElement.children().get(0);\n        MusicGrammar noteType = subNoteElement.name();\n        \n        if (noteType.equals(MusicGrammar.NOTE)) {\n            noteElementMusic = noteParser(subNoteElement, key, durationAdjustment, lyrics);\n            \n           // chord ::= \"[\" note+ \"]\";\n        } else if (noteType.equals(MusicGrammar.CHORD)) {\n            List<ParseTree<MusicGrammar>> notes = subNoteElement.children();\n            List<Note> notesInChord = new ArrayList<>();\n            notesInChord.add(noteParser(notes.get(0), key, durationAdjustment, lyrics));\n            for (int noteIdx=1; noteIdx<notes.size(); noteIdx++) {\n                //no lyrics for rest of notes in chord\n                notesInChord.add(noteParser(notes.get(noteIdx), key, durationAdjustment, \"\"));\n            }\n            noteElementMusic = new Chord(notesInChord,lyrics);\n        }\n        return noteElementMusic;\n    }\n    \n    /*\n     * Parses individual notes with length, octaves and accidentals\n     * Follows Grammar:\n     * note ::= pitch noteLength?;\n     * pitch ::= accidental? basenote octave?;\n     * octave ::= \"'\"+ | \",\"+;\n     * noteLength ::= (digit+)? (\"/\" (digit+)?)?;\n     */\n    private static Note noteParser(ParseTree<MusicGrammar> note, String key, double durationAdjustment, String lyric) {\n        List<ParseTree<MusicGrammar>> noteComponents = note.children();\n        final int pitchIdx = 0;\n        final int noteLengthIdx = 1;\n        \n        //basenote ::= \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"A\" | \"B\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"a\" | \"b\";\n        ParseTree<MusicGrammar> pitch = noteComponents.get(pitchIdx);\n        String baseNote = pitch.childrenByName(MusicGrammar.BASENOTE).get(0).text();\n\n        // noteLength ::= (digit+)? (\"/\" (digit+)?)?;\n        String noteLength = noteComponents.get(noteLengthIdx).text();\n        double duration = parseDuration(noteLength); \n        duration *= durationAdjustment; // adjust if part of tuplet\n        \n        //Adjust note to key signature\n        int semitonesChange = 0;\n        String keyFlats = getFlats(key);\n        String keySharps = getSharps(key);\n        String upperCaseBaseNote = baseNote.toUpperCase();\n        if (keyFlats.contains(upperCaseBaseNote)) {\n            semitonesChange -= 1;\n        } else if (keySharps.contains(upperCaseBaseNote)){\n            semitonesChange += 1;\n        }\n        \n        //Octave higher if lowercase\n        if (baseNote.equals(baseNote.toLowerCase())) {\n            semitonesChange += Pitch.OCTAVE;\n        }\n        \n        //accidental ::= \"^\" | \"^^\" | \"_\" | \"__\" | \"=\";\n        //store memory for bar\n        String accidental = \"\";\n        List<ParseTree<MusicGrammar>> accidentals = pitch.childrenByName(MusicGrammar.ACCIDENTAL);\n        if (!accidentals.isEmpty()) {\n            accidental = accidentals.get(0).text();\n            ACCIDENTAL_MEMORY.put(baseNote, accidental);\n        } else if (ACCIDENTAL_MEMORY.containsKey(baseNote)){\n            accidental = ACCIDENTAL_MEMORY.get(baseNote);\n        }\n        \n        //octave ::= \"'\"+ | \",\"+;\n        String octave = \"\";\n        List<ParseTree<MusicGrammar>> octaves = pitch.childrenByName(MusicGrammar.OCTAVE);\n        if (!octaves.isEmpty()) {\n            octave = octaves.get(0).text();\n        }\n        \n        //adjust note for octaves and accidentals\n        for (char c : (accidental + octave).toCharArray()) {\n            switch (c) {\n            case '_':\n                semitonesChange--;\n                break;\n            case '^':\n                semitonesChange++;\n                break;\n            case ',':\n                semitonesChange -= Pitch.OCTAVE;\n                break;\n            case '\\'':\n                semitonesChange += Pitch.OCTAVE;\n                break;\n            case '=': //neutral note\n                semitonesChange = 0;\n                break;\n            default:\n                throw new AssertionError(\"found \" + c + \" but expected either , or ' or _ or ^ or =\");\n            }\n        }\n        \n        //create note\n        Pitch notePitch = new Pitch(baseNote.toUpperCase().charAt(0));\n        return new Note(duration,notePitch.transpose(semitonesChange),lyric); //transpose before creating\n    }\n    \n    /*\n     * Parses Rests\n     * restElement ::= \"z\" noteLength?;\n     */\n    private static Rest restParser(ParseTree<MusicGrammar> restElement) {\n        String noteLength = restElement.children().get(0).text();\n        double duration = parseDuration(noteLength);\n        return new Rest(duration);\n    }\n    \n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282957,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/sound/HeadersFilter.java",
    "data": "package karaoke.sound;\n\n\nimport java.io.IOException;\nimport com.sun.net.httpserver.Filter;\nimport com.sun.net.httpserver.Headers;\nimport com.sun.net.httpserver.HttpExchange;\n\n/**\n * Filter that adds standard headers to every response.\n */\npublic class HeadersFilter extends Filter {\n    \n    private final Headers headers = new Headers();\n    \n    @Override public String description() { return \"Add headers to all responses\"; }\n    \n    /**\n     * Add a new header to the set of standard headers.\n     * @param key header name, e.g. \"Content-Type\"\n     * @param value header value, e.g. \"text/plain\"\n     */\n    public void add(String key, String value) {\n        headers.add(key, value);\n    }\n    \n    @Override public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n        exchange.getResponseHeaders().putAll(headers);\n        chain.doFilter(exchange);\n    }\n}",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282958,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/sound/Instrument.java",
    "data": "package karaoke.sound;\n\n/**\n * Instrument represents a musical instrument.\n * \n * These instruments are the 128 standard General MIDI Level 1 instruments.\n * See: http://www.midi.org/about-midi/gm/gm1sound.shtml\n */\npublic enum Instrument {\n    // Order is important in this enumeration because an instrument's\n    // position must correspond to its MIDI program number.\n\n    PIANO,\n    BRIGHT_PIANO,\n    ELECTRIC_GRAND,\n    HONKY_TONK_PIANO,\n    ELECTRIC_PIANO_1,\n    ELECTRIC_PIANO_2,\n    HARPSICHORD,\n    CLAVINET,\n\n    CELESTA,\n    GLOCKENSPIEL,\n    MUSIC_BOX,\n    VIBRAPHONE,\n    MARIMBA,\n    XYLOPHONE,\n    TUBULAR_BELL,\n    DULCIMER,\n\n    HAMMOND_ORGAN,\n    PERC_ORGAN,\n    ROCK_ORGAN,\n    CHURCH_ORGAN,\n    REED_ORGAN,\n    ACCORDION,\n    HARMONICA,\n    TANGO_ACCORDION,\n\n    NYLON_STR_GUITAR,\n    STEEL_STRING_GUITAR,\n    JAZZ_ELECTRIC_GTR,\n    CLEAN_GUITAR,\n    MUTED_GUITAR,\n    OVERDRIVE_GUITAR,\n    DISTORTION_GUITAR,\n    GUITAR_HARMONICS,\n\n    ACOUSTIC_BASS,\n    FINGERED_BASS,\n    PICKED_BASS,\n    FRETLESS_BASS,\n    SLAP_BASS_1,\n    SLAP_BASS_2,\n    SYN_BASS_1,\n    SYN_BASS_2,\n\n    VIOLIN,\n    VIOLA,\n    CELLO,\n    CONTRABASS,\n    TREMOLO_STRINGS,\n    PIZZICATO_STRINGS,\n    ORCHESTRAL_HARP,\n    TIMPANI,\n\n    ENSEMBLE_STRINGS,\n    SLOW_STRINGS,\n    SYNTH_STRINGS_1,\n    SYNTH_STRINGS_2,\n    CHOIR_AAHS,\n    VOICE_OOHS,\n    SYN_CHOIR,\n    ORCHESTRA_HIT,\n\n    TRUMPET,\n    TROMBONE,\n    TUBA,\n    MUTED_TRUMPET,\n    FRENCH_HORN,\n    BRASS_ENSEMBLE,\n    SYN_BRASS_1,\n    SYN_BRASS_2,\n\n    SOPRANO_SAX,\n    ALTO_SAX,\n    TENOR_SAX,\n    BARITONE_SAX,\n    OBOE,\n    ENGLISH_HORN,\n    BASSOON,\n    CLARINET,\n\n    PICCOLO,\n    FLUTE,\n    RECORDER,\n    PAN_FLUTE,\n    BOTTLE_BLOW,\n    SHAKUHACHI,\n    WHISTLE,\n    OCARINA,\n\n    SYN_SQUARE_WAVE,\n    SYN_SAW_WAVE,\n    SYN_CALLIOPE,\n    SYN_CHIFF,\n    SYN_CHARANG,\n    SYN_VOICE,\n    SYN_FIFTHS_SAW,\n    SYN_BRASS_AND_LEAD,\n\n    FANTASIA,\n    WARM_PAD,\n    POLYSYNTH,\n    SPACE_VOX,\n    BOWED_GLASS,\n    METAL_PAD,\n    HALO_PAD,\n    SWEEP_PAD,\n\n    ICE_RAIN,\n    SOUNDTRACK,\n    CRYSTAL,\n    ATMOSPHERE,\n    BRIGHTNESS,\n    GOBLINS,\n    ECHO_DROPS,\n    SCI_FI,\n\n    SITAR,\n    BANJO,\n    SHAMISEN,\n    KOTO,\n    KALIMBA,\n    BAG_PIPE,\n    FIDDLE,\n    SHANAI,\n\n    TINKLE_BELL,\n    AGOGO,\n    STEEL_DRUMS,\n    WOODBLOCK,\n    TAIKO_DRUM,\n    MELODIC_TOM,\n    SYN_DRUM,\n    REVERSE_CYMBAL,\n\n    GUITAR_FRET_NOISE,\n    BREATH_NOISE,\n    SEASHORE,\n    BIRD,\n    TELEPHONE,\n    HELICOPTER,\n    APPLAUSE,\n    GUNSHOT,\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282959,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/sound/LogFilter.java",
    "data": "package karaoke.sound;\n\nimport java.io.IOException;\nimport com.sun.net.httpserver.Filter;\nimport com.sun.net.httpserver.HttpExchange;\n\n/**\n * Logging filter that reports request URLs, exceptions, and response codes to\n * the console.\n */\npublic class LogFilter extends Filter {\n    \n    @Override public String description() { return \"Log requests\"; }\n    \n    @Override public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n        System.err.println(\" -> \" + exchange.getRequestMethod() + \" \" + exchange.getRequestURI());\n        try {\n            chain.doFilter(exchange);\n        } catch (IOException | RuntimeException e) {\n            System.err.print(\" !! \");\n            e.printStackTrace();\n            throw e; // after logging, let the exception continue\n        }\n        System.err.println(\" <- \" + exchange.getResponseCode());\n    }\n}",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282960,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/sound/MidiSequencePlayer.java",
    "data": "package karaoke.sound;\n\nimport java.math.BigInteger;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.function.Consumer;\nimport javax.sound.midi.*;\nimport karaoke.Pitch;\n\n/**\n * Schedules and plays a sequence of notes using the MIDI synthesizer.\n */\npublic class MidiSequencePlayer implements SequencePlayer {\n\n    /**\n     * Default tempo.\n     */\n    public static final int DEFAULT_BEATS_PER_MINUTE = 120;\n    /**\n     * Default MIDI ticks per beat.\n     */\n    public static final int DEFAULT_TICKS_PER_BEAT = 64;\n\n    // the volume\n    private static final int DEFAULT_VELOCITY = 100;\n\n    // the generic marker meta message type\n    private static final int META_MARKER = 6;\n    // the \"end_of_track\" meta message type\n    private static final int META_END_OF_TRACK = 47;\n\n    // MIDI note number representing middle C\n    private static final int MIDI_NOTE_MIDDLE_C = 60;\n\n    // sound synthesizer\n    private final Synthesizer synthesizer;\n\n    // active MIDI channels, assigned to instruments\n    private final Map<Instrument, Integer> channelForInstrument = new HashMap<>();\n\n    // next available channel number (not assigned to an instrument yet)\n    private int nextChannel = 0;\n\n    private final Sequencer sequencer;\n    private final Track track;\n    private final int beatsPerMinute;\n    private final int ticksPerBeat;\n\n    // event callback functions\n    private final SortedMap<Integer, Consumer<Double>> callbacks = new TreeMap<>();\n    private final MetaMessage keepalive = new MetaMessage(META_MARKER, new byte[] { 0 }, 1);\n\n    /*\n     * Rep invariant:\n     *   sequencer and track are non-null,\n     *   beatsPerMinute and ticksPerBeat are positive,\n     *   channels and callbacks are non-null,\n     *   channels does not contain value nextChannel\n     */\n\n    private void checkRep() {\n        assert sequencer != null : \"sequencer should be non-null\";\n        assert track != null : \"track should be non-null\";\n        assert beatsPerMinute >= 0 : \"should be positive number of beats per minute\";\n        assert ticksPerBeat >= 0 : \"should be positive number of ticks per beat\";\n        assert callbacks != null : \"callbacks should be non-null\";\n        assert callbacks.keySet().stream().allMatch(n -> n >= 1) : \"callback numbers should be positive\";\n        assert !channelForInstrument.values().contains(nextChannel) : \"nextChannel should not be assigned\";\n    }\n\n    /**\n     * Make a new MIDI sequence player with the default parameters.\n     * @throws MidiUnavailableException if MIDI device unavailable\n     * @throws InvalidMidiDataException if MIDI play fails\n     */\n    public MidiSequencePlayer() throws MidiUnavailableException, InvalidMidiDataException {\n        this(DEFAULT_BEATS_PER_MINUTE, DEFAULT_TICKS_PER_BEAT);\n    }\n\n    /**\n     * Make a new MIDI sequence player.\n     * @param beatsPerMinute the number of beats per minute\n     * @param ticksPerBeat the number of ticks per beat; every note plays for an integer number of ticks\n     * @throws MidiUnavailableException if MIDI device unavailable\n     * @throws InvalidMidiDataException if MIDI play fails\n     */\n    public MidiSequencePlayer(int beatsPerMinute, int ticksPerBeat)\n            throws MidiUnavailableException, InvalidMidiDataException {\n        synthesizer = MidiSystem.getSynthesizer();\n        synthesizer.open();\n        synthesizer.loadAllInstruments(synthesizer.getDefaultSoundbank());\n\n        this.sequencer = MidiSystem.getSequencer();\n\n        // create a sequence object with with tempo-based timing, where\n        // the resolution of the time step is based on ticks per quarter note\n        Sequence sequence = new Sequence(Sequence.PPQ, ticksPerBeat);\n        this.beatsPerMinute = beatsPerMinute;\n        this.ticksPerBeat = ticksPerBeat;\n\n        // create an empty track; notes will be added to this track\n        this.track = sequence.createTrack();\n\n        sequencer.setSequence(sequence);\n\n        checkRep();\n    }\n\n    /**\n     * adds note to be played on the player at a specified time for a specified duration\n     * @param instr instrument with which the note is played\n     * @param pitch at which the note is played\n     * @param startBeat when the note should start\n     * @param numBeats how long the note should be held for.\n     */\n    public void addNote(Instrument instr, Pitch pitch, double startBeat, double numBeats) {\n        int channel = getChannel(instr);\n        int note = getMidiNote(pitch);\n        try {\n            // schedule two events in the track, one for starting a note and one for ending\n            addMidiNoteEvent(ShortMessage.NOTE_ON, channel, note, (int) (startBeat * ticksPerBeat));\n            addMidiNoteEvent(ShortMessage.NOTE_OFF, channel, note, (int) ((startBeat + numBeats) * ticksPerBeat));\n        } catch (InvalidMidiDataException imde) {\n            String msg = MessageFormat.format(\"Cannot add note with the pitch {0} at beat {1} \" + \"for duration {2}\",\n                    note, startBeat, numBeats);\n            throw new RuntimeException(msg, imde);\n        }\n    }\n\n    /**\n     * Schedule a MIDI note event.\n     * @param eventType valid MidiMessage type in ShortMessage\n     * @param channel valid channel\n     * @param note valid pitch value\n     * @param tick tick >= 0\n     * @throws InvalidMidiDataException\n     */\n    private void addMidiNoteEvent(int eventType, int channel, int note, int tick) throws InvalidMidiDataException {\n        ShortMessage msg = new ShortMessage(eventType, channel, note, DEFAULT_VELOCITY);\n        this.track.add(new MidiEvent(msg, tick));\n    }\n\n\n    @Override public void addEvent(double atBeat, Consumer<Double> callback) {\n        int callbackNumber = saveCallback(callback);\n        try {\n            addMidiMetaEvent(callbackNumber, (int) (atBeat * ticksPerBeat));\n        } catch (InvalidMidiDataException imde) {\n            throw new RuntimeException(\"Cannot add event at beat \" + atBeat, imde);\n        }\n    }\n\n    /**\n     * saves callbacks for later\n     * @param callback\n     * @return\n     */\n    private int saveCallback(Consumer<Double> callback) {\n        synchronized (callbacks) {\n            int key = callbacks.isEmpty() ? 1 : callbacks.lastKey() + 1;\n            if (callbacks == null || callback == null) {\n                return 1;\n            }\n            callbacks.put(key, callback);\n            checkRep();\n            return key;\n        }\n    }\n\n    /**\n     * Schedule a MIDI meta event.\n     * @param callback active callback number\n     * @param tick tick >= 0\n     * @throws InvalidMidiDataException\n     */\n    private void addMidiMetaEvent(int callback, int tick) throws InvalidMidiDataException {\n        byte[] bytes = BigInteger.valueOf(callback).toByteArray();\n        MetaMessage msg = new MetaMessage(META_MARKER, bytes, bytes.length);\n        this.track.add(new MidiEvent(msg, tick));\n        this.track.add(new MidiEvent(keepalive, tick + 1));\n    }\n\n    @Override public void play() {\n        try {\n            sequencer.open();\n        } catch (MidiUnavailableException mue) {\n            throw new RuntimeException(\"Unable to open MIDI sequencer\", mue);\n        }\n        sequencer.setTempoInBPM(this.beatsPerMinute);\n\n        sequencer.addMetaEventListener(meta -> {\n            if (meta.getType() == META_MARKER) {\n                // trigger event callback\n                int callbackNumber = new BigInteger(meta.getData()).intValue();\n                if (callbackNumber > 0) {\n                    callbacks.remove(callbackNumber).accept(sequencer.getTickPosition() / (double) ticksPerBeat);\n                }\n            } else if (meta.getType() == META_END_OF_TRACK) {\n                // allow the sequencer to finish\n                try {\n                    Thread.sleep(Duration.ofSeconds(1).toMillis());\n                } catch (InterruptedException ie) {\n                }\n                // stop & close the sequencer\n                sequencer.stop();\n                sequencer.close();\n            }\n        });\n\n        // start playing!\n        sequencer.start();\n    }\n\n    /**\n     * Get a MIDI channel for the given instrument, allocating one if necessary.\n     * @param instr instrument\n     * @return channel for the instrument\n     */\n    private int getChannel(Instrument instr) {\n        // check whether this instrument already has a channel\n        if (channelForInstrument.containsKey(instr)) {\n            return channelForInstrument.get(instr);\n        }\n\n        int channel = allocateChannel();\n        patchInstrumentIntoChannel(channel, instr);\n        channelForInstrument.put(instr, channel);\n        checkRep();\n        return channel;\n    }\n\n    /**\n     * @return next available channel number\n     */\n    private int allocateChannel() {\n        MidiChannel[] channels = synthesizer.getChannels();\n        if (nextChannel >= channels.length) {\n            throw new RuntimeException(\"Tried to use too many instruments: limited to \" + channels.length);\n        }\n        return nextChannel++;\n    }\n\n    private void patchInstrumentIntoChannel(int channel, Instrument instr) {\n        try {\n            addMidiNoteEvent(ShortMessage.PROGRAM_CHANGE, channel, instr.ordinal(), 0);\n        } catch (InvalidMidiDataException imde) {\n            throw new RuntimeException(\"Cannot set instrument\", imde);\n        }\n    }\n\n    /**\n     * @return the MIDI note number for a pitch, defined as the number of\n     *         semitones above C 5 octaves below middle C; for example,\n     *         middle C is note 60\n     */\n    private static int getMidiNote(Pitch pitch) {\n        return MIDI_NOTE_MIDDLE_C + pitch.difference(Pitch.MIDDLE_C);\n    }\n\n    /**\n     * @return a string that displays the entire track information as a\n     *         sequence of MIDI events, where each event is either turning on\n     *         or off a note at a certain tick, a marker event, or the end of\n     *         the track\n     */\n    @Override public String toString() {\n        String trackInfo = \"\";\n\n        for (int i = 0; i < track.size(); i++) {\n            final MidiEvent e = track.get(i);\n            final MidiMessage msg = e.getMessage();\n            final String msgString;\n\n            if (msg instanceof ShortMessage) {\n                final ShortMessage smg = (ShortMessage) msg;\n                final int command = smg.getCommand();\n                final String commandName;\n\n                if (command == ShortMessage.NOTE_OFF) {\n                    commandName = \"NOTE_OFF\";\n                } else if (command == ShortMessage.NOTE_ON) {\n                    commandName = \"NOTE_ON \";\n                } else {\n                    commandName = \"Unknown command \" + command;\n                }\n\n                msgString = \"Event: \" + commandName + \" Pitch: \" + smg.getData1() + \" \";\n\n            } else if (msg instanceof MetaMessage) {\n                final MetaMessage mmg = (MetaMessage) msg;\n                final int type = mmg.getType();\n                final String typeName;\n\n                if (type == META_MARKER) {\n                    typeName = \"MARKER\";\n                } else if (type == META_END_OF_TRACK) {\n                    typeName = \"END_OF_TRACK\";\n                } else {\n                    typeName = \"Unknown type \" + type;\n                }\n\n                msgString = \"Meta event: \" + typeName;\n\n            } else {\n                msgString = \"Unknown event\";\n            }\n\n            trackInfo += msgString + \" Tick: \" + e.getTick() + \"\\n\";\n        }\n\n        return trackInfo;\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282961,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/sound/MusicPlayer.java",
    "data": "////Written by 6033 staff. \n//\n//package karaoke.sound;\n//\n//import javax.sound.midi.InvalidMidiDataException;\n//import javax.sound.midi.MidiUnavailableException;\n//import karaoke.Music;\n//\n//public class MusicPlayer {\n//   \n//    /**\n//     * creates a music player\n//     * @param music the music piece to be played\n//     * @param beatsPerMinute hwo fast the music should be played in bpm\n//     * @throws MidiUnavailableException if player attempted to play music cannot\n//     * @throws InvalidMidiDataException if the given parameters are not conducive \n//     *      to making a midi sequence player\n//     */\n//    public static void play(Music music, int beatsPerMinute) throws MidiUnavailableException, InvalidMidiDataException {\n//        \n//        // create a new player\n//        final int ticksPerBeat = MidiSequencePlayer.DEFAULT_TICKS_PER_BEAT; // allows up to 1/64-beat notes to be played with fidelity\n//        final SequencePlayer player = new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n//\n//        // add the notes to the player\n//        final double bufferTime = 0.125;\n//        music.play(player, bufferTime, );\n//        \n//        // create a listener for the end of the music\n//        final Object lock = new Object(); \n//        player.addEvent(music.duration(), beat -> {\n//            synchronized (lock) {\n//                lock.notify();\n//            }\n//        });\n//\n//        // wait until player is done\n//        // (not strictly needed here, but useful for JUnit tests)\n//        synchronized (lock) {\n//            // play!\n//            player.play();\n//            try {\n//                lock.wait();\n//            } catch (InterruptedException e) {\n//                e.printStackTrace();\n//            }\n//        }\n//    }\n//}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282962,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/sound/Pitch.java",
    "data": "package karaoke.sound;\n\n/**\n * Pitch is an immutable type representing the frequency of a musical note.\n * Standard music notation represents pitches by letters: A, B, C, ..., G.\n * Pitches can be sharp or flat, or whole octaves up or down from these\n * primitive generators.\n * \n * <p> For example:\n * <br> new Pitch('C') makes middle C\n * <br> new Pitch('C').transpose(1) makes C-sharp\n * <br> new Pitch('E').transpose(-1) makes E-flat\n * <br> new Pitch('C').transpose(OCTAVE) makes high C\n * <br> new Pitch('C').transpose(-OCTAVE) makes low C\n */\npublic class Pitch {\n\n    private final int value;\n\n    /*\n     * Rep invariant: true.\n     *\n     * Abstraction function AF(value):\n     *   AF(0),...,AF(11) map to middle C, C-sharp, D, ..., A, A-sharp, B.\n     *   AF(i+12n) maps to n octaves above middle AF(i)\n     *   AF(i-12n) maps to n octaves below middle AF(i)\n     */\n    \n    private static final int[] SCALE = {\n            9,  // A\n            11, // B\n            0,  // C\n            2,  // D\n            4,  // E\n            5,  // F\n            7,  // G\n    };\n\n    private static final String[] VALUE_TO_STRING = {\n            \"C\", \"^C\", \"D\", \"^D\", \"E\", \"F\", \"^F\", \"G\", \"^G\", \"A\", \"^A\", \"B\"\n    };\n    \n    /**\n     * Middle C.\n     */\n    public static final Pitch MIDDLE_C = new Pitch('C');\n\n    /**\n     * Number of pitches in an octave.\n     */\n    public static final int OCTAVE = 12;\n\n    private Pitch(int value) {\n        this.value = value;\n    }\n\n    /**\n     * Make a Pitch named c in the middle octave of the piano keyboard.\n     * For example, new Pitch('C') constructs middle C.\n     * @param c letter in {'A',...,'G'}\n     */\n    public Pitch(char c) {\n        try {\n            value = SCALE[c-'A'];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(c + \" must be in the range A-G\", e);\n        }\n    }\n\n    /**\n     * @param semitonesUp \n     * @return pitch made by transposing this pitch by semitonesUp semitones;\n     *         for example, middle C transposed by 12 semitones is high C, and\n     *         E transposed by -1 semitones is E flat\n     */\n    public Pitch transpose(int semitonesUp) {\n        return new Pitch(value + semitonesUp);\n    }\n\n    /**\n     * @param that \n     * @return number of semitones between this and that; i.e., n such that\n     *         that.transpose(n).equals(this)\n     */\n    public int difference(Pitch that) {\n        return this.value - that.value;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null) return false;\n        if (obj.getClass() != this.getClass()) return false;\n        \n        Pitch that = (Pitch) obj;\n        return this.value == that.value;\n    }\n\n    @Override\n    public int hashCode() {\n        return value;\n    }\n\n    /**\n     * @return this pitch in abc music notation\n     * @see \"http://www.walshaw.plus.com/abc/examples/\"\n     */\n    @Override\n    public String toString() {\n        String suffix = \"\";\n        int v = value;\n\n        while (v < 0) {\n            suffix += \",\";\n            v += OCTAVE;\n        }\n\n        while (v >= OCTAVE) {\n            suffix += \"'\";\n            v -= OCTAVE;\n        }\n\n        return VALUE_TO_STRING[v] + suffix;\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282963,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/sound/SequencePlayer.java",
    "data": "package karaoke.sound;\n\nimport java.util.function.Consumer;\n\nimport karaoke.Pitch;\n\n/**\n * Schedules and plays a sequence of notes at given times.\n * Times and durations are specified in doubles, but implementations of this\n * interface may round to implementation-specific precision.\n * For example, 0.501 beats may be rounded to 0.5 beats.\n * (In MidiSequencePlayer, this precision is controlled by the ticksPerBeat\n * parameter.)\n */\npublic interface SequencePlayer {\n\n    /**\n     * Schedule a note to be played starting at startBeat for the duration numBeats.\n     * @param instr instrument for the note\n     * @param pitch pitch value of the note\n     * @param startBeat the starting beat\n     * @param numBeats the number of beats the note is played\n     */\n    public void addNote(Instrument instr, Pitch pitch, double startBeat, double numBeats);\n   \n    /**\n     * Schedule a callback when the synthesizer reaches a time.\n     * @param atBeat beat at which to call the callback\n     * @param callback function to call, with type double->void. \n     *              The double parameter is the time when actually called, in beats.\n     *              This time may be slightly different from atBeat because of rounding.\n     */\n    public void addEvent(double atBeat, Consumer<Double> callback);\n\n    /**\n     * Play the scheduled music.\n     */\n    public void play();\n    \n\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282964,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/src/karaoke/sound/WebServer.java",
    "data": " package karaoke.sound;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport com.sun.net.httpserver.HttpContext;\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\nimport karaoke.Composition;\nimport karaoke.LyricListener;\nimport karaoke.MultipleVoice;\nimport karaoke.Music;\n\n/**\n * HTTP web server interface \n * Has a different URL for each set of lyrics that a karaoke song may have.\n * Lyrics start playing with music and are synced with it. \n * \n */\n\npublic class WebServer {\n    private static final int OPERATION_SUCCESSFUL = 200;\n\n    private final HttpServer server;\n    private final MidiSequencePlayer player; \n    \n    // Abstraction function:\n    //   AF(server, player) = a web server playing karaoke from player on a specified server\n    // Representation invariant:\n    //      all elements not-null\n    // Safety from rep exposure:\n    //   all fields private and final.  \n    \n    /**\n     * Make a new web game server using board that listens for connections on port.\n     * @param filepath which leads to the music to play\n     * @param player a midisequenceplayer\n     * @param addr socket address \n     * @param time a shared variable that determines when playback should start\n     * @throws IOException if an error occurs starting the server\n     */\n     public WebServer(MidiSequencePlayer player, String filepath, InetSocketAddress addr, LinkedBlockingQueue<String> time) throws IOException{\n        this.server = HttpServer.create(addr, 0);\n\n        this.player = player;\n        \n        // handle concurrent requests with multiple threads\n        server.setExecutor(Executors.newCachedThreadPool());\n        \n        LogFilter log = new LogFilter();\n        HeadersFilter headers = new HeadersFilter();\n        // allow requests from web pages hosted anywhere\n        headers.add(\"Access-Control-Allow-Origin\", \"*\");\n        // all responses will be plain-text UTF-8\n        headers.add(\"Content-Type\", \"text/plain; charset=utf-8\");\n        \n        HttpContext play = server.createContext(\"/play/\", new HttpHandler(){\n            /** Passes the web request to appropriate play handler*/\n            public void handle(HttpExchange exchange) throws IOException{\n                handlePlay(exchange, filepath, player, time);\n            }\n        });\n        play.getFilters().addAll(Arrays.asList(log, headers));\n        checkRep();\n    }\n    \n    //CheckRep:\n    //Rep. Invariant: \n    //  port number is valid\n    //  player is not null\n    private void checkRep() {\n        assert(player!=null);\n    }\n    \n    /**\n     * @return the port on which this server is listening for connections\n     * taken from Staff's work on pset4\n     */\n    public int port() {\n        return server.getAddress().getPort();\n    }\n\n    /**\n     * Start this server in a new background thread.\n     * taken from Staff's work on pset4\n     */\n    public void start() {\n        System.err.println(\"Server will listen on \" + server.getAddress());\n        server.start();\n    }\n    \n    /**\n     * Stop this server. Once stopped, this server cannot be restarted.\n     * taken from Staff's work on pset4\n     */\n    public void stop() {\n        System.err.println(\"Server will stop\");\n        server.stop(0);\n    }\n    \n    /**\n     * handle webserver requests\n     * @param exchange an HTTP exchange requesting webserver to show the lyrics \n     *      does not play music for the non-participant\n     * @throws IOException \n     */\n    private static void handlePlay(HttpExchange exchange, String filepath, MidiSequencePlayer player, LinkedBlockingQueue<String> time) throws IOException {\n      //final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        final String path = exchange.getRequestURI().getPath();\n        \n        // it will always start with the base path from server.createContext():\n        final String base = exchange.getHttpContext().getPath();\n        assert path.startsWith(base);\n        \n        //get parts from the exchange\n        Composition composition = Composition.parse(filepath);\n        Music piece = composition.getBody();\n        \n        //get the music piece to play\n        Music music;\n        String voice;\n        if(piece.hasVoices()) {\n            voice = new ArrayList<String>(Arrays.asList(path.split(filepath+\"/\"))).get(1);\n            MultipleVoice multivoice = (MultipleVoice)piece;\n            music = multivoice.getPiece(voice);\n        }else {\n            music = piece;\n        }\n       \n        exchange.sendResponseHeaders(OPERATION_SUCCESSFUL, 0);\n        \n        // write the response to the output stream using UTF-8 character encoding\n        OutputStream body = exchange.getResponseBody();\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(body, UTF_8), true);\n        \n        //has a number of bytes as a threshold before it will start: flood it to begin\n        final int enoughBytesToStartStreaming = 2048;\n        for (int i = 0; i < enoughBytesToStartStreaming; ++i) {\n            out.print(' ');\n        } //and flush: \n        out.println(); \n        \n        //create listeners\n        LyricListener listen = new LyricListener(out); \n        Optional<LyricListener>listener = Optional.of(listen);\n        double warmup = 0.125;\n        \n        //wait for a sign that playback should start. Also must make sure the sign does not lose state. \n        try {\n            time.take();\n            time.put(\" \");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        //play music\n        music.play(player, warmup, listener);\n        if(piece.hasVoices()) {\n            MultipleVoice multivoice = (MultipleVoice)piece;\n            for(String voiceName:multivoice.getVoices()) {\n                Music unlyriced = multivoice.getPiece(voiceName);\n                unlyriced.play(player, warmup, Optional.empty());\n            }\n        }\n        player.play();\n        listener.get().start();\n        exchange.close();\n    }\n    \n}",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282965,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/test/karaoke/parser/KaraokeParserTest.java",
    "data": "package karaoke.parser;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.IOException;\nimport org.junit.Test;\nimport karaoke.Composition;\nimport karaoke.Header;\nimport karaoke.Music;\n\npublic class KaraokeParserTest {\n\n    @Test(expected = AssertionError.class) public void testAssertionsEnabled() {\n        assert false; // make sure assertions are enabled with VM argument: -ea\n    }\n\n    //Testing strategy for parser:\n    //          Header: index number, title, key signature, composer\n    //                  default tempo, assigned tempo\n    //                  one voice, multiple voices\n    //                  default note length, assigned note length\n    //                  default meter, assigned meter\n    //          Body:   with lyrics, without lyrics\n    //                  duplets, triplets, quadruplets, \n    //                  multiple and single voices, \n    //                  chords, and notelengths:\n    //                  1/4, 1/2, 3/4, 1/3, 2/3, full\n    //                  Rests, repeats\n\n/////////////////// HEADER TESTS/////////////////////\n\n    // Test header for index number, title, composer, default tempo, and keySignature\n    @Test public void testHeaderIndexTitleComposerKey() throws IOException {\n        Composition composition = Composition.parse(\"sample-abc/paddy.abc\");\n        Header header = composition.getHeader();\n        assertEquals(\"index not correct\", 1, header.getIdx(), 0);\n        assertEquals(\"title not correct\", \"Paddy O'Rafferty\", header.getTitle());\n        assertEquals(\"composer not correct\", \"Trad.\", header.getComposer());\n        assertEquals(\"key signature not correct\", \"D\", header.getKey());\n        assertEquals(\"default tempo should be\", 200, header.getTempo()); \n    }\n\n    // Test header for tempo, meter and default note length\n    @Test public void testTempoMeterNoteLength() throws IOException {\n        Composition composition = Composition.parse(\"sample-abc/paddy.abc\");\n        Header header = composition.getHeader();\n        assertEquals(\"tempo not correct\", 200, header.getTempo(), 0);\n        assertEquals(\"note length not correct\", 0.125, header.getNoteLength(), 0.01);\n        assertEquals(\"meter not correct\", 0.75, header.getMeter(), 0.01);\n    }\n\n    // Test header for assigned note length\n    @Test public void testAssignedNoteLength() throws IOException {\n        Composition composition = Composition.parse(\"sample-abc/piece3.abc\");\n        Header header = composition.getHeader();\n        assertEquals(\"note length wrong\", 0.125, header.getNoteLength(), 0.01);\n    }\n\n    // Test header for default meter\n    @Test public void testDefaultMeter() throws IOException {\n        Composition composition = Composition.parse(\"sample-abc/sample1.abc\");\n        Header header = composition.getHeader();\n        assertEquals(\"meter wrong\", 1, header.getMeter(), 0.01);\n    }\n\n    /////////////////// BODY TESTS/////////////////////\n    \n    //note lengths for thirds.\n    private String twoThirds = Double.toString(2.0/3.0);\n    private String oneThird = Double.toString(1.0/3.0);\n   \n    // Tests body with no chords and no lyrics.  Tests timing esp. w/tuples.\n    @Test public void testNoChordsNoLyrics() throws IOException {\n        String bodyString = \"C1.0 C1.0 C0.75 D0.25 E1.0 E0.75 D0.25 E0.75 F0.25 G2.0 C'\"\n                +oneThird+\" C'\"+oneThird+\" C'\"+oneThird+\" G\"+oneThird+\" G\"+oneThird\n                +\" G\"+oneThird+\" E\"+oneThird+\" E\"+oneThird+\" E\"+oneThird+\" C\"+oneThird\n                +\" C\"+oneThird+\" C\"+oneThird+\" G0.75 F0.25 E0.75 D0.25 C2.0\";\n        parseAndCheck(\"sample-abc/piece1.abc\", bodyString);\n    }\n\n    // Tests body with chords and tuples\n    @Test public void testChords() throws IOException {\n        String bodyString = \"[^F0.5, E'0.5] [^F0.5, E'0.5] z0.5 [^F0.5, E'0.5] \"\n                + \"z0.5 [^F0.5, C'0.5] [^F1.0, E'1.0] [G1.0, B1.0, G'1.0] \"\n                + \"z1.0 G1.0 z1.0 C'1.5 G0.5 z1.0 E1.0 E0.5 A1.0 B1.0 ^A0.5 \"\n                + \"A1.0 G\"+twoThirds+\" E'\"+twoThirds+\" G'\"+twoThirds\n                +\" A'1.0 F'0.5 G'0.5 z0.5 E'1.0 C'0.5 D'0.5 B0.75 z0.75\";\n        parseAndCheck(\"sample-abc/piece2.abc\", bodyString);\n    }\n\n    // Tests notes of body with lyrics. See LyricTests for lyric streaming tests.\n    @Test public void testLyrics() throws IOException {\n        String bodyString = \"z4.0 D2.0 G4.0 B1.0 G1.0 B4.0 A2.0 G4.0 E2.0 D4.0 \"\n                + \"D2.0 G4.0 B1.0 G1.0 B4.0 A2.0 D'6.0\";\n        parseAndCheck(\"sample-abc/piece3.abc\", bodyString);\n    }\n    \n    //Tests notes of multi-voiced body. pieces have a number of blank zeroes (got via trial/error)\n    //      hard coded into the compare line. This does not matter ot the parsing since blank zeroes\n    //      do not effect the music at all. \n    @Test public void testVoices() throws IOException {\n        String firstVoice = \"z0.5 C0.5 D0.5 E0.5 F0.5 D0.5 E0.5 C0.5 G1.0 C'1.0 B1.0 C'1.0 \";\n        String secondVoice = \"z4.0 z0.5 C,0.5 D,0.5 E,0.5 F,0.5 D,0.5 E,0.5 C,0.5 \";\n        String bodyString = \"{\"+\"1=\"+firstVoice+\", 2=\"+secondVoice+\"}\";\n        parseAndCheck(\"sample-abc/LyricTestMultiVoice.abc\", bodyString);\n    }\n    \n    //Tests duplets and quadruplets\n    @Test public void testDupletsTriplets()throws IOException{\n        String bodyString = \"A1.5 B1.5 A0.75 B0.75 C0.75\";\n        parseAndCheck(\"sample-abc/dupletQuadruplet.abc\", bodyString);\n    }\n    \n    //Tests repeat of an entire piece\n    @Test public void testRepeatAll()throws IOException{\n        String bodyString = \"A4.0 A4.0\";\n        parseAndCheck(\"sample-abc/LyricTestSingleRepeatAll.abc\", bodyString);\n    }\n    \n    //Tests repeat of a section\n    @Test public void testRepeatSection()throws IOException{\n        String bodyString = \"A4.0 E4.0 E4.0 A4.0\";\n        parseAndCheck(\"sample-abc/LyricTestSingleRepeatSection.abc\", bodyString);\n    }\n    //Tests repeat with two different endings\n    @Test public void testRepeatDiffEndings()throws IOException{\n        String bodyString = \"A4.0 C4.0 G4.0 G4.0 C4.0 F4.0\";\n        parseAndCheck(\"sample-abc/LyricTestRepeatDiffEndings.abc\", bodyString);\n    }\n    \n    /**\n     * takes a piece and says whether it was parsed as expected.  \n     * @param filepath to the piece to be parsed\n     * @param expected queued stirng of expected output\n     * @throws IOException if filepath does not lead to a viable file\n     */\n    public static void parseAndCheck(String filepath, String expected) throws IOException {\n        Composition composition = Composition.parse(filepath);\n        Music music = composition.getBody();\n        String parsed = music.toString();\n        //remove empty rests and end spaces\n        String refined = parsed.replaceAll(\"z0.0 \", \"\");\n        String refined2 = refined.replaceAll(\"z0.0\", \"\");\n        while(refined2.endsWith(\" \")) {\n            refined2 = refined2.substring(0, refined2.length()-1);\n        }\n        assertEquals(expected, refined2);\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:55"
  }
},
{
  "model": "review.file",
  "pk": 282966,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/test/karaoke/sound/LyricsTest.java",
    "data": "package karaoke.sound;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\nimport org.junit.Test;\nimport edu.mit.eecs.parserlib.UnableToParseException;\n\n/**\n * Automated tests for lyric streaming \n */\n\npublic class LyricsTest {\n    /*\n     * Testing strategy:\n     *  Handling multiple-syllable words\n     *  Multiple bars (bars do not appear)\n     *  Multiple lines and line changeover.\n     *  Behavior with special characters:\n     *       *: highlighted filler-character '*'\n     *      \\-: two syllables under one note, printed as a hyphen\n     *       -: separates two syllables, each is highlighted separately.\n     *      --: regarded as a separate syllable \n     *       _: syllable is held for an extra note (highlighted for two notes)\n     *      __: syllable is held for N extra notes (highlighted for N extra notes)\n     *       ~: multiple words held under one note.  Appearing as a space\n     *       |: advance lyrics to next bar (even if not enough syllables for notes in bar)\n     *    ' -': behaves exactly as --\n     *  Uneven lengths: \n     *      more notes than syllables: remaining notes have no lyrics \n     *      more syllables than notes: extra syllables ignored. \n     *          this happens automatically in our implementation \n     *  Repeat all.\n     *      Repeat one only part\n     *      Repeat two different endings \n     *  Voices\n     *      single and multiple\n     *      same length.\n     *  Timing: done manually.\n     *      Each test is associated with a short music piece accompanying its case.\n     *      For each, from command line run the piece with the music, following the instructions\n     *      about the url and the browser.\n     *      Watch to make sure a new line appears on the screen with each note heard. \n     */\n    \n    /**\n     * case: test assertions enabled with VM argument: -ea\n     */\n    @Test(expected = AssertionError.class) public void testAssertionsEnabled() {\n        assert false; \n    }\n    \n    /**\n    * case: behavior with '*' and notes without lyrics.\n    * @category no_didit\n    */\n    @Test\n    public void testStar() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException { \n        String musicFile = \"sample-abc/LyricTestBlank.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*Here* is a ???? see\",\n                \"Here *is* a ???? see\",\n                \"Here is *a* ???? see\",\n                \"Here is a *????* see\",\n                \"Here is a ???? *see*\",\n                \"???? ???? ????\",\n                \"???? ???? ????\",\n                \"???? ???? ????\"));\n        playAndCheck(musicFile, lyricStream);\n    }\n\n    /**\n     * case: behavior with '\\-' and printing hyphen and joining syllables under a note\n     * @category no_didit\n     */\n    @Test\n    public void testMultiSyllableNote() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{ \n        String musicFile = \"sample-abc/LyricTestMultiSyllableOneNote.abc\";//multiple syllable\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*win-ter* is\",\n                \"win-ter *is*\"));\n        playAndCheck(musicFile, lyricStream);\n    }\n   \n    /**\n     * case: behavior with '-' and multiple syllables\n     * @category no_didit\n     */\n    @Test \n    public void testMultiSyllableWord() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{ \n        String musicFile = \"sample-abc/LyricTestMultiSyllable.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*win*-ter's now\",\n                \"win-*ter's* now\",\n                \"win-ter's *now*\"));\n        \n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: behavior with '--' and empty syllables\n     * @category no_didit\n     */\n    @Test\n    public void testEmptySyllable() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{ \n        String musicFile = \"sample-abc/LyricTestEmptySyllable.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*syll*-a- ???? ble\",\n                \"syll-*a*- ???? ble\",\n                \"syll-a *????* ble\",\n                \"syll-a- ???? *ble*\"\n        ));\n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: behavior with '--' and empty syllables \n     * @category no_didit\n     */\n    @Test\n    public void testBackslashHyphen() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{ \n        String musicFile = \"sample-abc/LyricTestBackslashHyphen.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*syll*-a-ble ????\",\n                \"syll-*a-ble* ????\",\n                \"syll-a*-*ble ????\"\n        ));\n        playAndCheck(musicFile, lyricStream);\n    }\n\n    /**\n     *case: behavior with '--' and ' -' are equivalent\n     * @category no_didit\n     */\n    @Test\n    public void testEmptySyllableEquivalency() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{ \n        String musicFile = \"sample-abc/LyricTestMultipleHyphens.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*syll*-a- ???? ble syll-a- ???? ble\",\n                \"syll-*a*- ???? ble syll-a- ???? ble\",\n                \"syll-a- *????* ble syll-a- ???? ble\",\n                \"syll-a- ???? *ble* syll-a- ???? ble\",\n                \"syll-a- ???? ble *syll*-a- ???? ble\",\n                \"syll-a- ???? ble syll-*a*- ???? ble\",\n                \"syll-a- ???? ble syll-a- *????* ble\",\n                \"syll-a- ???? ble syll-a- ???? *ble*\"));\n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: behavior with '_' and holding syllables\n     * @category no_didit\n     */\n    @Test\n    public void testHoldOne() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{ \n        String musicFile = \"sample-abc/LyricTestSingleHolds.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*The* days are\",\n                \"The *days* are\",\n                \"The *days* are\",\n                \"The days *are*\"));\n        playAndCheck(musicFile, lyricStream);        \n    }\n  \n    /**\n     * case: behavior with '__' and syllables held for >2 notes.\n     * @category no_didit\n     */\n    @Test\n    public void testHoldMulti() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{ \n        String musicFile = \"sample-abc/LyricTestMultipleHold.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*hold* more\",\n                \"*hold* more\",\n                \"*hold* more\",\n                \"hold *more*\",\n                \"hold *more*\",\n                \"hold *more*\"));\n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: behavior with '~' and multiple words being held under a note, appearing as a space\n     * @category no_didit\n     */\n    @Test\n    public void testMultiWordNote() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{ \n        String musicFile = \"sample-abc/LyricTestMultiWordOneNote.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*long it* is cold\",\n                \"long it *is* cold\",\n                \"long it is *cold*\",\n                \"long it is cold\"\n        ));\n        playAndCheck(musicFile, lyricStream);\n    }\n   \n    /**\n     * case: not enough notes when bar happens\n     * @category no_didit\n     */\n    @Test\n    public void testBarTooSoon() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException {\n        String musicFile = \"sample-abc/LyricTestBar.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*Here* is a ???? see it was blank\",\n                \"Here *is* a ???? see it was blank\",\n                \"Here is *a* ???? see it was blank\",\n                \"Here is a *????* see it was blank\",\n                \"Here is a ???? *see* it was blank\",\n                \"Here is a ???? see *it* was blank\",\n                \"Here is a ???? see it *was* blank\",\n                \"Here is a ???? see it was *blank*\"\n        ));\n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: uneven lengths more notes than syllables and blank syllables\n     * @category no_didit\n     */\n    @Test\n    public void testNotesOutnumberSyllables() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException {\n        String musicFile = \"sample-abc/LyricTestMoreNotes.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*not* 'nough\",\n                \"not *'nough*\",\n                \"???? ???? ????\", \n                \"???? ???? ????\" ));\n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: uneven lengths more syllables than notes and cutting off the syllables\n     * @category no_didit\n     */\n    @Test \n    public void testSyllablesOutnumberNotes() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{\n        String musicFile = \"sample-abc/LyricTestMoreSyllables.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*here* are too man\",\n                \"here *are* too man\",\n                \"here are *too* man\",\n                \"here are too *man*\" ));\n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: repeat everything\n     * @category no_didit\n     */\n    @Test\n    public void testRepeatAll() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{\n        String musicFile = \"sample-abc/LyricTestSingleRepeatAll.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*cat*\",\n                \"*cat*\"));\n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: repeat a section\n     * @category no_didit\n     */\n    @Test\n    public void testRepeatCenter() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{\n        String musicFile = \"sample-abc/LyricTestSingleRepeatSection.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*cat* dog cat\",\n                \"cat *dog* cat\",\n                \"*cat* dog cat\",\n                \"cat *dog* cat\",\n                \"cat dog *cat*\"));\n        playAndCheck(musicFile, lyricStream);\n    }\n    \n    /**\n     * case: repeat with a different ending \n     * @category no_didit\n     */\n    @Test\n    public void testRepeatDiffEnding() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{\n        String musicFile = \"sample-abc/LyricTestRepeatDiffEndings.abc\";\n        Queue<String> lyricStream = new LinkedList<>(Arrays.asList(\n                \"*A* C G G F\",\n                \"A *C* G G F\",\n                \"A C *G* G F\",\n                \"A C G *G* F\",\n                \"*A* C G G F\",\n                \"A *C* G G F\",\n                \"A C G G *F*\"));\n        playAndCheck(musicFile, lyricStream);\n    }\n   \n    /**\n     * case: two voices with different start and end times, and different lyrics. \n     * @category no_didit\n     */\n    @Test\n    public void testTwoVoices() throws UnableToParseException, IOException, MidiUnavailableException, InvalidMidiDataException{\n        String musicFile = \"sample-abc/LyricTestMultiVoice.abc\";\n        String upperVoice = \"1\";\n        String lowerVoice = \"2\";\n        Queue<String> upperLyricStream = new LinkedList<>(Arrays.asList(\n                \"*this* is the up-per sec-tion\",\n                \"this *is* the up-per sec-tion\",\n                \"this is *the* up-per sec-tion\",\n                \"this is the *up*-per sec-tion\",\n                \"this is the up-*per* sec-tion\",\n                \"this is the up-per *sec*-tion\",\n                \"this is the up-per sec-*tion*\",\n                \"???? ???? ????\",\n                \"???? ???? ????\",\n                \"???? ???? ????\",\n                \"???? ???? ????\"));\n        Queue<String>lowerLyricStream = new LinkedList<>(Arrays.asList( \n                \"*and* here is part two\",\n                \"and *here* is part two\",\n                \"and here *is* part two\",\n                \"and here is *part* two\",\n                \"and here is part *two*\",\n                \"???? ???? ????\",\n                \"???? ???? ????\"));\n        playAndCheck(musicFile, upperVoice, upperLyricStream);\n        playAndCheck(musicFile, lowerVoice, lowerLyricStream); \n    }\n    \n    ///////////HELPER///////////\n    /**\n     * takes in a music file and an list of the lyrics expected to appear on webpage\n     * during the course of the piece.\n     * checks that the output of playing the music file is indeed the same as expected \n     * @param musicFile file path to the music file to be played\n     * @param expectedStream what lyrics are expected to be played\n     * @throws UnableToParseException\n     * @throws IOException\n     * @throws MidiUnavailableException\n     * @throws InvalidMidiDataException\n     */\n    private static synchronized void playAndCheck(String musicFile, Queue<String>expectedStream) \n            throws UnableToParseException, IOException, MidiUnavailableException, \n            InvalidMidiDataException {\n        //create player\n        MidiSequencePlayer player = new MidiSequencePlayer(100, 100);\n        \n        //create web server\n        int portDefault = 8080;\n        InetSocketAddress addr = new InetSocketAddress(\"localhost\", portDefault);\n        LinkedBlockingQueue<String>time = new LinkedBlockingQueue<>(); \n        WebServer server = new WebServer(player, musicFile, addr, time);\n        server.start();\n\n        //opening page and starting \n        final URL url = new URL(\"http://localhost:8080/play/\"+ musicFile); \n        final InputStream input = url.openStream();\n        try {\n            time.put(\" \");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(input, UTF_8));\n        String line;\n        \n        //read and compare\n        while(reader.ready()) {\n            line = reader.readLine();\n            while(line.trim().length() == 0) {      \n                line = reader.readLine();\n            }\n            if (line.trim().length() > 0) {\n                String expected = expectedStream.remove();\n                if (line.equals(expected)) {\n                    assert true;\n                } else {\n                    server.stop();\n                    assert false;\n                }\n            }\n        }\n        server.stop();\n    }\n    \n    /**\n     * Overloads \"play and check\", allowing for use when a voice is specified. \n     * takes in a music file and an list of the lyrics expected to appear on webpage\n     * during the course of the piece.\n     * checks that the output of playing the music file is indeed the same as expected \n     * @param musicFile file path to the music file to be played\n     * @param voice that the music file should be playing\n     * @param expectedStream what lyrics are expected to be played\n     * @throws UnableToParseException\n     * @throws IOException\n     * @throws MidiUnavailableException\n     * @throws InvalidMidiDataException\n     */\n    private static synchronized void playAndCheck(String musicFile, String voiceName, Queue<String>expectedStream) \n            throws UnableToParseException, IOException, MidiUnavailableException, \n            InvalidMidiDataException {\n        \n        MidiSequencePlayer player = new MidiSequencePlayer(100, 100);\n       \n        //create webserver\n        int portDefault = 8080;\n        InetSocketAddress addr = new InetSocketAddress(\"localhost\", portDefault);\n        LinkedBlockingQueue<String>time = new LinkedBlockingQueue<>(); \n        WebServer server = new WebServer(player, musicFile, addr, time);\n        server.start();\n\n        //open page and operate\n        final URL url = new URL(\"http://localhost:8080/play/\"+ musicFile+\"/\"+voiceName); \n        final InputStream input = url.openStream();\n        try {\n            time.put(\" \");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        //read and compare\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(input, UTF_8));\n        String line;\n        while(reader.ready()) {\n            line = reader.readLine();\n            while(line.trim().length() == 0) {      \n                line = reader.readLine();\n            }\n            if (line.trim().length() > 0) {\n                String expected = expectedStream.remove();\n                if (line.equals(expected)) {\n                    assert true;\n                } else {\n                    server.stop();\n                    assert false;\n                }\n            }\n        }\n        server.stop();\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:56"
  }
},
{
  "model": "review.file",
  "pk": 282967,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/test/karaoke/sound/SequencePlayerTest.java",
    "data": "package karaoke.sound;\n\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\n\nimport org.junit.Test;\n\nimport karaoke.Main;\n\npublic class SequencePlayerTest {\n\n    @Test(expected = AssertionError.class) public void testAssertionsEnabled() {\n        assert false; // make sure assertions are enabled with VM argument: -ea\n    }\n    \n    /**\n     * Test piece1.abc - Row Row Row Your Boat\n     * @category no_didit\n     */\n    @Test \n    public void playPiece1() throws MidiUnavailableException, InvalidMidiDataException {\n        final int beatsPerMinute = 140;\n        final String music = \"C C C3/4 D/4 E | E3/4 D/4 E3/4 F/4 G2 | c/3 c/3 c/3 G/3 G/3 G/3 E/3 E/3 E/3 C/3 C/3 C/3 | G3/4 \"\n                + \"F/4 E3/4 D/4 C2\";\n        \n        playPiece(beatsPerMinute, music);\n    }\n    \n    /**\n     * Test piece2.abc - Super Mario Bros. Theme Song\n     * @category no_didit\n     */\n    @Test\n    public void playPiece2() throws MidiUnavailableException, InvalidMidiDataException {\n        final String music = \"^Fe/2 ^Fe/2 z/2 ^Fe/2 z/2 ^Fc/2 ^Fe | GBg z G z |\"\n                + \" c3/2 G/2 z E | E/2 A B _B/2 A | G2/3 e2/3 g2/3 a f/2 g/2 | z/2 e c/2 d/2 B3/4 z3/4\";\n        final int beatsPerMinute = 200;\n        \n        playPiece(beatsPerMinute, music);\n    }\n    \n    /**\n     * Test piece3.abc - Amazing Grace - with lyrics\n     * @category no_didit\n     */\n    @Test\n    public void playPiece3() throws MidiUnavailableException, InvalidMidiDataException {\n        final String music = \"z4 D2 | G4 B G | B4 A2 | G4 E2 | D4 D2 | G4 B G | B4 A2 | d6\";\n\n        final String lyrics = \"* A- ma- zing_ grace! How sweet the sound That saved a_ wretch like me.\";\n        final int beatsPerMinute = 200; // normally the tempo is 100. but playPiece does not allow for 1/8 beat value.\n        \n        playPiece(beatsPerMinute, music, lyrics);\n    }\n    \n    /**\n     * Test how the SequencePlayer as in Main.makePlayer plays abc_song\n     * @throws InterruptedException \n     * @category no_didit\n     */\n    @Test public void playAbcSong() throws InterruptedException {\n        SequencePlayer player = Main.makePlayer(\"sample-abc/abc_song.abc\");\n        player.play();\n        // TODO this is a work in progress\n    }\n   \n    private static void playPiece(final int beatsPerMinute, final String music, final String lyrics) throws MidiUnavailableException, InvalidMidiDataException {\n        Instrument piano = Instrument.PIANO;\n\n        // create a new player\n        final int ticksPerBeat = 64; // allows up to 1/64-beat notes to be played with fidelity\n        final SequencePlayer player = new MidiSequencePlayer(beatsPerMinute, ticksPerBeat);\n\n        final Object lock = SequencePlayerTestHelper.parseMusic(player, piano, music, lyrics);\n\n        // print the configured player\n        System.out.println(player);\n\n        // play!\n        player.play();\n\n        // wait until player is done\n        // (not strictly needed here, but useful for JUnit tests)\n        synchronized (lock) {\n            try {\n                lock.wait();\n                System.out.println();\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n        System.out.println(\"done playing\");\n    }\n\n    private static void playPiece(final int beatsPerMinute, final String music) throws MidiUnavailableException, InvalidMidiDataException {\n        playPiece(beatsPerMinute, music, \"\");\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:56"
  }
},
{
  "model": "review.file",
  "pk": 282968,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/test/karaoke/sound/SequencePlayerTestHelper.java",
    "data": "package karaoke.sound;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport karaoke.Pitch;\n\npublic class SequencePlayerTestHelper {\n\n    private static Pattern pitchPattern = Pattern.compile(\"(_+|^+)?([A-Ga-g])(,+|'+)?\");\n    private static Pattern durationPattern = Pattern.compile(\"(\\\\/(\\\\d+))|((\\\\d+)(\\\\/(\\\\d+))?)\");\n    private static Pattern lyricsPattern = Pattern.compile(\"\\\\*|([A-Za-z0-9!?\\\\.]+(-)?)|_\");\n\n    /**\n     * Parses very simple music. Is intended only as a helper function for tests in SequencePlayerTest.\n     * @param player The SequencePlayer to play the music from.\n     * @param instr The instrument to play as.\n     * @param music A string of chords that are separated by spaces \" \" and measure bars \"|\". Chords are defined to\n     * be any non-separated group of pitches. Each pitch is defined to be some number of accidentals (^ or _), followed by\n     * a note name (which may be lowercase, signifying one octave higher), followed by some number of octave transposes\n     * (' or ,). Formally: \n     *      pitch := (_+|^+)?[A-Ga-g](,+|'+)?\n     * \n     * At the end of each chord is optionally a duration. If none is supplied, it is assumed to be 1.\n     * \n     * A duration takes the form of a numerator and denominator.\n     * Formally:\n     *      duration := \\\\d*(/\\\\d+)?\n     * \n     * Example usage with multi-note chords and triplets:\n     *      String music = \"C C C3/4 D/4 CE | CE3/4 D/4 CE3/4 F/4 CG2 | Cc/3 c/3 c/3 CG/3 G/3 G/3 CE/3 E/3 E/3 C/3 C/3 \"\n     *                   + \"C/3 | CG3/4 F/4 CE3/4 D/4 C2\";\n     *      Object lock = parseMusic(player, instr, music, \"\");\n     *      player.play();\n     *      // wait on the lock until lock.notify() is called by the player...\n     * @param lyrics A string containing lyrics. These are separated by [non-alphanumeric/*] characters. An asterisk \"*\"\n     * represents a rest over the duration of a chord. A \"_\" represents sustaining the last syllable over the chord.\n     * For an example, see SequencePlayerTest.playPiece3(). \n     * \n     * @return A lock that notifies when the end of the piece has occurred.\n     */\n    public static Object parseMusic(final SequencePlayer player, final Instrument instr, final String music,\n            final String lyrics) {\n\n        List<Chord> chords = parse(music);\n\n        double startBeat = 0;\n\n        Matcher mLyrics = lyricsPattern.matcher(lyrics);\n\n        for (Chord chord : chords) {\n            for (Pitch pitch : chord.pitches) {\n                // addNote(instr, pitch, startBeat, numBeats) schedules a note with pitch value 'pitch'\n                // played by 'instr' starting at 'startBeat' to be played for 'numBeats' beats.\n                player.addNote(instr, pitch, startBeat, chord.duration);\n            }\n            if (!lyrics.isEmpty()) {\n                final String lyric = getLyric(mLyrics);\n                \n                player.addEvent(startBeat, (Double beat) -> {\n                    System.out.print(lyric); //advancing lyrics so put to the \n                });\n            }\n            startBeat += chord.duration;\n        }\n\n        // add a listener at the end of the piece to tell main thread when it's done\n        Object lock = new Object();\n        player.addEvent(startBeat, (Double beat) -> {\n            synchronized (lock) {\n                lock.notify();\n            }\n        });\n\n        return lock;\n    }\n    \n    private static String getLyric(Matcher mLyrics) {\n        mLyrics.find();\n        String lyric = mLyrics.group();\n        if (mLyrics.group(1) != null && mLyrics.group(2) == null)\n            // if this is a syllable that doesn't contain a following syllable, add a space\n            lyric += \" \";\n        else if (mLyrics.group(1) == null)\n            // if this is not a syllable, but a rest or syllable extension \"_\", add a space\n            lyric += \" \";\n        \n        return lyric.replaceAll(\"-\", \"\");\n    }\n\n    private static List<Chord> parse(String music) {\n        music = music.replaceAll(\"\\\\|\", \"\").replaceAll(\" +\", \" \").trim();\n\n        List<Chord> chords = new ArrayList<>();\n\n        for (String block : music.split(\" \")) {\n            chords.add(parsePitchBlock(block));\n        }\n\n        return chords;\n    }\n\n    private static Chord parsePitchBlock(String block) {\n        Matcher mPitch = pitchPattern.matcher(block);\n        Matcher mDuration = durationPattern.matcher(block);\n\n        List<Pitch> pitches = getPitches(mPitch);\n        double duration = getDuration(mDuration);\n\n        return new Chord(pitches, duration);\n    }\n\n    private static double getDuration(Matcher m) {\n        if (m.find()) {\n            String singleDenominator = m.group(2);\n            String numerator = m.group(4);\n            String denominator = m.group(6);\n\n            if (singleDenominator != null)\n                return 1 / Double.parseDouble(singleDenominator);\n\n            double numeratorValue = numerator == null ? 1 : Double.parseDouble(numerator);\n            double denominatorValue = denominator == null ? 1 : Double.parseDouble(denominator);\n\n            return numeratorValue / denominatorValue;\n        } else {\n            return 1;\n        }\n    }\n\n    private static List<Pitch> getPitches(Matcher m) {\n        List<Pitch> pitches = new ArrayList<>();\n\n        while (m.find()) {\n            pitches.add(getPitch(m));\n        }\n\n        return pitches;\n    }\n\n    private static Pitch getPitch(Matcher m) {\n        String accidental = m.group(1);\n        String noteName = m.group(2);\n        assert noteName.length() == 1 : \"noteName should be a single letter but was \" + noteName;\n        String octave = m.group(3);\n\n        int transpose = getTranspose(accidental, octave);\n        \n        if (Character.isLowerCase(noteName.charAt(0))) {\n            transpose += Pitch.OCTAVE;\n            noteName = noteName.toUpperCase();\n        }\n\n        Pitch pitch = new Pitch(noteName.charAt(0));\n        return pitch.transpose(transpose);\n    }\n\n    private static int getTranspose(String accidental, String octave) {\n        int transpose = 0;\n\n        accidental = (accidental == null) ? \"\" : accidental;\n        octave = (octave == null) ? \"\" : octave;\n\n        for (char c : (accidental + octave).toCharArray()) {\n            switch (c) {\n            case '_':\n                transpose--;\n                break;\n            case '^':\n                transpose++;\n                break;\n            case ',':\n                transpose -= Pitch.OCTAVE;\n                break;\n            case '\\'':\n                transpose += Pitch.OCTAVE;\n                break;\n            default:\n                throw new AssertionError(\"found \" + c + \" but expected either , or ' or _ or '\");\n            }\n        }\n\n        return transpose;\n    }\n\n    private static class Chord {\n\n        private double duration;\n        private List<Pitch> pitches;\n\n        private Chord(List<Pitch> pitches, double duration) {\n            this.pitches = pitches;\n            this.duration = duration;\n        }\n    }\n\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:56"
  }
},
{
  "model": "review.file",
  "pk": 282969,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/sp18/code/karaoke/final/cww-mayalk-sebatoro/test/karaoke/sound/SoundOutputTest.java",
    "data": "package karaoke.sound;\n\nimport org.junit.Test;\n\nimport karaoke.Composition;\nimport karaoke.parser.KaraokeParser;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.IOException;\nimport javax.sound.midi.InvalidMidiDataException;\nimport javax.sound.midi.MidiUnavailableException;\nimport edu.mit.eecs.parserlib.UnableToParseException;\nimport java.util.Optional;\n\n\npublic class SoundOutputTest {\n    /*\n     * Testing strategy:\n     *         Automated testing for Music playing at right time on MidiSequencePlayer:\n     *         - Note: play for duration of Note\n     *              -note lengths: 1, numerator, numerator/denominator, denominator, '/', numerator/\n     *         - Rest: nothing playing for the duration of Rest\n     *         - Chord: several Note objects playing at same time\n     *         - Tuplets:\n     *               -Duplets: Notes play at 3/2 of base note duration\n     *               -Triplets Notes play at 2/3 of base note duration\n     *               -Quadruplets: Notes play at 3/4 of base note duration\n     *         -Voices:\n     *               -voices with notes at same times\n     *               -voices with notes at different times\n     *         -Repeats:\n     *                -One Ending: repeat major music section\n     *                -Multiple Endings: repeat major music section with different end bars\n     *                \n     *         Automated testing for Music playing correct pitch:\n     *         - natural pitch\n     *         - key signature\n     *         - accidentals: #,?,?, ##, ??\n     *              -memory within bar, outside of bar return to key signature\n     *         - octaves: , and ' and lowercase\n     *         \n     *         Manual Testing Stategy:\n     *         - Listened to all the files in sample-abc and followed note by note\n     */\n    \n    //value of 64\n    private static final int TICKS_PER_BEAT = MidiSequencePlayer.DEFAULT_TICKS_PER_BEAT; \n    private static final double WARMUP = 0.125;//track starts at tick 8\n    \n    //test assertions enabled\n    @Test(expected = AssertionError.class) public void testAssertionsEnabled() {\n        assert false; \n    }\n    \n    private static String[] getPlayerTrackEvents(String filename) throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        Composition composition = KaraokeParser.parse(filename);\n        MidiSequencePlayer player =  new MidiSequencePlayer(composition.getHeader().getTempo(), TICKS_PER_BEAT);\n        composition.getBody().play(player,WARMUP, Optional.empty());\n        String trackEvents = player.toString();\n        System.out.println(trackEvents);\n        return trackEvents.split(\"\\n\");\n    }\n    \n    private static void checkEvents(String[] trackEvents, String[] testEvents) {\n        for (int eventIdx=0; eventIdx<trackEvents.length; eventIdx++) {\n            assertEquals(trackEvents[eventIdx],testEvents[eventIdx]);\n        }\n    }\n    \n    /* Note playing at correct time\n     * -natural pitch\n     * -octave lowercase and ' and ,\n     * @category no_didit\n     */\n    @Test public void testNote() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/sample1.abc\");\n        String[] testEvents = new String[] {\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                \"Event: NOTE_ON  Pitch: 48  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 48  Tick: 136\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 264\",\n                \"Event: NOTE_ON  Pitch: 84  Tick: 264\",\n                \"Event: NOTE_OFF Pitch: 84  Tick: 328\",\n                \"Event: NOTE_ON  Pitch: 96  Tick: 328\",\n                \"Event: NOTE_OFF Pitch: 96  Tick: 392\",\n                \"Meta event: END_OF_TRACK Tick: 392\"   \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n    /* Rest playing at correct time\n     * @category no_didit\n     */\n    @Test public void testRest() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/SoundOutputTestRest.abc\");\n        String[] testEvents = new String[] {\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 72\",\n                //rest for 64 ticks = 1 beat\n                //2 rests\n                \"Event: NOTE_ON  Pitch: 60  Tick: 200\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 264\",\n                \"Meta event: END_OF_TRACK Tick: 264\"   \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n    /* Chord has Note objects playing at same time\n     * @category no_didit\n     */\n    @Test public void testChord() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/SoundOutputTestChord.abc\");\n        String[] testEvents = new String[] {\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 8\",\n                \"Event: NOTE_ON  Pitch: 64  Tick: 8\",\n                \"Event: NOTE_ON  Pitch: 67  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 72\",\n                \"Event: NOTE_OFF Pitch: 64  Tick: 72\",\n                \"Event: NOTE_OFF Pitch: 67  Tick: 72\",\n                \"Event: NOTE_ON  Pitch: 65  Tick: 72\",\n                \"Event: NOTE_ON  Pitch: 69  Tick: 72\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 72\",\n                \"Event: NOTE_OFF Pitch: 65  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 69  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 136\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 136\",\n                \"Event: NOTE_ON  Pitch: 64  Tick: 136\",\n                \"Event: NOTE_ON  Pitch: 67  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 200\",\n                \"Event: NOTE_OFF Pitch: 64  Tick: 200\",\n                \"Event: NOTE_OFF Pitch: 67  Tick: 200\",\n                \"Event: NOTE_ON  Pitch: 65  Tick: 200\",\n                \"Event: NOTE_ON  Pitch: 69  Tick: 200\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 200\",\n                \"Event: NOTE_OFF Pitch: 65  Tick: 264\",\n                \"Event: NOTE_OFF Pitch: 69  Tick: 264\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 264\",\n                \"Meta event: END_OF_TRACK Tick: 264\"   \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n    /* Tests note lengths: 1, numerator, numerator/denominator, denominator, '/', numerator/\n     * @category no_didit\n     */\n    @Test // note lengths: 1, numerator, numerator/denominator, denominator, '/', numerator/\n    public void testNoteLengths() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/SoundOutputTestNoteLengths.abc\");\n        String[] testEvents = new String[] {\n                //C C/ C1/4 C/4 C2| C8/||\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                // length: 1\n                \"Event: NOTE_ON  Pitch: 60  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 72\",\n                // length: '/'\n                \"Event: NOTE_ON  Pitch: 60  Tick: 72\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 104\",\n                // length: 1/4\n                \"Event: NOTE_ON  Pitch: 60  Tick: 104\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 120\",\n                // length: /4\n                \"Event: NOTE_ON  Pitch: 60  Tick: 120\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 136\",\n                // length: 2\n                \"Event: NOTE_ON  Pitch: 60  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 264\",\n                // length: 8/\n                \"Event: NOTE_ON  Pitch: 60  Tick: 264\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 520\",\n                \"Meta event: END_OF_TRACK Tick: 520\"  \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n    /* Duplets: Notes play at 3/2 of base note duration\n     * Quadruplets: Notes play at 3/4 of base note duration\n     * @category no_didit\n     */\n    @Test public void testDupletsQuadruplets() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/SoundOutputTestTuplets.abc\");\n        String[] testEvents = new String[] {\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                //duplet: 3/2*64 = 96\n                \"Event: NOTE_ON  Pitch: 60  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 104\",\n                \"Event: NOTE_ON  Pitch: 64  Tick: 104\",\n                \"Event: NOTE_OFF Pitch: 64  Tick: 200\",\n                //quadruplet: 3/4*64 = 48\n                \"Event: NOTE_ON  Pitch: 67  Tick: 200\",\n                \"Event: NOTE_OFF Pitch: 67  Tick: 248\",\n                \"Event: NOTE_ON  Pitch: 71  Tick: 248\",\n                \"Event: NOTE_OFF Pitch: 71  Tick: 296\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 296\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 344\",\n                \"Event: NOTE_ON  Pitch: 65  Tick: 344\",\n                \"Event: NOTE_OFF Pitch: 65  Tick: 392\",\n                \"Meta event: END_OF_TRACK Tick: 392\"   \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n    /*\n     * Triplets Notes play at 2/3 of base note duration\n     * @category no_didit\n     */\n    @Test public void testTriplets() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/SoundOutputTestTuplets2.abc\");\n        String[] testEvents = new String[] {\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                //triplet: 2/3*64 ~ 42.666 (ADJUSTS TO TICKS PER NOTE: 42 43 43)\n                \"Event: NOTE_ON  Pitch: 60  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 50\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 50\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 93\",\n                \"Event: NOTE_ON  Pitch: 64  Tick: 93\",\n                \"Event: NOTE_OFF Pitch: 64  Tick: 136\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 178\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 178\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 221\",\n                \"Event: NOTE_ON  Pitch: 64  Tick: 221\",\n                \"Event: NOTE_OFF Pitch: 64  Tick: 264\",\n                \"Meta event: END_OF_TRACK Tick: 264\"   \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n    \n    /*accidentals: #,?,?, ##, ??\n     * -memory within bar, outside of bar return to key signature\n     * @category no_didit\n     */\n    @Test public void testAccidentals() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/SoundOutputTestAccidentals.abc\");\n        String[] testEvents = new String[] {\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                //key F#m\n                \"Event: NOTE_ON  Pitch: 61  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 61  Tick: 72\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 72\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 136\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 200\",\n                \"Event: NOTE_ON  Pitch: 61  Tick: 200\",\n                \"Event: NOTE_OFF Pitch: 61  Tick: 264\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 264\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 328\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 328\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 392\",\n                \"Event: NOTE_ON  Pitch: 64  Tick: 392\",\n                \"Event: NOTE_OFF Pitch: 64  Tick: 456\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 456\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 520\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 520\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 584\",\n                \"Event: NOTE_ON  Pitch: 64  Tick: 584\",\n                \"Event: NOTE_OFF Pitch: 64  Tick: 648\",\n                \"Event: NOTE_ON  Pitch: 66  Tick: 648\",\n                \"Event: NOTE_OFF Pitch: 66  Tick: 712\",\n                \"Event: NOTE_ON  Pitch: 66  Tick: 712\",\n                \"Event: NOTE_OFF Pitch: 66  Tick: 776\",\n                \"Event: NOTE_ON  Pitch: 68  Tick: 776\",\n                \"Event: NOTE_OFF Pitch: 68  Tick: 840\",\n                \"Event: NOTE_ON  Pitch: 67  Tick: 840\",\n                \"Event: NOTE_OFF Pitch: 67  Tick: 904\",\n                \"Event: NOTE_ON  Pitch: 67  Tick: 904\",\n                \"Event: NOTE_OFF Pitch: 67  Tick: 968\",\n                \"Meta event: END_OF_TRACK Tick: 968\"   \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n    \n    /*voices with notes at same times\n     *voices with notes at different times\n     * @category no_didit\n     */\n    @Test public void testVoices() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/SoundOutputTestVoices.abc\");\n        String[] testEvents = new String[] {\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 8\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 72\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 72\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 72\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 136\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 200\",\n                \"Meta event: END_OF_TRACK Tick: 200\"   \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n    \n    /* Repeats:\n     * -One Ending: repeat major music section\n     * -Multiple Endings: repeat major music section with different end bars\n     * @category no_didit\n     */\n    @Test public void testRepeats() throws IOException, MidiUnavailableException, InvalidMidiDataException, UnableToParseException {\n        String[] trackEvents = getPlayerTrackEvents(\"sample-abc/SoundOutputTestRepeats.abc\");\n        String[] testEvents = new String[] {\n                \"Event: Unknown command 192 Pitch: 24  Tick: 0\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 8\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 72\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 72\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 136\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 136\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 200\",\n                \"Event: NOTE_ON  Pitch: 64  Tick: 200\",\n                \"Event: NOTE_OFF Pitch: 64  Tick: 264\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 264\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 328\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 328\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 392\",\n                \"Event: NOTE_ON  Pitch: 60  Tick: 392\",\n                \"Event: NOTE_OFF Pitch: 60  Tick: 456\",\n                \"Event: NOTE_ON  Pitch: 62  Tick: 456\",\n                \"Event: NOTE_OFF Pitch: 62  Tick: 520\",\n                \"Meta event: END_OF_TRACK Tick: 520\"   \n        };\n        checkEvents(trackEvents, testEvents);\n    }\n}\n",
    "submission": 36368,
    "created": "2018-05-18T07:43:56"
  }
},
{
  "model": "review.file",
  "pk": 286213,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/fa18/code/ps0/preview/avl/6031-fa18-ps0-avl-53eb6177e2b675cbff1b064f0c84ef7adae01428/src/turtle/TurtleSoup.java",
    "data": "/* Copyright (c) 2007-2018 MIT 6.005/6.031 course staff, all rights reserved.\n * Redistribution of original or derived work requires permission of course staff.\n */\npackage turtle;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class TurtleSoup {\n\n    /**\n     * Draw a square.\n     * \n     * @param turtle the turtle context\n     * @param sideLength length of each side, must be >= 0\n     */\n    public static void drawSquare(Turtle turtle, int sideLength) {\n        throw new RuntimeException(\"implement me!\");\n    }\n\n    /**\n     * Determine inside angles of a regular polygon.\n     * \n     * There is a simple formula for calculating the inside angles of a polygon;\n     * you should derive it and use it here.\n     * \n     * @param sides number of sides, where sides must be > 2\n     * @return angle in degrees, where 0 <= angle < 360\n     */\n    public static double calculateRegularPolygonAngle(int sides) {\n        throw new RuntimeException(\"implement me!\");\n    }\n\n    /**\n     * Draw a regular polygon, using only right-hand turns.\n     * \n     * @param turtle the turtle context\n     * @param sides number of sides of the polygon to draw, where sides must be > 2\n     * @param sideLength length of each side, must be >= 0\n     */\n    public static void drawRegularPolygon(Turtle turtle, int sides, int sideLength) {\n        throw new RuntimeException(\"implement me!\");\n    }\n\n    /**\n     * Given a turtle's current heading direction and location, plus a target point, calculate the bearing\n     * of the target point.\n     * \n     * A bearing is the angle that the turtle's heading would have to change in order to point straight \n     * at the target point. \n     * \n     * The return value is the angle input to turn() that would point the turtle in the direction of\n     * the target point (targetX,targetY), given that the turtle is already at the point\n     * (currentX,currentY) and is facing at angle currentHeading. The angle must be expressed in\n     * degrees, where 0 <= angle < 360. \n     *\n     * HINT: look at http://en.wikipedia.org/wiki/Atan2 and Java's math libraries\n     * \n     * @param currentHeading turtle's current heading direction, measured clockwise from north\n     * @param currentX turtle's current location x-coordinate\n     * @param currentY turtle's current location y-coordinate\n     * @param targetX target point x-coordinate\n     * @param targetY target point y-coordinate\n     * @return adjustment to heading (right turn amount) to get to target point,\n     *         must be 0 <= angle < 360\n     */\n    public static double calculateBearingToPoint(double currentHeading, \n                                                 double currentX, double currentY,\n                                                 double targetX, double targetY) {\n        throw new RuntimeException(\"implement me!\");\n    }\n\n    /**\n     * Given a sequence of points, calculate the heading adjustments needed to get from each point\n     * to the next.\n     * \n     * Assumes that the turtle starts at the first point given, facing up (i.e. 0 degrees).\n     * For each subsequent point, assumes that the turtle is still facing in the direction it was\n     * facing when it moved to the previous point.\n     * You should use calculateBearingToPoint() to implement this function.\n     * \n     * @param xCoords list of x-coordinates (must be same length as yCoords)\n     * @param yCoords list of y-coordinates (must be same length as xCoords)\n     * @return list of heading adjustments between points, of size 0 if (# of points) == 0,\n     *         otherwise of size (# of points) - 1\n     */\n    public static List<Double> calculateBearings(List<Double> xCoords, List<Double> yCoords) {\n        throw new RuntimeException(\"implement me!\");\n    }\n    \n    /**\n     * Given a set of points, calculate its convex hull, the smallest convex set that contains all the points.\n     * \n     * Hint: one way to implement this is https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n     * \n     * @param points  input points\n     * @return minimal subset of the input points that form the vertices of the perimeter of the convex hull.\n     */\n    public static Set<Point> convexHull(Set<Point> points) {\n        throw new RuntimeException(\"implement me!\");\n    }\n\n    /**\n     * Draw your personal, custom art.\n     * \n     * Many interesting images can be drawn using the simple implementation of a turtle.  For this\n     * function, draw something interesting; the complexity can be as little or as much as you want.\n     * \n     * @param turtle the turtle context\n     */\n    public static void drawPersonalArt(Turtle turtle) {\n        throw new RuntimeException(\"implement me!\");\n    }\n\n    /**\n     * Main method.\n     * \n     * This is the method that runs when you run \"java TurtleSoup\".\n     * \n     * @param args unused\n     */\n    public static void main(String args[]) {\n        DrawableTurtle turtle = new DrawableTurtle();\n\n        final int sideLength = 40;\n        drawSquare(turtle, sideLength);\n\n        // draw the window\n        turtle.draw();\n    }\n\n}\n",
    "submission": 36481,
    "created": "2018-08-27T14:57:30"
  }
},
{
  "model": "review.file",
  "pk": 286214,
  "fields": {
    "path": "/var/django/caesar/preprocessor/6.031/private/fa18/code/ps0/preview/amirf/6031-fa18-ps0-amirf-fc486b2a19e95ac50a5a01037cbb6cc7cb9c65e1/src/turtle/TurtleSoup.java",
    "data": "/* Copyright (c) 2007-2018 MIT 6.005/6.031 course staff, all rights reserved.\n * Redistribution of original or derived work requires permission of course staff.\n */\npackage turtle;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class TurtleSoup {\n\n    /**\n     * Draw a square.\n     * \n     * @param turtle the turtle context\n     * @param sideLength length of each side, must be >= 0\n     */\n    public static void drawSquare(Turtle turtle, int sideLength) {\n        final int squareSidesCount = 4;\n        drawRegularPolygon(turtle, squareSidesCount, sideLength);\n    }\n\n    /**\n     * Determine inside angles of a regular polygon.\n     * \n     * There is a simple formula for calculating the inside angles of a polygon;\n     * you should derive it and use it here.\n     * \n     * @param sides number of sides, where sides must be > 2\n     * @return angle in degrees, where 0 <= angle < 360\n     */\n    public static double calculateRegularPolygonAngle(int sides) {\n        // a regular polygon with n sides can be split into n-2 triangles (assuming n > 2)\n        int numTriangles = sides - 2;\n        // the sum of a triangle's interior angles is 180 degrees\n        final double triangleInteriorAngleSum = 180.0;\n        // so now for the regular polygon\n        double sumOfInsideAngles = triangleInteriorAngleSum * numTriangles;\n        double singleAngle = sumOfInsideAngles / sides;\n        return singleAngle;\n    }\n\n    /**\n     * Draw a regular polygon, using only right-hand turns.\n     * \n     * @param turtle the turtle context\n     * @param sides number of sides of the polygon to draw, where sides must be > 2\n     * @param sideLength length of each side, must be >= 0\n     */\n    public static void drawRegularPolygon(Turtle turtle, int sides, int sideLength) {\n        // convert the angle to a clockwise angle for valid input into turtle's turn method\n        final double clockwiseAngleToTurn = 180.0 - calculateRegularPolygonAngle(sides);\n        for (int i = 0; i < sides; i++) {\n            turtle.forward(sideLength);\n            turtle.turn(clockwiseAngleToTurn);\n        }\n    }\n\n    /**\n     * Given a turtle's current heading direction and location, plus a target point, calculate the bearing\n     * of the target point.\n     * \n     * A bearing is the angle that the turtle's heading would have to change in order to point straight \n     * at the target point. \n     * \n     * The return value is the angle input to turn() that would point the turtle in the direction of\n     * the target point (targetX,targetY), given that the turtle is already at the point\n     * (currentX,currentY) and is facing at angle currentHeading. The angle must be expressed in\n     * degrees, where 0 <= angle < 360. \n     *\n     * HINT: look at http://en.wikipedia.org/wiki/Atan2 and Java's math libraries\n     * \n     * @param currentHeading turtle's current heading direction, measured clockwise from north\n     * @param currentX turtle's current location x-coordinate\n     * @param currentY turtle's current location y-coordinate\n     * @param targetX target point x-coordinate\n     * @param targetY target point y-coordinate\n     * @return adjustment to heading (right turn amount) to get to target point,\n     *         must be 0 <= angle < 360\n     */\n    public static double calculateBearingToPoint(double currentHeading, \n                                                 double currentX, double currentY,\n                                                 double targetX, double targetY) {\n        double fullRevolutionInDegrees = 360.0;\n        double quarterRevolutionInDegrees = fullRevolutionInDegrees / 4;\n        // atan2 returns a counterclockwise angle in radians from the East direction\n        double initialRadiansAngle = Math.atan2(targetY - currentY, targetX - currentX); // [-PI, PI]\n        double initialDegreesAngle = Math.toDegrees(initialRadiansAngle); // [-180, 180]\n        // firstly, negate initialDegreesAngle to switch to clockwise angle measurement\n        // secondly, add a quarterRevolutionInDegrees to get bearing from North\n        double angleInTurtleFrame = quarterRevolutionInDegrees - initialDegreesAngle; // [-90, 270]\n        if (angleInTurtleFrame - currentHeading < 0) {\n            // we add a fullRevolutionInDegrees to get nonnegative angles as per postcondition\n            return angleInTurtleFrame - currentHeading + fullRevolutionInDegrees;\n        }\n        else {\n            return angleInTurtleFrame - currentHeading;\n        }\n        \n    }\n\n    /**\n     * Given a sequence of points, calculate the heading adjustments needed to get from each point\n     * to the next.\n     * \n     * Assumes that the turtle starts at the first point given, facing up (i.e. 0 degrees).\n     * For each subsequent point, assumes that the turtle is still facing in the direction it was\n     * facing when it moved to the previous point.\n     * You should use calculateBearingToPoint() to implement this function.\n     * \n     * @param xCoords list of x-coordinates (must be same length as yCoords)\n     * @param yCoords list of y-coordinates (must be same length as xCoords)\n     * @return list of heading adjustments between points, of size 0 if (# of points) == 0,\n     *         otherwise of size (# of points) - 1\n     */\n    public static List<Double> calculateBearings(List<Double> xCoords, List<Double> yCoords) {\n        final int fullRevolutionInDegrees = 360;\n        List<Double> bearingsList = new ArrayList<Double>();\n        if (xCoords.size() <= 1) {\n         // return empty list if 1 point or fewer\n            return bearingsList; \n        }\n        double turtleHeading = 0.0; // turtle starts facing up (i.e. 0 degrees)\n        double currX = xCoords.get(0); // initial point's x value  \n        double currY = yCoords.get(0); // initial point's y value\n        for (int i = 1; i < xCoords.size(); i++) {\n            double nextX = xCoords.get(i);\n            double nextY = yCoords.get(i);\n            double adjustment = calculateBearingToPoint(turtleHeading, currX, currY, nextX, nextY);\n            bearingsList.add(adjustment);\n            currX = nextX;\n            currY = nextY;\n            // use modulo to restrict the heading between [0, 360]\n            turtleHeading = (turtleHeading + adjustment) % fullRevolutionInDegrees;\n        }\n        return bearingsList;\n    }\n    \n    /**\n     * Returns the leftmost point found in the set points\n     * @param points input points, assumes nonempty\n     * @return the leftmost (smallest x-coord) point in points with the largest index \n     */\n    public static Point getLeftMostPoint(Set<Point> points) {\n        double smallestX = Double.POSITIVE_INFINITY;\n        Point leftMost = new Point(smallestX, smallestX);\n        for (Point p : points) {\n            if (p.x() < smallestX) {\n                smallestX = p.x();\n                leftMost = p;\n            }\n        }\n        return leftMost;   \n    }\n    \n    /**\n     * \n     * @param points input points\n     * @return an element in the Set points\n     */\n    public static Point getPoint(Set<Point> points) {\n        if (points.size() == 0) return null;\n        Point firstPoint = new Point(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n        for (Point p : points) {\n            firstPoint = new Point(p.x(), p.y());\n            break;\n        }\n        return firstPoint;\n    }\n    \n    /**\n     * Determines the spacial orientation of point q relative to the line from p to r\n     * @param p a point\n     * @param q a point\n     * @param r a point\n     * @return \"colinear\", \"clockwise\", or \"counterclockwise\" \n     *          based on p, q, and r's spacial orientation\n     */\n    public static String orientation(Point p, Point q, Point r)\n    {\n        // implementation based off https://www.geeksforgeeks.org/orientation-3-ordered-points/\n        // we consider the slope of the lines p-->q and q-->r\n        double pqLineDeltaX = q.x() - p.x();\n        double pqLineDeltaY = q.y() - p.y();\n        double qrLineDeltaX = r.x() - q.x();\n        double qrLineDeltaY = r.y() - q.y();\n        // use this alternate form to avoid division by zero\n        int qrSlopeRelativeTopqSlope = (int) ((pqLineDeltaY * qrLineDeltaX) - (pqLineDeltaX * qrLineDeltaY));\n        // check for the slope of line q-->r relative to line p-->q\n        if (qrSlopeRelativeTopqSlope == 0) {\n            return \"colinear\";\n        }\n        else if (qrSlopeRelativeTopqSlope > 0) {\n            return \"clockwise\";\n        }\n        else {\n            return \"counterclockwise\";\n        }\n    }\n    \n    /**\n     * Given a set of points, calculate its convex hull, the smallest convex set that contains all the points.\n     * \n     * Hint: one way to implement this is https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n     * \n     * @param points  input points\n     * @return minimal subset of the input points that form the vertices of the perimeter of the convex hull.\n     */\n    public static Set<Point> convexHull(Set<Point> points) {\n        // https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n        Set<Point> result = new HashSet<>();\n        // if there are fewer than three points, the points we have form the convex hull\n        if (points.size() < 3) {\n            for (Point p : points) {\n                result.add(p);\n            }\n            return result;\n        }\n        Point pointOnHull = getLeftMostPoint(points);\n        Point firstPoint = new Point(pointOnHull.x(), pointOnHull.y());\n        Point endPoint = new Point(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n        // loop around the outside (boundary) of the points\n        while ( ! (endPoint.equals(firstPoint))) {\n            // add the leftmost point to the convexHull and then pick and endPoint\n            result.add(pointOnHull);\n            endPoint = getPoint(points);\n            for (Point p : points) {\n                if ( ! (p.equals(endPoint))) {\n                    // if p is to the left of the line pointOnHull-->endPoint\n                    if ((endPoint.equals(pointOnHull)) || (orientation(pointOnHull, p, endPoint).equals(\"clockwise\"))) {\n                        endPoint = p;\n                    } \n                    // otherwise if p, pointOnHull, and endPoint are colinear\n                    // choose the endPoint with greatest distance from the pointOnHull\n                    else if (orientation(pointOnHull, p, endPoint).equals(\"colinear\")) {\n                        LineSegment pointOnHullToPointP = new LineSegment(pointOnHull.x(), pointOnHull.y(), p.x(), p.y(), PenColor.BLACK);\n                        LineSegment pointOnHullToendPoint = new LineSegment(pointOnHull.x(), pointOnHull.y(), endPoint.x(), endPoint.y(), PenColor.BLACK);\n                        if (pointOnHullToendPoint.length() <= pointOnHullToPointP.length()) endPoint = p;\n                    }\n                }\n            }\n            pointOnHull = endPoint;\n        }\n        return result;\n        \n    }\n\n    /**\n     * Draw your personal, custom art.\n     * \n     * Many interesting images can be drawn using the simple implementation of a turtle.  For this\n     * function, draw something interesting; the complexity can be as little or as much as you want.\n     * \n     * @param turtle the turtle context\n     */\n    public static void drawPersonalArt(Turtle turtle) {\n        // draws nested regular polgyons!\n        // change sides and sideLength for awesome results.\n        int sides, sideLength;\n        sides = 8;\n        sideLength = 80;\n        turtle.color(PenColor.RED);\n        while (sideLength != 0) {\n            drawRegularPolygon(turtle, sides, sideLength);\n            sideLength -= 5;\n        }\n//        turtle.color(PenColor.BLACK);\n        \n    }\n\n    /**\n     * Main method.\n     * \n     * This is the method that runs when you run \"java TurtleSoup\".\n     * \n     * @param args unused\n     */\n    public static void main(String args[]) {\n        DrawableTurtle turtle = new DrawableTurtle();\n        drawPersonalArt(turtle);\n        // draw the window\n        turtle.draw();\n        // checking for absence of Point(1.0, 0.0) in the convex hull\n        Set<Point> points = new HashSet<>();\n        points.add(new Point(0.0, 0.0));\n        points.add(new Point(1.0, 1.0));\n        points.add(new Point(2.0, 1.0));\n        points.add(new Point(1.0, -1.0));\n        points.add(new Point(1.0, 0.0));\n        System.out.println(points);\n        System.out.println(convexHull(points));\n    }\n\n}\n",
    "submission": 36482,
    "created": "2018-08-27T14:57:30"
  }
},
{
  "model": "review.chunk",
  "pk": 285374,
  "fields": {
    "file": 282896,
    "name": "HostnameExample",
    "start": 0,
    "end": 989,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 0,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285375,
  "fields": {
    "file": 282897,
    "name": "ScaleExample",
    "start": 0,
    "end": 3079,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 0,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285376,
  "fields": {
    "file": 282898,
    "name": "StreamingExample",
    "start": 0,
    "end": 9033,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 3,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285377,
  "fields": {
    "file": 282899,
    "name": "Main",
    "start": 0,
    "end": 3056,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 52,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285378,
  "fields": {
    "file": 282900,
    "name": "Server",
    "start": 0,
    "end": 7684,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 205,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285379,
  "fields": {
    "file": 282901,
    "name": "Abc",
    "start": 0,
    "end": 2109,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 52,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285380,
  "fields": {
    "file": 282902,
    "name": "AbcParser",
    "start": 0,
    "end": 13255,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 338,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285381,
  "fields": {
    "file": 282903,
    "name": "AbcReference",
    "start": 0,
    "end": 2541,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 87,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285382,
  "fields": {
    "file": 282904,
    "name": "Header",
    "start": 0,
    "end": 2221,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 75,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285383,
  "fields": {
    "file": 282905,
    "name": "LyricParser",
    "start": 0,
    "end": 7098,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 212,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285384,
  "fields": {
    "file": 282906,
    "name": "Lyrics",
    "start": 0,
    "end": 350,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 25,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285385,
  "fields": {
    "file": 282907,
    "name": "PieceParser",
    "start": 0,
    "end": 18959,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 380,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285386,
  "fields": {
    "file": 282908,
    "name": "StaffParser",
    "start": 0,
    "end": 7565,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 186,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285387,
  "fields": {
    "file": 282909,
    "name": "music",
    "start": 0,
    "end": 867,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 38,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285388,
  "fields": {
    "file": 282910,
    "name": "Chord",
    "start": 0,
    "end": 3939,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 138,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285389,
  "fields": {
    "file": 282911,
    "name": "Instrument",
    "start": 0,
    "end": 2470,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 0,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285390,
  "fields": {
    "file": 282912,
    "name": "LyricLine",
    "start": 0,
    "end": 14783,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 402,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285391,
  "fields": {
    "file": 282913,
    "name": "MidiSequencePlayer",
    "start": 0,
    "end": 11953,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 22,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285392,
  "fields": {
    "file": 282914,
    "name": "Music",
    "start": 0,
    "end": 10506,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 325,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285393,
  "fields": {
    "file": 282915,
    "name": "Note",
    "start": 0,
    "end": 7691,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:54",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 228,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285394,
  "fields": {
    "file": 282916,
    "name": "Piece",
    "start": 0,
    "end": 14741,
    "cluster_id": null,
    "created": "2018-05-18T07:43:54",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 464,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285395,
  "fields": {
    "file": 282917,
    "name": "Pitch",
    "start": 0,
    "end": 3458,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 6,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285396,
  "fields": {
    "file": 282918,
    "name": "Rest",
    "start": 0,
    "end": 2227,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 98,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285397,
  "fields": {
    "file": 282919,
    "name": "SequencePlayer",
    "start": 0,
    "end": 1360,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 0,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285398,
  "fields": {
    "file": 282920,
    "name": "Staff",
    "start": 0,
    "end": 15142,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 392,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285399,
  "fields": {
    "file": 282921,
    "name": "Tuplet",
    "start": 0,
    "end": 5302,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 181,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285400,
  "fields": {
    "file": 282922,
    "name": "HeadersFilter",
    "start": 0,
    "end": 1051,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 36,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285401,
  "fields": {
    "file": 282923,
    "name": "LogFilter",
    "start": 0,
    "end": 1035,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 32,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285402,
  "fields": {
    "file": 282924,
    "name": "ServerTest",
    "start": 0,
    "end": 1391,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 67,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285403,
  "fields": {
    "file": 282925,
    "name": "LyricParserTest",
    "start": 0,
    "end": 9529,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 235,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285404,
  "fields": {
    "file": 282926,
    "name": "PieceParserTest",
    "start": 0,
    "end": 43176,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 341,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285405,
  "fields": {
    "file": 282927,
    "name": "StaffParserTest",
    "start": 0,
    "end": 10745,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 261,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285406,
  "fields": {
    "file": 282928,
    "name": "ChordTest",
    "start": 0,
    "end": 8335,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 235,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285407,
  "fields": {
    "file": 282929,
    "name": "MusicTest",
    "start": 0,
    "end": 14344,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 423,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285408,
  "fields": {
    "file": 282930,
    "name": "NoteTest",
    "start": 0,
    "end": 3837,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 118,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285409,
  "fields": {
    "file": 282931,
    "name": "PieceTest",
    "start": 0,
    "end": 39617,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 449,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285410,
  "fields": {
    "file": 282932,
    "name": "RestTest",
    "start": 0,
    "end": 1186,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 48,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285411,
  "fields": {
    "file": 282933,
    "name": "SequencePlayerTest",
    "start": 0,
    "end": 13272,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 309,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285412,
  "fields": {
    "file": 282934,
    "name": "StaffTest",
    "start": 0,
    "end": 12613,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 303,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285413,
  "fields": {
    "file": 282935,
    "name": "TupletTest",
    "start": 0,
    "end": 5195,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 139,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285414,
  "fields": {
    "file": 282936,
    "name": "happyBirthdayBrent",
    "start": 0,
    "end": 3620,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 111,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285415,
  "fields": {
    "file": 282937,
    "name": "LyricElement",
    "start": 0,
    "end": 549,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 26,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285416,
  "fields": {
    "file": 282938,
    "name": "LyricPlayer",
    "start": 0,
    "end": 16529,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 407,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285417,
  "fields": {
    "file": 282939,
    "name": "Lyrics",
    "start": 0,
    "end": 3143,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 98,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285418,
  "fields": {
    "file": 282940,
    "name": "Syllable",
    "start": 0,
    "end": 907,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 33,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285419,
  "fields": {
    "file": 282941,
    "name": "HostnameExample",
    "start": 0,
    "end": 1204,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 3,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285420,
  "fields": {
    "file": 282942,
    "name": "ScaleExample",
    "start": 0,
    "end": 3220,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 75,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285421,
  "fields": {
    "file": 282943,
    "name": "StreamingExample",
    "start": 0,
    "end": 9061,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 0,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285422,
  "fields": {
    "file": 282944,
    "name": "Chord",
    "start": 0,
    "end": 2931,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 113,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285423,
  "fields": {
    "file": 282945,
    "name": "Composition",
    "start": 0,
    "end": 2057,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 83,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285424,
  "fields": {
    "file": 282946,
    "name": "Concat",
    "start": 0,
    "end": 2586,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 104,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285425,
  "fields": {
    "file": 282947,
    "name": "Header",
    "start": 0,
    "end": 3468,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 128,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285426,
  "fields": {
    "file": 282948,
    "name": "LyricListener",
    "start": 0,
    "end": 1605,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 53,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285427,
  "fields": {
    "file": 282949,
    "name": "Main",
    "start": 0,
    "end": 5573,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 102,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285428,
  "fields": {
    "file": 282950,
    "name": "MultipleVoice",
    "start": 0,
    "end": 3129,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 105,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285429,
  "fields": {
    "file": 282951,
    "name": "Music",
    "start": 0,
    "end": 1144,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 41,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285430,
  "fields": {
    "file": 282952,
    "name": "Note",
    "start": 0,
    "end": 3367,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 125,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285431,
  "fields": {
    "file": 282953,
    "name": "Rest",
    "start": 0,
    "end": 1682,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 78,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285432,
  "fields": {
    "file": 282954,
    "name": "Pitch",
    "start": 0,
    "end": 3284,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 126,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285433,
  "fields": {
    "file": 282955,
    "name": "Abc",
    "start": 0,
    "end": 2233,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 64,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285434,
  "fields": {
    "file": 282956,
    "name": "KaraokeParser",
    "start": 0,
    "end": 34851,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 768,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285435,
  "fields": {
    "file": 282957,
    "name": "HeadersFilter",
    "start": 0,
    "end": 889,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 31,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285436,
  "fields": {
    "file": 282958,
    "name": "Instrument",
    "start": 0,
    "end": 2470,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 0,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285437,
  "fields": {
    "file": 282959,
    "name": "LogFilter",
    "start": 0,
    "end": 872,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 26,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285438,
  "fields": {
    "file": 282960,
    "name": "MidiSequencePlayer",
    "start": 0,
    "end": 11662,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 24,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285439,
  "fields": {
    "file": 282961,
    "name": "MusicPlayer",
    "start": 0,
    "end": 1784,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 50,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285440,
  "fields": {
    "file": 282962,
    "name": "Pitch",
    "start": 0,
    "end": 3290,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 0,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285441,
  "fields": {
    "file": 282963,
    "name": "SequencePlayer",
    "start": 0,
    "end": 1386,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 1,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285442,
  "fields": {
    "file": 282964,
    "name": "WebServer",
    "start": 0,
    "end": 6405,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:55",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 179,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285443,
  "fields": {
    "file": 282965,
    "name": "KaraokeParserTest",
    "start": 0,
    "end": 6940,
    "cluster_id": null,
    "created": "2018-05-18T07:43:55",
    "modified": "2018-05-18T07:43:56",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 150,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285444,
  "fields": {
    "file": 282966,
    "name": "LyricsTest",
    "start": 0,
    "end": 17665,
    "cluster_id": null,
    "created": "2018-05-18T07:43:56",
    "modified": "2018-05-18T07:43:56",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 450,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285445,
  "fields": {
    "file": 282967,
    "name": "SequencePlayerTest",
    "start": 0,
    "end": 3465,
    "cluster_id": null,
    "created": "2018-05-18T07:43:56",
    "modified": "2018-05-18T07:43:56",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 61,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285446,
  "fields": {
    "file": 282968,
    "name": "SequencePlayerTestHelper",
    "start": 0,
    "end": 7110,
    "cluster_id": null,
    "created": "2018-05-18T07:43:56",
    "modified": "2018-05-18T07:43:56",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 200,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 285447,
  "fields": {
    "file": 282969,
    "name": "SoundOutputTest",
    "start": 0,
    "end": 15752,
    "cluster_id": null,
    "created": "2018-05-18T07:43:56",
    "modified": "2018-05-18T07:43:56",
    "class_type": "test",
    "staff_portion": 0,
    "student_lines": 322,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 288691,
  "fields": {
    "file": 286213,
    "name": "TurtleSoup",
    "start": 0,
    "end": 5147,
    "cluster_id": null,
    "created": "2018-08-27T14:57:30",
    "modified": "2018-08-27T14:57:30",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 135,
    "chunk_info": null
  }
},
{
  "model": "review.chunk",
  "pk": 288692,
  "fields": {
    "file": 286214,
    "name": "TurtleSoup",
    "start": 0,
    "end": 12599,
    "cluster_id": null,
    "created": "2018-08-27T14:57:30",
    "modified": "2018-08-27T14:57:30",
    "class_type": "none",
    "staff_portion": 0,
    "student_lines": 297,
    "chunk_info": null
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884856,
  "fields": {
    "chunk": 285374,
    "start_line": 1,
    "end_line": 31
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884857,
  "fields": {
    "chunk": 285375,
    "start_line": 1,
    "end_line": 77
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884858,
  "fields": {
    "chunk": 285376,
    "start_line": 1,
    "end_line": 146
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884859,
  "fields": {
    "chunk": 285376,
    "start_line": 148,
    "end_line": 148
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884860,
  "fields": {
    "chunk": 285376,
    "start_line": 150,
    "end_line": 151
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884861,
  "fields": {
    "chunk": 285376,
    "start_line": 153,
    "end_line": 229
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884862,
  "fields": {
    "chunk": 285377,
    "start_line": 1,
    "end_line": 2
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884863,
  "fields": {
    "chunk": 285377,
    "start_line": 15,
    "end_line": 15
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884864,
  "fields": {
    "chunk": 285377,
    "start_line": 19,
    "end_line": 21
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884865,
  "fields": {
    "chunk": 285377,
    "start_line": 24,
    "end_line": 27
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884866,
  "fields": {
    "chunk": 285377,
    "start_line": 34,
    "end_line": 34
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884867,
  "fields": {
    "chunk": 285377,
    "start_line": 37,
    "end_line": 37
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884868,
  "fields": {
    "chunk": 285377,
    "start_line": 40,
    "end_line": 40
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884869,
  "fields": {
    "chunk": 285377,
    "start_line": 45,
    "end_line": 45
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884870,
  "fields": {
    "chunk": 285377,
    "start_line": 50,
    "end_line": 50
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884871,
  "fields": {
    "chunk": 285377,
    "start_line": 57,
    "end_line": 58
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884872,
  "fields": {
    "chunk": 285377,
    "start_line": 61,
    "end_line": 63
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884873,
  "fields": {
    "chunk": 285377,
    "start_line": 66,
    "end_line": 66
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884874,
  "fields": {
    "chunk": 285377,
    "start_line": 74,
    "end_line": 77
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884875,
  "fields": {
    "chunk": 285379,
    "start_line": 2,
    "end_line": 3
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884876,
  "fields": {
    "chunk": 285379,
    "start_line": 5,
    "end_line": 5
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884877,
  "fields": {
    "chunk": 285379,
    "start_line": 15,
    "end_line": 15
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884878,
  "fields": {
    "chunk": 285379,
    "start_line": 20,
    "end_line": 20
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884879,
  "fields": {
    "chunk": 285379,
    "start_line": 23,
    "end_line": 23
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884880,
  "fields": {
    "chunk": 285379,
    "start_line": 25,
    "end_line": 26
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884881,
  "fields": {
    "chunk": 285379,
    "start_line": 30,
    "end_line": 30
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884882,
  "fields": {
    "chunk": 285379,
    "start_line": 33,
    "end_line": 33
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884883,
  "fields": {
    "chunk": 285379,
    "start_line": 39,
    "end_line": 39
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884884,
  "fields": {
    "chunk": 285379,
    "start_line": 42,
    "end_line": 42
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884885,
  "fields": {
    "chunk": 285379,
    "start_line": 45,
    "end_line": 45
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884886,
  "fields": {
    "chunk": 285379,
    "start_line": 47,
    "end_line": 47
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884887,
  "fields": {
    "chunk": 285379,
    "start_line": 51,
    "end_line": 51
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884888,
  "fields": {
    "chunk": 285379,
    "start_line": 54,
    "end_line": 54
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884889,
  "fields": {
    "chunk": 285379,
    "start_line": 57,
    "end_line": 57
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884890,
  "fields": {
    "chunk": 285379,
    "start_line": 61,
    "end_line": 61
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884891,
  "fields": {
    "chunk": 285379,
    "start_line": 65,
    "end_line": 66
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884892,
  "fields": {
    "chunk": 285379,
    "start_line": 69,
    "end_line": 69
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884893,
  "fields": {
    "chunk": 285379,
    "start_line": 71,
    "end_line": 71
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884894,
  "fields": {
    "chunk": 285379,
    "start_line": 75,
    "end_line": 76
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884895,
  "fields": {
    "chunk": 285389,
    "start_line": 1,
    "end_line": 157
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884896,
  "fields": {
    "chunk": 285391,
    "start_line": 1,
    "end_line": 11
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884897,
  "fields": {
    "chunk": 285391,
    "start_line": 24,
    "end_line": 59
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884898,
  "fields": {
    "chunk": 285391,
    "start_line": 61,
    "end_line": 211
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884899,
  "fields": {
    "chunk": 285391,
    "start_line": 214,
    "end_line": 214
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884900,
  "fields": {
    "chunk": 285391,
    "start_line": 217,
    "end_line": 219
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884901,
  "fields": {
    "chunk": 285391,
    "start_line": 222,
    "end_line": 222
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884902,
  "fields": {
    "chunk": 285391,
    "start_line": 226,
    "end_line": 329
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884903,
  "fields": {
    "chunk": 285395,
    "start_line": 1,
    "end_line": 26
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884904,
  "fields": {
    "chunk": 285395,
    "start_line": 29,
    "end_line": 55
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884905,
  "fields": {
    "chunk": 285395,
    "start_line": 59,
    "end_line": 59
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884906,
  "fields": {
    "chunk": 285395,
    "start_line": 61,
    "end_line": 134
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884907,
  "fields": {
    "chunk": 285397,
    "start_line": 1,
    "end_line": 40
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884908,
  "fields": {
    "chunk": 285411,
    "start_line": 1,
    "end_line": 2
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884909,
  "fields": {
    "chunk": 285411,
    "start_line": 6,
    "end_line": 6
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884910,
  "fields": {
    "chunk": 285411,
    "start_line": 9,
    "end_line": 11
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884911,
  "fields": {
    "chunk": 285411,
    "start_line": 17,
    "end_line": 23
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884912,
  "fields": {
    "chunk": 285411,
    "start_line": 323,
    "end_line": 327
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884913,
  "fields": {
    "chunk": 285419,
    "start_line": 1,
    "end_line": 23
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884914,
  "fields": {
    "chunk": 285419,
    "start_line": 27,
    "end_line": 35
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884915,
  "fields": {
    "chunk": 285420,
    "start_line": 76,
    "end_line": 76
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884916,
  "fields": {
    "chunk": 285421,
    "start_line": 1,
    "end_line": 229
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884917,
  "fields": {
    "chunk": 285427,
    "start_line": 1,
    "end_line": 2
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884918,
  "fields": {
    "chunk": 285427,
    "start_line": 22,
    "end_line": 23
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884919,
  "fields": {
    "chunk": 285427,
    "start_line": 31,
    "end_line": 34
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884920,
  "fields": {
    "chunk": 285427,
    "start_line": 40,
    "end_line": 40
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884921,
  "fields": {
    "chunk": 285427,
    "start_line": 42,
    "end_line": 42
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884922,
  "fields": {
    "chunk": 285427,
    "start_line": 47,
    "end_line": 47
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884923,
  "fields": {
    "chunk": 285427,
    "start_line": 54,
    "end_line": 55
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884924,
  "fields": {
    "chunk": 285427,
    "start_line": 62,
    "end_line": 62
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884925,
  "fields": {
    "chunk": 285427,
    "start_line": 72,
    "end_line": 72
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884926,
  "fields": {
    "chunk": 285427,
    "start_line": 75,
    "end_line": 75
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884927,
  "fields": {
    "chunk": 285427,
    "start_line": 77,
    "end_line": 77
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884928,
  "fields": {
    "chunk": 285427,
    "start_line": 85,
    "end_line": 88
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884929,
  "fields": {
    "chunk": 285427,
    "start_line": 92,
    "end_line": 92
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884930,
  "fields": {
    "chunk": 285427,
    "start_line": 95,
    "end_line": 98
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884931,
  "fields": {
    "chunk": 285427,
    "start_line": 102,
    "end_line": 102
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884932,
  "fields": {
    "chunk": 285427,
    "start_line": 118,
    "end_line": 118
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884933,
  "fields": {
    "chunk": 285427,
    "start_line": 120,
    "end_line": 122
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884934,
  "fields": {
    "chunk": 285427,
    "start_line": 126,
    "end_line": 126
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884935,
  "fields": {
    "chunk": 285427,
    "start_line": 134,
    "end_line": 138
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884936,
  "fields": {
    "chunk": 285427,
    "start_line": 140,
    "end_line": 142
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884937,
  "fields": {
    "chunk": 285433,
    "start_line": 6,
    "end_line": 6
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884938,
  "fields": {
    "chunk": 285433,
    "start_line": 12,
    "end_line": 12
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884939,
  "fields": {
    "chunk": 285433,
    "start_line": 17,
    "end_line": 17
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884940,
  "fields": {
    "chunk": 285433,
    "start_line": 32,
    "end_line": 32
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884941,
  "fields": {
    "chunk": 285433,
    "start_line": 35,
    "end_line": 35
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884942,
  "fields": {
    "chunk": 285433,
    "start_line": 40,
    "end_line": 40
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884943,
  "fields": {
    "chunk": 285433,
    "start_line": 43,
    "end_line": 43
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884944,
  "fields": {
    "chunk": 285433,
    "start_line": 46,
    "end_line": 46
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884945,
  "fields": {
    "chunk": 285433,
    "start_line": 49,
    "end_line": 49
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884946,
  "fields": {
    "chunk": 285433,
    "start_line": 53,
    "end_line": 53
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884947,
  "fields": {
    "chunk": 285433,
    "start_line": 56,
    "end_line": 56
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884948,
  "fields": {
    "chunk": 285433,
    "start_line": 59,
    "end_line": 59
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884949,
  "fields": {
    "chunk": 285433,
    "start_line": 65,
    "end_line": 65
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884950,
  "fields": {
    "chunk": 285433,
    "start_line": 67,
    "end_line": 67
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884951,
  "fields": {
    "chunk": 285433,
    "start_line": 70,
    "end_line": 70
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884952,
  "fields": {
    "chunk": 285433,
    "start_line": 73,
    "end_line": 73
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884953,
  "fields": {
    "chunk": 285433,
    "start_line": 75,
    "end_line": 75
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884954,
  "fields": {
    "chunk": 285433,
    "start_line": 78,
    "end_line": 78
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884955,
  "fields": {
    "chunk": 285433,
    "start_line": 80,
    "end_line": 80
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884956,
  "fields": {
    "chunk": 285433,
    "start_line": 84,
    "end_line": 84
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884957,
  "fields": {
    "chunk": 285436,
    "start_line": 1,
    "end_line": 157
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884958,
  "fields": {
    "chunk": 285438,
    "start_line": 1,
    "end_line": 11
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884959,
  "fields": {
    "chunk": 285438,
    "start_line": 13,
    "end_line": 38
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884960,
  "fields": {
    "chunk": 285438,
    "start_line": 40,
    "end_line": 71
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884961,
  "fields": {
    "chunk": 285438,
    "start_line": 73,
    "end_line": 113
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884962,
  "fields": {
    "chunk": 285438,
    "start_line": 119,
    "end_line": 123
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884963,
  "fields": {
    "chunk": 285438,
    "start_line": 125,
    "end_line": 127
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884964,
  "fields": {
    "chunk": 285438,
    "start_line": 130,
    "end_line": 147
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884965,
  "fields": {
    "chunk": 285438,
    "start_line": 149,
    "end_line": 157
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884966,
  "fields": {
    "chunk": 285438,
    "start_line": 161,
    "end_line": 162
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884967,
  "fields": {
    "chunk": 285438,
    "start_line": 164,
    "end_line": 164
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884968,
  "fields": {
    "chunk": 285438,
    "start_line": 167,
    "end_line": 183
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884969,
  "fields": {
    "chunk": 285438,
    "start_line": 185,
    "end_line": 186
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884970,
  "fields": {
    "chunk": 285438,
    "start_line": 188,
    "end_line": 199
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884971,
  "fields": {
    "chunk": 285438,
    "start_line": 201,
    "end_line": 204
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884972,
  "fields": {
    "chunk": 285438,
    "start_line": 207,
    "end_line": 269
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884973,
  "fields": {
    "chunk": 285438,
    "start_line": 271,
    "end_line": 318
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884974,
  "fields": {
    "chunk": 285440,
    "start_line": 1,
    "end_line": 126
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884975,
  "fields": {
    "chunk": 285441,
    "start_line": 1,
    "end_line": 4
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884976,
  "fields": {
    "chunk": 285441,
    "start_line": 6,
    "end_line": 42
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884977,
  "fields": {
    "chunk": 285445,
    "start_line": 1,
    "end_line": 2
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884978,
  "fields": {
    "chunk": 285445,
    "start_line": 5,
    "end_line": 7
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884979,
  "fields": {
    "chunk": 285445,
    "start_line": 9,
    "end_line": 11
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884980,
  "fields": {
    "chunk": 285445,
    "start_line": 13,
    "end_line": 15
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884981,
  "fields": {
    "chunk": 285445,
    "start_line": 20,
    "end_line": 20
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884982,
  "fields": {
    "chunk": 285445,
    "start_line": 25,
    "end_line": 25
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884983,
  "fields": {
    "chunk": 285445,
    "start_line": 27,
    "end_line": 28
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884984,
  "fields": {
    "chunk": 285445,
    "start_line": 33,
    "end_line": 33
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884985,
  "fields": {
    "chunk": 285445,
    "start_line": 38,
    "end_line": 38
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884986,
  "fields": {
    "chunk": 285445,
    "start_line": 40,
    "end_line": 41
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884987,
  "fields": {
    "chunk": 285445,
    "start_line": 46,
    "end_line": 46
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884988,
  "fields": {
    "chunk": 285445,
    "start_line": 49,
    "end_line": 49
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884989,
  "fields": {
    "chunk": 285445,
    "start_line": 52,
    "end_line": 52
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884990,
  "fields": {
    "chunk": 285445,
    "start_line": 54,
    "end_line": 55
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884991,
  "fields": {
    "chunk": 285445,
    "start_line": 65,
    "end_line": 66
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884992,
  "fields": {
    "chunk": 285445,
    "start_line": 69,
    "end_line": 69
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884993,
  "fields": {
    "chunk": 285445,
    "start_line": 73,
    "end_line": 73
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884994,
  "fields": {
    "chunk": 285445,
    "start_line": 75,
    "end_line": 75
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884995,
  "fields": {
    "chunk": 285445,
    "start_line": 78,
    "end_line": 78
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884996,
  "fields": {
    "chunk": 285445,
    "start_line": 81,
    "end_line": 81
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884997,
  "fields": {
    "chunk": 285445,
    "start_line": 90,
    "end_line": 91
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884998,
  "fields": {
    "chunk": 285445,
    "start_line": 93,
    "end_line": 94
  }
},
{
  "model": "review.staffmarker",
  "pk": 3884999,
  "fields": {
    "chunk": 285445,
    "start_line": 97,
    "end_line": 99
  }
},
{
  "model": "review.comment",
  "pk": 688400,
  "fields": {
    "text": "#design type of soundedelements?",
    "chunk": 285429,
    "author": [
      "ksmori"
    ],
    "start": 17,
    "end": 17,
    "type": "U",
    "created": "2018-05-20T14:16:29",
    "modified": "2018-05-20T14:16:29",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688400,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688404,
  "fields": {
    "text": "#design FYI because duration is specced in your Music interface class, you don't necessary need to copy the spec here",
    "chunk": 285430,
    "author": [
      "ksmori"
    ],
    "start": 56,
    "end": 56,
    "type": "U",
    "created": "2018-05-20T14:18:29",
    "modified": "2018-05-20T14:18:29",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688404,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688406,
  "fields": {
    "text": "#design these non-terminals don't have the best names. For example, it's not obvious that \"l\" refers to the default beat length",
    "chunk": 285433,
    "author": [
      "ksmori"
    ],
    "start": 13,
    "end": 13,
    "type": "U",
    "created": "2018-05-20T14:20:08",
    "modified": "2018-05-20T14:20:08",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688406,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688408,
  "fields": {
    "text": "#design #coding while modularity of code is generally a good thing, it looks like the way you have split up parsing seems a bit convoluded to me and more complex than it needs to be. I honestly am having a lot of trouble following how your parser is working across the different grammars and parser files.",
    "chunk": 285380,
    "author": [
      "caronoff"
    ],
    "start": 23,
    "end": 23,
    "type": "U",
    "created": "2018-05-20T14:21:04",
    "modified": "2018-05-20T14:21:04",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688408,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688409,
  "fields": {
    "text": "#design AF doesn't include full rep.",
    "chunk": 285378,
    "author": [
      "caronoff"
    ],
    "start": 25,
    "end": 25,
    "type": "U",
    "created": "2018-05-20T14:21:33",
    "modified": "2018-05-20T14:21:33",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688409,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688410,
  "fields": {
    "text": "#design I like this static lookup map. Could also wrap it in an unmodifiable wrapper!",
    "chunk": 285434,
    "author": [
      "ksmori"
    ],
    "start": 27,
    "end": 27,
    "type": "U",
    "created": "2018-05-20T14:21:34",
    "modified": "2018-05-20T14:22:03",
    "edited": "2018-05-20T14:22:03",
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688410,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688412,
  "fields": {
    "text": "#design This is not a rep invariant, but rather a description of what a variable (that isn't a rep field) is abstractly representing.",
    "chunk": 285378,
    "author": [
      "caronoff"
    ],
    "start": 31,
    "end": 31,
    "type": "U",
    "created": "2018-05-20T14:22:21",
    "modified": "2018-05-20T14:22:21",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688412,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688413,
  "fields": {
    "text": "#coding remove unused code",
    "chunk": 285434,
    "author": [
      "ksmori"
    ],
    "start": 47,
    "end": 47,
    "type": "U",
    "created": "2018-05-20T14:22:23",
    "modified": "2018-05-20T14:22:23",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688413,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688415,
  "fields": {
    "text": "#design this doesn't seem like the best spec for this method, especially when the return type is Composition?",
    "chunk": 285434,
    "author": [
      "ksmori"
    ],
    "start": 121,
    "end": 125,
    "type": "U",
    "created": "2018-05-20T14:23:44",
    "modified": "2018-05-20T14:23:44",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688415,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688417,
  "fields": {
    "text": "#design good use of datatype",
    "chunk": 285434,
    "author": [
      "ksmori"
    ],
    "start": 152,
    "end": 152,
    "type": "U",
    "created": "2018-05-20T14:24:39",
    "modified": "2018-05-20T14:24:39",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688417,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688418,
  "fields": {
    "text": "#design does not check your RI (that notes must have length > 0). It is checked in the constructor itself which is better than nothing, but it should be checked in checkRep. #coding.",
    "chunk": 285388,
    "author": [
      "caronoff"
    ],
    "start": 47,
    "end": 47,
    "type": "U",
    "created": "2018-05-20T14:25:10",
    "modified": "2018-05-20T14:25:10",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688418,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688419,
  "fields": {
    "text": "#design try avoiding using Strings for stuff like this...",
    "chunk": 285434,
    "author": [
      "ksmori"
    ],
    "start": 269,
    "end": 269,
    "type": "U",
    "created": "2018-05-20T14:26:07",
    "modified": "2018-05-20T14:26:07",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688419,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688423,
  "fields": {
    "text": "#design the Music datatype is claimed immutable, but this is a mutator. It may have made more sense to not have MultipleVoice as a variant.",
    "chunk": 285428,
    "author": [
      "ksmori"
    ],
    "start": 45,
    "end": 45,
    "type": "U",
    "created": "2018-05-20T14:27:59",
    "modified": "2018-05-20T14:27:59",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688423,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688429,
  "fields": {
    "text": "#design in general, I like your use of static methods to create the various parts of your Music objects",
    "chunk": 285434,
    "author": [
      "ksmori"
    ],
    "start": 25,
    "end": 25,
    "type": "U",
    "created": "2018-05-20T14:29:43",
    "modified": "2018-05-20T14:29:43",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688429,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688436,
  "fields": {
    "text": "#coding should remove all unused code",
    "chunk": 285416,
    "author": [
      "ksmori"
    ],
    "start": 1,
    "end": 1,
    "type": "U",
    "created": "2018-05-20T14:31:45",
    "modified": "2018-05-20T14:31:45",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688436,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688438,
  "fields": {
    "text": "#design not immediately obvious what this is for",
    "chunk": 285427,
    "author": [
      "ksmori"
    ],
    "start": 82,
    "end": 82,
    "type": "U",
    "created": "2018-05-20T14:32:48",
    "modified": "2018-05-20T14:32:48",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688438,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688442,
  "fields": {
    "text": "#Design there's a lot in here that seems like it should probably be refactored out to some other places. For example, information like key signature details, math operations, and tuplet specific information don't seem to really belong here. It seems like you treated this interface as a catch-all utility method holder which is bad design.",
    "chunk": 285392,
    "author": [
      "caronoff"
    ],
    "start": 14,
    "end": 14,
    "type": "U",
    "created": "2018-05-20T14:34:02",
    "modified": "2018-05-20T15:06:43",
    "edited": "2018-05-20T15:06:43",
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688442,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688444,
  "fields": {
    "text": "#design this design choice caused your system to need both a web request and an enter in the console to play the music, which was very confusing. The requests for lyrics and playing should be separated.",
    "chunk": 285442,
    "author": [
      "ksmori"
    ],
    "start": 160,
    "end": 160,
    "type": "U",
    "created": "2018-05-20T14:34:29",
    "modified": "2018-05-20T14:34:29",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688444,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688446,
  "fields": {
    "text": "#design spec doesn't match the method.",
    "chunk": 285392,
    "author": [
      "caronoff"
    ],
    "start": 289,
    "end": 289,
    "type": "U",
    "created": "2018-05-20T14:35:38",
    "modified": "2018-05-20T14:35:38",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688446,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688447,
  "fields": {
    "text": "#design doesn't make sense to remake the music for each separate request (modular design)",
    "chunk": 285442,
    "author": [
      "ksmori"
    ],
    "start": 126,
    "end": 126,
    "type": "U",
    "created": "2018-05-20T14:36:18",
    "modified": "2018-05-20T14:36:18",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688447,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688448,
  "fields": {
    "text": "#design can't find thread safety argument",
    "chunk": 285442,
    "author": [
      "ksmori"
    ],
    "start": 42,
    "end": 42,
    "type": "U",
    "created": "2018-05-20T14:36:51",
    "modified": "2018-05-20T14:38:16",
    "edited": "2018-05-20T14:38:16",
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688448,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688449,
  "fields": {
    "text": "#design can't find thread safety argument",
    "chunk": 285442,
    "author": [
      "ksmori"
    ],
    "start": 42,
    "end": 42,
    "type": "U",
    "created": "2018-05-20T14:36:51",
    "modified": "2018-05-20T14:36:51",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688449,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688451,
  "fields": {
    "text": "#design only thread safety argument, but we really need one for the WebServer",
    "chunk": 285426,
    "author": [
      "ksmori"
    ],
    "start": 16,
    "end": 16,
    "type": "U",
    "created": "2018-05-20T14:38:39",
    "modified": "2018-05-20T14:38:39",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688451,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688456,
  "fields": {
    "text": "#testing detailed partitions for lyrics",
    "chunk": 285444,
    "author": [
      "ksmori"
    ],
    "start": 26,
    "end": 26,
    "type": "U",
    "created": "2018-05-20T14:44:03",
    "modified": "2018-05-20T14:44:03",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688456,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688461,
  "fields": {
    "text": "#testing missing testing for music ADT",
    "chunk": 285443,
    "author": [
      "ksmori"
    ],
    "start": 17,
    "end": 17,
    "type": "U",
    "created": "2018-05-20T14:45:10",
    "modified": "2018-05-20T14:45:10",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688461,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688462,
  "fields": {
    "text": "#design I don't think this really belongs here in the Staff itself. It really should be in a parser file somewhere.",
    "chunk": 285398,
    "author": [
      "caronoff"
    ],
    "start": 160,
    "end": 160,
    "type": "U",
    "created": "2018-05-20T14:45:19",
    "modified": "2018-05-20T14:46:33",
    "edited": "2018-05-20T14:46:33",
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688462,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688467,
  "fields": {
    "text": "#testing good automated testing for music playback",
    "chunk": 285447,
    "author": [
      "ksmori"
    ],
    "start": 19,
    "end": 19,
    "type": "U",
    "created": "2018-05-20T14:46:55",
    "modified": "2018-05-20T14:46:55",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688467,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688470,
  "fields": {
    "text": "#design I think there's more to it. Can a tuplet have infinite notes? 0 notes?",
    "chunk": 285399,
    "author": [
      "caronoff"
    ],
    "start": 21,
    "end": 21,
    "type": "U",
    "created": "2018-05-20T14:48:09",
    "modified": "2018-05-20T14:48:09",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688470,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688595,
  "fields": {
    "text": "#design I don't think you have included the filePath in the request. It forces files to be in your project folder. For example, if I'm trying to play ../../blah/foo/song.abc, the request no longer works.",
    "chunk": 285427,
    "author": [
      "ksmori"
    ],
    "start": 71,
    "end": 71,
    "type": "U",
    "created": "2018-05-20T15:47:08",
    "modified": "2018-05-20T15:47:08",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688595,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688625,
  "fields": {
    "text": "#design (not strictly for this file) You have 3 different grammar files in use. 2 of them are fully contained in this one. That makes your grammar very not DRY.",
    "chunk": 285382,
    "author": [
      "caronoff"
    ],
    "start": 6,
    "end": 6,
    "type": "U",
    "created": "2018-05-20T16:08:21",
    "modified": "2018-05-20T16:08:21",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688625,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 688800,
  "fields": {
    "text": "#coding general hygiene comment: any large commented out chunks like this should really just be deleted. Keeping them in makes code clunky to navigate and more difficult to read through.",
    "chunk": 285385,
    "author": [
      "caronoff"
    ],
    "start": 27,
    "end": 27,
    "type": "U",
    "created": "2018-05-20T19:34:15",
    "modified": "2018-05-20T19:34:15",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 688800,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 689066,
  "fields": {
    "text": "#testing nit pick: proper partition format would have >1 rather than n.",
    "chunk": 285403,
    "author": [
      "caronoff"
    ],
    "start": 28,
    "end": 28,
    "type": "U",
    "created": "2018-05-21T09:47:48",
    "modified": "2018-05-21T09:47:48",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 689066,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 689069,
  "fields": {
    "text": "#testing there are some missing cases here that would have been able to catch issues found in correctness testing. For example: accidentals that carry over in the measure and what kind of music (ex: Notes or Chords) are contained in Tuplets.",
    "chunk": 285405,
    "author": [
      "caronoff"
    ],
    "start": 20,
    "end": 20,
    "type": "U",
    "created": "2018-05-21T09:50:21",
    "modified": "2018-05-21T09:50:21",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 689069,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.comment",
  "pk": 689071,
  "fields": {
    "text": "#testing No strategy written and minimal testing written.",
    "chunk": 285402,
    "author": [
      "caronoff"
    ],
    "start": 18,
    "end": 18,
    "type": "U",
    "created": "2018-05-21T09:51:39",
    "modified": "2018-05-21T09:51:39",
    "edited": null,
    "parent": null,
    "upvote_count": 0,
    "downvote_count": 0,
    "thread_id": 689071,
    "deleted": false,
    "batch": null,
    "similar_comment": null
  }
},
{
  "model": "review.member",
  "pk": 3207,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "rcm"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3209,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "ksmori"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3210,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "mcslao"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3211,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "caronoff"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3212,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "lagrassa"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3213,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "lu16j"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3215,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "varot"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3216,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "zlily"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3236,
  "fields": {
    "role": "S",
    "slack_budget": 10,
    "user": [
      "yaatehr"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3278,
  "fields": {
    "role": "S",
    "slack_budget": 12,
    "user": [
      "nibr"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3318,
  "fields": {
    "role": "S",
    "slack_budget": 12,
    "user": [
      "sebatoro"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3330,
  "fields": {
    "role": "S",
    "slack_budget": 10,
    "user": [
      "amirf"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3352,
  "fields": {
    "role": "S",
    "slack_budget": 12,
    "user": [
      "umustafi"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3385,
  "fields": {
    "role": "S",
    "slack_budget": 10,
    "user": [
      "mayalk"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3415,
  "fields": {
    "role": "S",
    "slack_budget": 15,
    "user": [
      "avl"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3416,
  "fields": {
    "role": "S",
    "slack_budget": 10,
    "user": [
      "bcsam"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3419,
  "fields": {
    "role": "S",
    "slack_budget": 11,
    "user": [
      "cww"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3457,
  "fields": {
    "role": "S",
    "slack_budget": 10,
    "user": [
      "zhengt"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3465,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "a2z"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3473,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "jeaniep"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3476,
  "fields": {
    "role": "T",
    "slack_budget": 0,
    "user": [
      "psy01212"
    ],
    "semester": 18
  }
},
{
  "model": "review.member",
  "pk": 3489,
  "fields": {
    "role": "S",
    "slack_budget": 15,
    "user": [
      "avl"
    ],
    "semester": 19
  }
},
{
  "model": "review.member",
  "pk": 3490,
  "fields": {
    "role": "S",
    "slack_budget": 10,
    "user": [
      "amirf"
    ],
    "semester": 19
  }
},
{
  "model": "review.userprofile",
  "pk": 3,
  "fields": {
    "user": [
      "rcm"
    ],
    "reputation": 110
  }
},
{
  "model": "review.userprofile",
  "pk": 629,
  "fields": {
    "user": [
      "caronoff"
    ],
    "reputation": 158
  }
},
{
  "model": "review.userprofile",
  "pk": 1241,
  "fields": {
    "user": [
      "lu16j"
    ],
    "reputation": 240
  }
},
{
  "model": "review.userprofile",
  "pk": 1844,
  "fields": {
    "user": [
      "nibr"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 1902,
  "fields": {
    "user": [
      "zlily"
    ],
    "reputation": 117
  }
},
{
  "model": "review.userprofile",
  "pk": 1976,
  "fields": {
    "user": [
      "a2z"
    ],
    "reputation": 134
  }
},
{
  "model": "review.userprofile",
  "pk": 2142,
  "fields": {
    "user": [
      "psy01212"
    ],
    "reputation": 15
  }
},
{
  "model": "review.userprofile",
  "pk": 2173,
  "fields": {
    "user": [
      "varot"
    ],
    "reputation": 110
  }
},
{
  "model": "review.userprofile",
  "pk": 2258,
  "fields": {
    "user": [
      "jeaniep"
    ],
    "reputation": 138
  }
},
{
  "model": "review.userprofile",
  "pk": 2352,
  "fields": {
    "user": [
      "lagrassa"
    ],
    "reputation": 138
  }
},
{
  "model": "review.userprofile",
  "pk": 2364,
  "fields": {
    "user": [
      "mcslao"
    ],
    "reputation": 139
  }
},
{
  "model": "review.userprofile",
  "pk": 2428,
  "fields": {
    "user": [
      "zhengt"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 2683,
  "fields": {
    "user": [
      "ksmori"
    ],
    "reputation": 100
  }
},
{
  "model": "review.userprofile",
  "pk": 2987,
  "fields": {
    "user": [
      "avl"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 3209,
  "fields": {
    "user": [
      "cww"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 3316,
  "fields": {
    "user": [
      "yaatehr"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 3393,
  "fields": {
    "user": [
      "sebatoro"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 3405,
  "fields": {
    "user": [
      "amirf"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 3425,
  "fields": {
    "user": [
      "umustafi"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 3453,
  "fields": {
    "user": [
      "mayalk"
    ],
    "reputation": 0
  }
},
{
  "model": "review.userprofile",
  "pk": 3489,
  "fields": {
    "user": [
      "bcsam"
    ],
    "reputation": 0
  }
}
]
